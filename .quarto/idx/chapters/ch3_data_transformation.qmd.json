{"title":"数据处理","markdown":{"yaml":{"title":"数据处理","format":"html"},"headingText":"引言","containsRefs":false,"markdown":"\n\n\n可视化是数据分析时的重要手段，但前提是数据格式严格符合要求。因此针对格式不当的数据需要进行一些处理。\n\n本章主要介绍使用dplyr包对数据进行处理，dplyr同样归属于tidyverse。另外为了举例，还需加载含有纽约航班信息的包：\n\n``` r\n> library(nycflights13)\n> library(tidyverse)\n```\n\nnycflights13包中包含 2013 年从纽约市出发的所有 336,776 个航班，记录在`nycflights13::flights`里：\n\n``` r\nflights\n#> # A tibble: 336,776 × 19\n#>    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n#>   <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>\n#> 1  2013     1     1      517            515         2      830            819\n#> 2  2013     1     1      533            529         4      850            830\n#> 3  2013     1     1      542            540         2      923            850\n#> 4  2013     1     1      544            545        -1     1004           1022\n#> 5  2013     1     1      554            600        -6      812            837\n#> 6  2013     1     1      554            558        -4      740            728\n#> # ℹ 336,770 more rows\n#> # ℹ 11 more variables: arr_delay <dbl>, carrier <chr>, flight <int>, …\n```\n\n`flights`表格是一个 “Tibble”，这是一种特殊的数据框。Tibble 和普通数据框之间最重要的区别是其显示方式，tibble专为大型数据集而设计，因此它们仅显示前几行，并且仅显示适配屏幕大小的列。如果使用 RStudio操作则更方便，会打开一个可交互、可滚动、可筛选的视图。\n\n注意到表头下方用尖括号标注了数据类型，大致有：\n\n-   int 表示整数型变量。\n-   dbl表示双精度浮点数型变量，或称实数。\n-   chr 表示字符向量，或称字符串。\n-   lgl表示逻辑型变量，是一个仅包括 TRUE 和 FALSE 的向量。\n-   fctr 表示因子，R用其来表示具有固定数目的值的分类变量。\n-   date 表示日期型变量。\n-   dttm 表示日期时间(日期+时间)型变量。\n\n本章将学习5个dplyr核心函数，用于数据处理，大致为：\n\n-   按值筛选(`filter()`)。\n-   对行进行重新排序(`arrange()`)\n-   按名称选取变量(`select()`)\n-   使用现有变量的函数创建新变量(`mutate())`\n-   将多个值总结为一个摘要统计量(`summarize()`)\n\n上述5个函数的工作方式大致相同，有以下共通点：\n\n-   第一个参数是数据框。\n-   后续参数使用不带引号的变量名称，描述针对数据框进行的操作。\n-   输出结果是一个新数据框。\n\n下面对其一一阐述。\n\n## 行\n\n操作数据行的最主要函数为：\n\n-   `filter()`：用于筛选数据。改变的是**行的种类**，但**不改变顺序**；\n-   `arrange()`：用于排序。改变的是**行的顺序**，但**不改变行的内容**。\n\n这两个函数仅作用于行，不会修改列。\n\n此外，还有 `distinct()` 函数，用于查找具有唯一值的行。与 `arrange()` 和 `filter()` 不同，`distinct()` 在筛选行的同时也可以选择性地**修改列**。\n\n### filter()\n\n`filter()` 函数用于根据列中的值保留数据框中的某些行。第一个参数是数据框，后续的参数是判断各行是否保留的条件。例如，以下代码能找出所有**起飞延误超过 120 分钟**的航班：\n\n``` r\nflights |> \n  filter(dep_delay > 120)\n```\n\n除了 `>`（大于）之外，还可以使用以下比较运算符：\n\n-   `>=`（大于等于）\n-   `<`（小于）\n-   `<=`（小于等于）\n-   `==`（等于）\n-   `!=`（不等于）\n\n还可以使用 `&` 或 `,` 表示“与”（同时满足多个条件），使用 `|` 表示“或”（满足任一条件）。例如要筛选出所有在1月1日起飞的航班：\n\n``` r\nflights |> \n  filter(month == 1 & day == 1)\n```\n\n结合 `|` 与 `==` 时，有一个简洁的写法：`%in%`，用于匹配某个变量是否属于一组值之一。比如筛选1月或2月的航班：\n\n``` r\nflights |> \n  filter(month %in% c(1, 2))\n```\n\n在运行 `filter()` 时，dplyr 会返回一个新的数据框，而不会修改原始的 `flights` 数据集。要保存筛选结果，使用赋值操作符 `<-`：\n\n``` r\njan1 <- flights |> \n  filter(month == 1 & day == 1)\n```\n\n初学者常犯以下两点错误\n\n1.  用 `=` 判断相等，而非 `==`。此时 `filter()` 会报错提醒：\n\n``` r\nflights |> \n  filter(month = 1)\n#> Error in `filter()`:\n#> ! We detected a named input.\n#> ℹ This usually means that you've used `=` instead of `==`.\n#> ℹ Did you mean `month == 1`?\n```\n\n2.  像口语一样写“或”条件：\n\n``` r\nflights |> \n  filter(month == 1 | 2)\n```\n\n正确写法是 `month == 1 | month == 2`。\n\n### `arrange()`\n\n`arrange()` 根据某些列的值对**行**进行排序。它接收数据框及一组列名或表达式。如果提供多个列名，则后面的列用于在前面的列值相同时进一步排序。\n\n例如，下面的代码按年、月、日和起飞时间排序，得到的是最早起飞的航班排在前面：\n\n``` r\nflights |> \n  arrange(year, month, day, dep_time)\n```\n\n若希望按某列的**降序排列**，可以用 `desc()`：\n\n``` r\n# 按照起飞延误时间从大到小排序\nflights |> \n  arrange(desc(dep_delay))\n```\n\n### `distinct()`\n\n`distinct()` 查找数据框中所有**唯一（去重）行**。在实际使用中，更常用于获取某些列组合的唯一值，且会保留每组中第一次出现的那一行。\n\n``` r\n# 删除重复行\nflights |> \n  distinct()\n# 获取所有起点和终点的组合\nflights |> \n  distinct(origin, dest)\n```\n\n如需保留其他列信息，可添加 `.keep_all = TRUE`参数。\n\n若希望获取各组合的出现次数，使用 `count()` 更为合适，并可通过 `sort = TRUE` 参数按频数**降序**排列：\n\n``` r\nflights |>\n  count(origin, dest, sort = TRUE)\n```\n\n## 列操作\n\n在数据处理过程中，有四个 `dplyr` 中的重要函数可用于操作列而不改变行的结构：\n\n-   `mutate()`：基于现有列创建新列。\n-   `select()`：筛选保留指定列。\n-   `rename()`：重命名列。\n-   `relocate()`：重新排列列的位置。\n\n### `mutate()`\n\n`mutate()` 用于在数据框中添加新列，这些新列的值是通过现有列计算得出的。例如：\n\n``` r\nflights |> \n  mutate(\n    gain = dep_delay - arr_delay,\n    speed = distance / air_time * 60\n  )\n```\n\n此代码添加了两个新列 `gain`（“起飞延误”减去“到达延误”）和 `speed`（飞行速度，单位：mph）。默认情况下，新列会添加在数据框的最右侧。为了便于观察，可以使用 `.before` 参数控制其插入的位置：\n\n``` r\nflights |> \n  mutate(\n    gain = dep_delay - arr_delay,\n    speed = distance / air_time * 60,\n    .before = 1\n  )\n#> # A tibble: 336,776 × 21\n#>    gain speed  year month   day dep_time sched_dep_time dep_delay arr_time\n#>   <dbl> <dbl> <int> <int> <int>    <int>          <int>     <dbl>    <int>\n#> 1    -9  370.  2013     1     1      517            515         2      830\n#> 2   -16  374.  2013     1     1      533            529         4      850\n#> 3   -31  408.  2013     1     1      542            540         2      923\n#> 4    17  517.  2013     1     1      544            545        -1     1004\n#> 5    19  394.  2013     1     1      554            600        -6      812\n#> 6   -16  288.  2013     1     1      554            558        -4      740\n#> # ℹ 336,770 more rows\n#> # ℹ 12 more variables: sched_arr_time <int>, arr_delay <dbl>, …\n```\n\n此外，`.after` 可用于将新列插入某一**指定列**之后。`.keep` 参数可控制哪些列被保留。例如仅保留参与 `mutate()` 计算的列：\n\n``` r\nflights |> \n  mutate(\n    gain = dep_delay - arr_delay,\n    hours = air_time / 60,\n    gain_per_hour = gain / hours,\n    .keep = \"used\"\n  )\n```\n\n> **注意**：若未将结果赋值回对象（如 `flights` 或新对象），新生成的变量仅在当前操作中可见，不会永久保存。\n\n------------------------------------------------------------------------\n\n### `select()`\n\n在处理包含大量变量的数据集时，`select()` 可用于快速提取需要研究的列。常见用法包括：\n\n``` r\n# 指定列名\nselect(year, month, day)\n\n# 选择连续区间\nselect(year:day)\n\n# 排除某一列区间\nselect(!year:day)\n\n# 选择字符型列\nselect(where(is.character))\n```\n\n还可使用辅助函数进行模式匹配：\n\n-   `starts_with(\"abc\")`：匹配以 abc 开头的列名。\n-   `ends_with(\"xyz\")`：匹配以 xyz 结尾的列名。\n-   `contains(\"ijk\")`：包含 ijk 的列名。\n-   `num_range(\"x\", 1:3)`：匹配 x1, x2, x3。\n\n此外，也可在 `select()` 中**重命名**列，但是**只保留被选择的列**，未被选中的列会被移除。\n\n``` r\nflights |> \n  select(tail_num = tailnum)\n```\n\n### `rename()`\n\n若只想重命名部分列而**保留所有现有列**，可使用 `rename()`：\n\n``` r\nflights |> \n  rename(tail_num = tailnum)\n```\n\n相比 `select()`，`rename()` 不会改变列的数量，仅修改名称。\n\n若存在大量命名不规范的列名，可考虑使用 `janitor::clean_names()` 进行批量清洗。\n\n#### `relocate()`\n\n`relocate()` 用于调整列的顺序，可以将某些更关键的列移动到前面：\n\n``` r\nflights |> \n  relocate(time_hour, air_time)\n#> # A tibble: 336,776 × 19\n#>   time_hour           air_time  year month   day dep_time sched_dep_time\n#>   <dttm>                 <dbl> <int> <int> <int>    <int>          <int>\n#> 1 2013-01-01 05:00:00      227  2013     1     1      517            515\n#> 2 2013-01-01 05:00:00      227  2013     1     1      533            529\n#> 3 2013-01-01 05:00:00      160  2013     1     1      542            540\n#> 4 2013-01-01 05:00:00      183  2013     1     1      544            545\n#> 5 2013-01-01 06:00:00      116  2013     1     1      554            600\n#> 6 2013-01-01 05:00:00      150  2013     1     1      554            558\n#> # ℹ 336,770 more rows\n#> # ℹ 12 more variables: dep_delay <dbl>, arr_time <int>, …\n```\n\n`.before` 或 `.after` 精确定位：\n\n```         \nflights |> \n  relocate(year:dep_time, .after = time_hour)\nflights |> \n  relocate(starts_with(\"arr\"), .before = dep_time)\n```\n\n## 管道符\n\n管道符提升代码的可读性、简洁性和逻辑性，避免嵌套调用。\n\n### Base R 管道操作符 `|>`\n\n自 R 4.1.0 起，R 语言原生支持管道符 `|>`。其核心原理是**“把前一步的结果作为后一个函数的第一个参数”**。\n\n举例，找出飞往 IAH 的航班中速度最快的几架飞机：\n\n``` r\nflights |>\n  filter(dest == \"IAH\") |>\n  mutate(speed = distance / air_time * 60) |>\n  select(year:day, dep_time, carrier, flight, speed) |>\n  arrange(desc(speed))\n```\n\n等价于嵌套写法：\n\n``` r\narrange(\n  select(\n    mutate(\n      filter(flights, dest == \"IAH\"),\n      speed = distance / air_time * 60\n    ),\n    year:day, dep_time, carrier, flight, speed\n  ),\n  desc(speed)\n)\n```\n\n### \\|\\> 与 `%>%` 的区别\n\n`|>` 是 base R 提供的原生操作符，不依赖任何包。\n\n`%>%` 来源于 `magrittr` 包（tidyverse 的一部分），功能更强。比如可使用`.`占位符传递非首参数。\n\n不过，如果只在 `dplyr` 和 `ggplot2` 语境下处理数据，`|>` 通常已足够。\n\n## 分组操作与汇总\n\n管道操作仅简化流程，但对某些任务，如“对每个月统计平均延误时间”，则需要借助**分组与汇总函数**。\n\n### `group_by()`\n\n示例：按月份分组\n\n``` r\nflights |>\n  group_by(month)\n```\n\n此时返回的 tibble 看似不变，但其实多了一个“分组结构”属性，后续函数如 `summarize()` 将以此分组为单位运算。\n\n### `summarize()`\n\n用于计算每组的统计量，如平均数、个数、最大值等。\n\n``` r\nflights |>\n  group_by(month) |>\n  summarize(\n    avg_delay = mean(dep_delay, na.rm = TRUE),\n    flight_count = n()\n  )\n```\n\n> -   `na.rm = TRUE` 用于忽略缺失值；\n> -   `n()` 返回当前分组的行数（即航班数）；\n> -   默认情况下 `summarize()` 会“剥离”最后一个分组变量。\n\n### 多重分组与 `.groups` 参数\n\n可同时按多个变量分组：\n\n``` r\nflights |>\n  group_by(year, month, day) |>\n  summarize(avg_delay = mean(dep_delay, na.rm = TRUE))\n```\n\n可通过 `.groups` 参数明确控制输出是否保留某层分组：\n\n``` r\nsummarize(..., .groups = \"drop_last\")  # 保留上层分组\nsummarize(..., .groups = \"drop\")       # 全部取消分组\nsummarize(..., .groups = \"keep\")       # 保留所有分组\n```\n\n### `ungroup()`移除分组结构\n\n若后续不再需分组操作，需要使用 ungroup() 函数进行声明，避免出现意外。\n\n``` r\ndaily_summary |>\n  ungroup() |>\n  summarize(total_flights = sum(n))\n```\n\n### `slice_*()` 系列函数：获取组内特定行\n\nslice\\_\\*() 系列函数常用于提取组内最值、样本等，结果保留原始列结构。\n\n-   `slice_head(n = 1)`：每组取最前一行\n-   `slice_tail(n = 1)`：每组取最后一行\n-   `slice_max(order_by, n = 1)`：每组取最大值\n-   `slice_min(order_by, n = 1)`：每组取最小值\n-   `slice_sample(n = 1)`：每组随机取一行\n\n例如，找出每个目的地到达延误最长的航班：\n\n``` r\nflights |>\n  group_by(dest) |>\n  slice_max(arr_delay, n = 1) |>\n  relocate(dest)\n```\n\n默认行为中，若多个航班并列最大延误，则全部保留。若需限制为仅一行，可加 `with_ties = FALSE`。\n\n### `.by` 参数\n\n`dplyr` 1.1.0 引入 `.by` 参数，提供了一种更简洁、局部化的分组操作语法。与传统 `group_by()` 不同，`.by` 仅在当前动词范围内生效，不影响后续操作的分组状态，适合一次性分组计算。\n\n基本用法如下例所示：\n\n``` r\nflights |> \n  summarize(\n    delay = mean(dep_delay, na.rm = TRUE), \n    n = n(),\n    .by = month\n  )\n```\n\n可支持多变量分组：\n\n``` r\nflights |> \n  summarize(\n    delay = mean(dep_delay, na.rm = TRUE), \n    n = n(),\n    .by = c(origin, dest)\n  )\n```\n\n`.by`参数特性总结如下：\n\n-   作用范围限于当前动词，运算结束即“自动取消分组”；\n-   可用于 `summarize()`、`mutate()`、`filter()` 等所有动词；\n-   避免了 `.groups` 警告信息，简化结果处理流程；\n-   写法更贴近函数式风格，便于封装与组合。\n\n以下是两种写法的对比：\n\n-   传统写法：\n\n``` r\nflights |> \n  group_by(month) |> \n  summarize(delay = mean(dep_delay, na.rm = TRUE)) |> \n  ungroup()\n```\n\n-   `.by` 简化：\n\n\\`\\`\\` r flights \\|\\> summarize(delay = mean(dep_delay, na.rm = TRUE), .by = month)\n","srcMarkdownNoYaml":"\n\n## 引言\n\n可视化是数据分析时的重要手段，但前提是数据格式严格符合要求。因此针对格式不当的数据需要进行一些处理。\n\n本章主要介绍使用dplyr包对数据进行处理，dplyr同样归属于tidyverse。另外为了举例，还需加载含有纽约航班信息的包：\n\n``` r\n> library(nycflights13)\n> library(tidyverse)\n```\n\nnycflights13包中包含 2013 年从纽约市出发的所有 336,776 个航班，记录在`nycflights13::flights`里：\n\n``` r\nflights\n#> # A tibble: 336,776 × 19\n#>    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n#>   <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>\n#> 1  2013     1     1      517            515         2      830            819\n#> 2  2013     1     1      533            529         4      850            830\n#> 3  2013     1     1      542            540         2      923            850\n#> 4  2013     1     1      544            545        -1     1004           1022\n#> 5  2013     1     1      554            600        -6      812            837\n#> 6  2013     1     1      554            558        -4      740            728\n#> # ℹ 336,770 more rows\n#> # ℹ 11 more variables: arr_delay <dbl>, carrier <chr>, flight <int>, …\n```\n\n`flights`表格是一个 “Tibble”，这是一种特殊的数据框。Tibble 和普通数据框之间最重要的区别是其显示方式，tibble专为大型数据集而设计，因此它们仅显示前几行，并且仅显示适配屏幕大小的列。如果使用 RStudio操作则更方便，会打开一个可交互、可滚动、可筛选的视图。\n\n注意到表头下方用尖括号标注了数据类型，大致有：\n\n-   int 表示整数型变量。\n-   dbl表示双精度浮点数型变量，或称实数。\n-   chr 表示字符向量，或称字符串。\n-   lgl表示逻辑型变量，是一个仅包括 TRUE 和 FALSE 的向量。\n-   fctr 表示因子，R用其来表示具有固定数目的值的分类变量。\n-   date 表示日期型变量。\n-   dttm 表示日期时间(日期+时间)型变量。\n\n本章将学习5个dplyr核心函数，用于数据处理，大致为：\n\n-   按值筛选(`filter()`)。\n-   对行进行重新排序(`arrange()`)\n-   按名称选取变量(`select()`)\n-   使用现有变量的函数创建新变量(`mutate())`\n-   将多个值总结为一个摘要统计量(`summarize()`)\n\n上述5个函数的工作方式大致相同，有以下共通点：\n\n-   第一个参数是数据框。\n-   后续参数使用不带引号的变量名称，描述针对数据框进行的操作。\n-   输出结果是一个新数据框。\n\n下面对其一一阐述。\n\n## 行\n\n操作数据行的最主要函数为：\n\n-   `filter()`：用于筛选数据。改变的是**行的种类**，但**不改变顺序**；\n-   `arrange()`：用于排序。改变的是**行的顺序**，但**不改变行的内容**。\n\n这两个函数仅作用于行，不会修改列。\n\n此外，还有 `distinct()` 函数，用于查找具有唯一值的行。与 `arrange()` 和 `filter()` 不同，`distinct()` 在筛选行的同时也可以选择性地**修改列**。\n\n### filter()\n\n`filter()` 函数用于根据列中的值保留数据框中的某些行。第一个参数是数据框，后续的参数是判断各行是否保留的条件。例如，以下代码能找出所有**起飞延误超过 120 分钟**的航班：\n\n``` r\nflights |> \n  filter(dep_delay > 120)\n```\n\n除了 `>`（大于）之外，还可以使用以下比较运算符：\n\n-   `>=`（大于等于）\n-   `<`（小于）\n-   `<=`（小于等于）\n-   `==`（等于）\n-   `!=`（不等于）\n\n还可以使用 `&` 或 `,` 表示“与”（同时满足多个条件），使用 `|` 表示“或”（满足任一条件）。例如要筛选出所有在1月1日起飞的航班：\n\n``` r\nflights |> \n  filter(month == 1 & day == 1)\n```\n\n结合 `|` 与 `==` 时，有一个简洁的写法：`%in%`，用于匹配某个变量是否属于一组值之一。比如筛选1月或2月的航班：\n\n``` r\nflights |> \n  filter(month %in% c(1, 2))\n```\n\n在运行 `filter()` 时，dplyr 会返回一个新的数据框，而不会修改原始的 `flights` 数据集。要保存筛选结果，使用赋值操作符 `<-`：\n\n``` r\njan1 <- flights |> \n  filter(month == 1 & day == 1)\n```\n\n初学者常犯以下两点错误\n\n1.  用 `=` 判断相等，而非 `==`。此时 `filter()` 会报错提醒：\n\n``` r\nflights |> \n  filter(month = 1)\n#> Error in `filter()`:\n#> ! We detected a named input.\n#> ℹ This usually means that you've used `=` instead of `==`.\n#> ℹ Did you mean `month == 1`?\n```\n\n2.  像口语一样写“或”条件：\n\n``` r\nflights |> \n  filter(month == 1 | 2)\n```\n\n正确写法是 `month == 1 | month == 2`。\n\n### `arrange()`\n\n`arrange()` 根据某些列的值对**行**进行排序。它接收数据框及一组列名或表达式。如果提供多个列名，则后面的列用于在前面的列值相同时进一步排序。\n\n例如，下面的代码按年、月、日和起飞时间排序，得到的是最早起飞的航班排在前面：\n\n``` r\nflights |> \n  arrange(year, month, day, dep_time)\n```\n\n若希望按某列的**降序排列**，可以用 `desc()`：\n\n``` r\n# 按照起飞延误时间从大到小排序\nflights |> \n  arrange(desc(dep_delay))\n```\n\n### `distinct()`\n\n`distinct()` 查找数据框中所有**唯一（去重）行**。在实际使用中，更常用于获取某些列组合的唯一值，且会保留每组中第一次出现的那一行。\n\n``` r\n# 删除重复行\nflights |> \n  distinct()\n# 获取所有起点和终点的组合\nflights |> \n  distinct(origin, dest)\n```\n\n如需保留其他列信息，可添加 `.keep_all = TRUE`参数。\n\n若希望获取各组合的出现次数，使用 `count()` 更为合适，并可通过 `sort = TRUE` 参数按频数**降序**排列：\n\n``` r\nflights |>\n  count(origin, dest, sort = TRUE)\n```\n\n## 列操作\n\n在数据处理过程中，有四个 `dplyr` 中的重要函数可用于操作列而不改变行的结构：\n\n-   `mutate()`：基于现有列创建新列。\n-   `select()`：筛选保留指定列。\n-   `rename()`：重命名列。\n-   `relocate()`：重新排列列的位置。\n\n### `mutate()`\n\n`mutate()` 用于在数据框中添加新列，这些新列的值是通过现有列计算得出的。例如：\n\n``` r\nflights |> \n  mutate(\n    gain = dep_delay - arr_delay,\n    speed = distance / air_time * 60\n  )\n```\n\n此代码添加了两个新列 `gain`（“起飞延误”减去“到达延误”）和 `speed`（飞行速度，单位：mph）。默认情况下，新列会添加在数据框的最右侧。为了便于观察，可以使用 `.before` 参数控制其插入的位置：\n\n``` r\nflights |> \n  mutate(\n    gain = dep_delay - arr_delay,\n    speed = distance / air_time * 60,\n    .before = 1\n  )\n#> # A tibble: 336,776 × 21\n#>    gain speed  year month   day dep_time sched_dep_time dep_delay arr_time\n#>   <dbl> <dbl> <int> <int> <int>    <int>          <int>     <dbl>    <int>\n#> 1    -9  370.  2013     1     1      517            515         2      830\n#> 2   -16  374.  2013     1     1      533            529         4      850\n#> 3   -31  408.  2013     1     1      542            540         2      923\n#> 4    17  517.  2013     1     1      544            545        -1     1004\n#> 5    19  394.  2013     1     1      554            600        -6      812\n#> 6   -16  288.  2013     1     1      554            558        -4      740\n#> # ℹ 336,770 more rows\n#> # ℹ 12 more variables: sched_arr_time <int>, arr_delay <dbl>, …\n```\n\n此外，`.after` 可用于将新列插入某一**指定列**之后。`.keep` 参数可控制哪些列被保留。例如仅保留参与 `mutate()` 计算的列：\n\n``` r\nflights |> \n  mutate(\n    gain = dep_delay - arr_delay,\n    hours = air_time / 60,\n    gain_per_hour = gain / hours,\n    .keep = \"used\"\n  )\n```\n\n> **注意**：若未将结果赋值回对象（如 `flights` 或新对象），新生成的变量仅在当前操作中可见，不会永久保存。\n\n------------------------------------------------------------------------\n\n### `select()`\n\n在处理包含大量变量的数据集时，`select()` 可用于快速提取需要研究的列。常见用法包括：\n\n``` r\n# 指定列名\nselect(year, month, day)\n\n# 选择连续区间\nselect(year:day)\n\n# 排除某一列区间\nselect(!year:day)\n\n# 选择字符型列\nselect(where(is.character))\n```\n\n还可使用辅助函数进行模式匹配：\n\n-   `starts_with(\"abc\")`：匹配以 abc 开头的列名。\n-   `ends_with(\"xyz\")`：匹配以 xyz 结尾的列名。\n-   `contains(\"ijk\")`：包含 ijk 的列名。\n-   `num_range(\"x\", 1:3)`：匹配 x1, x2, x3。\n\n此外，也可在 `select()` 中**重命名**列，但是**只保留被选择的列**，未被选中的列会被移除。\n\n``` r\nflights |> \n  select(tail_num = tailnum)\n```\n\n### `rename()`\n\n若只想重命名部分列而**保留所有现有列**，可使用 `rename()`：\n\n``` r\nflights |> \n  rename(tail_num = tailnum)\n```\n\n相比 `select()`，`rename()` 不会改变列的数量，仅修改名称。\n\n若存在大量命名不规范的列名，可考虑使用 `janitor::clean_names()` 进行批量清洗。\n\n#### `relocate()`\n\n`relocate()` 用于调整列的顺序，可以将某些更关键的列移动到前面：\n\n``` r\nflights |> \n  relocate(time_hour, air_time)\n#> # A tibble: 336,776 × 19\n#>   time_hour           air_time  year month   day dep_time sched_dep_time\n#>   <dttm>                 <dbl> <int> <int> <int>    <int>          <int>\n#> 1 2013-01-01 05:00:00      227  2013     1     1      517            515\n#> 2 2013-01-01 05:00:00      227  2013     1     1      533            529\n#> 3 2013-01-01 05:00:00      160  2013     1     1      542            540\n#> 4 2013-01-01 05:00:00      183  2013     1     1      544            545\n#> 5 2013-01-01 06:00:00      116  2013     1     1      554            600\n#> 6 2013-01-01 05:00:00      150  2013     1     1      554            558\n#> # ℹ 336,770 more rows\n#> # ℹ 12 more variables: dep_delay <dbl>, arr_time <int>, …\n```\n\n`.before` 或 `.after` 精确定位：\n\n```         \nflights |> \n  relocate(year:dep_time, .after = time_hour)\nflights |> \n  relocate(starts_with(\"arr\"), .before = dep_time)\n```\n\n## 管道符\n\n管道符提升代码的可读性、简洁性和逻辑性，避免嵌套调用。\n\n### Base R 管道操作符 `|>`\n\n自 R 4.1.0 起，R 语言原生支持管道符 `|>`。其核心原理是**“把前一步的结果作为后一个函数的第一个参数”**。\n\n举例，找出飞往 IAH 的航班中速度最快的几架飞机：\n\n``` r\nflights |>\n  filter(dest == \"IAH\") |>\n  mutate(speed = distance / air_time * 60) |>\n  select(year:day, dep_time, carrier, flight, speed) |>\n  arrange(desc(speed))\n```\n\n等价于嵌套写法：\n\n``` r\narrange(\n  select(\n    mutate(\n      filter(flights, dest == \"IAH\"),\n      speed = distance / air_time * 60\n    ),\n    year:day, dep_time, carrier, flight, speed\n  ),\n  desc(speed)\n)\n```\n\n### \\|\\> 与 `%>%` 的区别\n\n`|>` 是 base R 提供的原生操作符，不依赖任何包。\n\n`%>%` 来源于 `magrittr` 包（tidyverse 的一部分），功能更强。比如可使用`.`占位符传递非首参数。\n\n不过，如果只在 `dplyr` 和 `ggplot2` 语境下处理数据，`|>` 通常已足够。\n\n## 分组操作与汇总\n\n管道操作仅简化流程，但对某些任务，如“对每个月统计平均延误时间”，则需要借助**分组与汇总函数**。\n\n### `group_by()`\n\n示例：按月份分组\n\n``` r\nflights |>\n  group_by(month)\n```\n\n此时返回的 tibble 看似不变，但其实多了一个“分组结构”属性，后续函数如 `summarize()` 将以此分组为单位运算。\n\n### `summarize()`\n\n用于计算每组的统计量，如平均数、个数、最大值等。\n\n``` r\nflights |>\n  group_by(month) |>\n  summarize(\n    avg_delay = mean(dep_delay, na.rm = TRUE),\n    flight_count = n()\n  )\n```\n\n> -   `na.rm = TRUE` 用于忽略缺失值；\n> -   `n()` 返回当前分组的行数（即航班数）；\n> -   默认情况下 `summarize()` 会“剥离”最后一个分组变量。\n\n### 多重分组与 `.groups` 参数\n\n可同时按多个变量分组：\n\n``` r\nflights |>\n  group_by(year, month, day) |>\n  summarize(avg_delay = mean(dep_delay, na.rm = TRUE))\n```\n\n可通过 `.groups` 参数明确控制输出是否保留某层分组：\n\n``` r\nsummarize(..., .groups = \"drop_last\")  # 保留上层分组\nsummarize(..., .groups = \"drop\")       # 全部取消分组\nsummarize(..., .groups = \"keep\")       # 保留所有分组\n```\n\n### `ungroup()`移除分组结构\n\n若后续不再需分组操作，需要使用 ungroup() 函数进行声明，避免出现意外。\n\n``` r\ndaily_summary |>\n  ungroup() |>\n  summarize(total_flights = sum(n))\n```\n\n### `slice_*()` 系列函数：获取组内特定行\n\nslice\\_\\*() 系列函数常用于提取组内最值、样本等，结果保留原始列结构。\n\n-   `slice_head(n = 1)`：每组取最前一行\n-   `slice_tail(n = 1)`：每组取最后一行\n-   `slice_max(order_by, n = 1)`：每组取最大值\n-   `slice_min(order_by, n = 1)`：每组取最小值\n-   `slice_sample(n = 1)`：每组随机取一行\n\n例如，找出每个目的地到达延误最长的航班：\n\n``` r\nflights |>\n  group_by(dest) |>\n  slice_max(arr_delay, n = 1) |>\n  relocate(dest)\n```\n\n默认行为中，若多个航班并列最大延误，则全部保留。若需限制为仅一行，可加 `with_ties = FALSE`。\n\n### `.by` 参数\n\n`dplyr` 1.1.0 引入 `.by` 参数，提供了一种更简洁、局部化的分组操作语法。与传统 `group_by()` 不同，`.by` 仅在当前动词范围内生效，不影响后续操作的分组状态，适合一次性分组计算。\n\n基本用法如下例所示：\n\n``` r\nflights |> \n  summarize(\n    delay = mean(dep_delay, na.rm = TRUE), \n    n = n(),\n    .by = month\n  )\n```\n\n可支持多变量分组：\n\n``` r\nflights |> \n  summarize(\n    delay = mean(dep_delay, na.rm = TRUE), \n    n = n(),\n    .by = c(origin, dest)\n  )\n```\n\n`.by`参数特性总结如下：\n\n-   作用范围限于当前动词，运算结束即“自动取消分组”；\n-   可用于 `summarize()`、`mutate()`、`filter()` 等所有动词；\n-   避免了 `.groups` 警告信息，简化结果处理流程；\n-   写法更贴近函数式风格，便于封装与组合。\n\n以下是两种写法的对比：\n\n-   传统写法：\n\n``` r\nflights |> \n  group_by(month) |> \n  summarize(delay = mean(dep_delay, na.rm = TRUE)) |> \n  ungroup()\n```\n\n-   `.by` 简化：\n\n\\`\\`\\` r flights \\|\\> summarize(delay = mean(dep_delay, na.rm = TRUE), .by = month)\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":"auto","echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","output-file":"ch3_data_transformation.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.7.32","bibliography":["../references.bib"],"editor":"visual","theme":["cosmo","brand"],"title":"数据处理"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}