{"title":"数据整洁化","markdown":{"yaml":{"title":"数据整洁化","format":"html"},"headingText":"引言","containsRefs":false,"markdown":"\n\n\n数据可视化和建模都要求数据处于“整洁”格式（tidy format）。虽然无法控制获取数据的原始结构，但可通过数据整理将其转换为整洁结构。\n\n本章展示：\n\n-   整洁数据的定义与原则；\n-   如何使用 `tidyr` 包中的函数进行数据整洁化；\n-   如何识别和处理缺失值。\n\n`tidyr` 是 `tidyverse` 的核心之一，故我们须先载入`tidyverse`。\n\n``` r\nlibrary(tidyverse)\n```\n\n## 整洁数据\n\n整洁数据具有以下三个核心特征：\n\n-   每个**变量**成一列；\n-   每个**观测值**成一行；\n-   每个**观测单位**成一个表。\n\n```         \ntable1\n#> # A tibble: 6 × 4\n#>   country      year  cases population\n#>   <chr>       <dbl>  <dbl>      <dbl>\n#> 1 Afghanistan  1999    745   19987071\n#> 2 Afghanistan  2000   2666   20595360\n#> 3 Brazil       1999  37737  172006362\n#> 4 Brazil       2000  80488  174504898\n#> 5 China        1999 212258 1272915272\n#> 6 China        2000 213766 1280428583\n```\n\n在 `table1` 中，每行表示一个国家在某一年的观测，有 `country`, `year`, `cases`, `population` 四列，结构清晰，便于进一步处理和可视化。\n\n可以基于已有变量创建**派生变量**。例如：\n\n``` r\n# 计算每万人中的发病率\ntable1 |>\n  mutate(rate = cases / population * 10000)\n#> # A tibble: 6 × 5\n#>   country      year  cases population  rate\n#>   <chr>       <dbl>  <dbl>      <dbl> <dbl>\n#> 1 Afghanistan  1999    745   19987071 0.373\n#> 2 Afghanistan  2000   2666   20595360 1.29 \n#> 3 Brazil       1999  37737  172006362 2.19 \n#> 4 Brazil       2000  80488  174504898 4.61 \n#> 5 China        1999 212258 1272915272 1.67 \n#> 6 China        2000 213766 1280428583 1.67\n\n# 计算每年病例数\ntable1 |> \n  group_by(year) |> \n  summarize(total_cases = sum(cases))\n#> # A tibble: 2 × 2\n#>    year total_cases\n#>   <dbl>       <dbl>\n#> 1  1999      250740\n#> 2  2000      296920\n```\n\n可视化如下：\n\n``` r\n# 可视化\nggplot(table1, aes(x = year, y = cases)) +\n  geom_line(aes(group = country), color = \"grey50\") +\n  geom_point(aes(color = country, shape = country)) +\n  scale_x_continuous(breaks = c(1999, 2000)) # x-axis breaks at 1999 and 2000\n```\n\n![](https://r4ds.hadley.nz/data-tidy_files/figure-html/unnamed-chunk-3-1.png)\n\n## pivot_long()\n\n虽然整洁数据貌似很好实现，但现实中的数据往往不符合整洁格式。两个常见原因：\n\n-   数据为录入/展示方便而设计（如宽格式）\n-   多数数据制作者未系统学习整洁数据的规范\n\n下面逐一介绍相关问题及解决方法。\n\n### 错误其一 \\| 变量作为列名\n\n下面这个名为 billboard 的数据集记录了 2000 年歌曲的公告牌排名：\n\n``` r\nbillboard\n#> # A tibble: 317 × 79\n#>   artist       track               date.entered   wk1   wk2   wk3   wk4   wk5\n#>   <chr>        <chr>               <date>       <dbl> <dbl> <dbl> <dbl> <dbl>\n#> 1 2 Pac        Baby Don't Cry (Ke… 2000-02-26      87    82    72    77    87\n#> 2 2Ge+her      The Hardest Part O… 2000-09-02      91    87    92    NA    NA\n#> 3 3 Doors Down Kryptonite          2000-04-08      81    70    68    67    66\n#> 4 3 Doors Down Loser               2000-10-21      76    76    72    69    67\n#> 5 504 Boyz     Wobble Wobble       2000-04-15      57    34    25    17    17\n#> 6 98^0         Give Me Just One N… 2000-08-19      51    39    34    26    26\n#> # ℹ 311 more rows\n#> # ℹ 71 more variables: wk6 <dbl>, wk7 <dbl>, wk8 <dbl>, wk9 <dbl>, …\n```\n\n表格宽度相当浮夸，因为制表者将不同星期这一变量作为列名，整整列出了76列星期（此处引用的表格仅展示wk1\\~wk5）。显然，星期数是一个变量，将其作为列名很不合理、很不整洁。\n\n使用 `pivot_longer()` 可进行处理，将星期这一变量进行转置：\n\n``` r\nbillboard |> \n  pivot_longer(\n    cols = starts_with(\"wk\"), \n    names_to = \"week\", \n    values_to = \"rank\"\n  )\n#> # A tibble: 24,092 × 5\n#>    artist track                   date.entered week   rank\n#>    <chr>  <chr>                   <date>       <chr> <dbl>\n#>  1 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk1      87\n#>  2 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk2      82\n#>  3 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk3      72\n#>  4 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk4      77\n#>  5 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk5      87\n#>  6 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk6      94\n#>  7 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk7      99\n#>  8 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk8      NA\n#>  9 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk9      NA\n#> 10 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk10     NA\n#> # ℹ 24,082 more rows\n```\n\n参数解释：\n\n-   `cols`用于指定需要转置的列。除了`starts_with(\"wk\")`，也可写成`!c(artist, track, date.entered)`\n\n-   `names_to`用于命名新产生的列，此处将该列命名为`week`\n\n-   `values_to`用于命名存储在原各个列下的变量分离后产生的新列，此处将该列命名为 `rank`\n\n需注意，`week`和`rank`都需要加上引号，因为这是正在创建的新变量。\n\n初步处理完毕，不知道你有没有发现一个问题：如果原表的某个歌曲还未到wk76就已经跌出榜单而观测值为空白，那么转置后岂不是会产生若干只含有`NA`的行？这显然仍需改进。\n\n方法很简单，只需在`pivot_longer()`中加上一个参数：`values_drop_na = TRUE`，即可删去只含`NA`的行。\n\n将转置后表格命名为 billboard_longer 并进行可视化如下图所示：\n\n![](https://r4ds.hadley.nz/data-tidy_files/figure-html/fig-billboard-ranks-1.png)\n\n### pivot_long() 的运作原理\n\n通过上一节的例子能看到`pivot`函数的奇妙之处，让人不禁好奇其原理如何。接下来以另一个数据框为例进行展示。\n\n假设有 3 名患者，id 分别是 A 、 B 和 C，现在对每位患者进行两次血压测量，以此创建 tibble 如下。\n\n``` r\ndf <- tribble(\n  ~id,  ~bp1, ~bp2,\n   \"A\",  100,  120,\n   \"B\",  140,  115,\n   \"C\",  120,  125\n)\n```\n\n> `tribble()`函数用于快捷创建`tibble`。\n\n接下来我们需要将其修整为新的数据框，含有三个变量：id、measurement、value，如下实现：\n\n``` r\ndf |> \n  pivot_longer(\n    cols = bp1:bp2,\n    names_to = \"measurement\",\n    values_to = \"value\"\n  )\n#> # A tibble: 6 × 3\n#>   id    measurement value\n#>   <chr> <chr>       <dbl>\n#> 1 A     bp1           100\n#> 2 A     bp2           120\n#> 3 B     bp1           140\n#> 4 B     bp2           115\n#> 5 C     bp1           120\n#> 6 C     bp2           125\n```\n\n下列组图形象地展现了这一转置过程：\n\n1.  已经是变量的列需要重复，每个转置列重复一次。\n\n![](https://r4ds.hadley.nz/diagrams/tidy-data/variables.png)\n\n2.  转置列的列名将成为新列中的值。对于原始数据集的每一行，这些值需要重复一次。\n\n![](https://r4ds.hadley.nz/diagrams/tidy-data/column-names.png)\n\n单元格值也会成为新变量中的值，其名称由`values_to`定义，且逐行展开。\n\n![](https://r4ds.hadley.nz/diagrams/tidy-data/cell-values.png)\n\n### 错误其二 \\| 列名包含多个变量\n\n有时制表者为了图方便，列名可能一次性塞入了若干变量，导致要素过多而很不整洁。下面以一名为 who2 的整理了结核病的数据框为例。\n\n``` r\nwho2\n#> # A tibble: 7,240 × 58\n#>   country      year sp_m_014 sp_m_1524 sp_m_2534 sp_m_3544 sp_m_4554\n#>   <chr>       <dbl>    <dbl>     <dbl>     <dbl>     <dbl>     <dbl>\n#> 1 Afghanistan  1980       NA        NA        NA        NA        NA\n#> 2 Afghanistan  1981       NA        NA        NA        NA        NA\n#> 3 Afghanistan  1982       NA        NA        NA        NA        NA\n#> 4 Afghanistan  1983       NA        NA        NA        NA        NA\n#> 5 Afghanistan  1984       NA        NA        NA        NA        NA\n#> 6 Afghanistan  1985       NA        NA        NA        NA        NA\n#> # ℹ 7,234 more rows\n#> # ℹ 51 more variables: sp_m_5564 <dbl>, sp_m_65 <dbl>, sp_f_014 <dbl>, …\n```\n\n这里解释一下制表者对第三列及后续列的命名思路：以下划线分为三个部分，第一部分表示诊断方法，第二部分表示性别，第三部分表示年龄范围。比如 sp_m_014 表示诊断方式sp，男性，0\\~14岁。\n\n可见若拆分后该表将包含六个变量：国家、年份、诊断方法、性别、年龄范围、患者数。\n\n下面依然使用`pivot_long()`函数进行修整：\n\n``` r\nwho2 |> \n  pivot_longer(\n    cols = !(country:year),\n    names_to = c(\"diagnosis\", \"gender\", \"age\"), \n    names_sep = \"_\",\n    values_to = \"count\"\n  )\n#> # A tibble: 405,440 × 6\n#>   country      year diagnosis gender age   count\n#>   <chr>       <dbl> <chr>     <chr>  <chr> <dbl>\n#> 1 Afghanistan  1980 sp        m      014      NA\n#> 2 Afghanistan  1980 sp        m      1524     NA\n#> 3 Afghanistan  1980 sp        m      2534     NA\n#> 4 Afghanistan  1980 sp        m      3544     NA\n#> 5 Afghanistan  1980 sp        m      4554     NA\n#> 6 Afghanistan  1980 sp        m      5564     NA\n#> # ℹ 405,434 more rows\n```\n\n这里有新增参数`names_sep`，可将对应列以指定方式进行拆分。\n\n这个例子同时体现了同时命名多个新列的方式，即使用集合`c()`。\n\n### 错误其三 \\| 列名同时包含变量的名称与值\n\n还有更复杂的错误，即变量的名与值相混合。下面以一个名为 household 的记录家庭孩子数与姓名的数据框为例。\n\n``` r\nhousehold\n#> # A tibble: 5 × 5\n#>   family dob_child1 dob_child2 name_child1 name_child2\n#>    <int> <date>     <date>     <chr>       <chr>      \n#> 1      1 1998-11-26 2000-01-29 Susan       Jose       \n#> 2      2 1996-06-22 NA         Mark        <NA>       \n#> 3      3 2002-07-11 2004-04-05 Sam         Seth       \n#> 4      4 2004-10-10 2009-08-27 Craig       Khai       \n#> 5      5 2000-12-05 2005-02-28 Parker      Gracie\n```\n\n可以看出新的挑战是：列名包含两个变量名（dob、name）和另一变量的值（child，值为 1 或 2）。\n\n为解决这一问题，需要在给参数`names_to`提供的向量的首位加一个`.value`，这并不是某一个变量名称，而是表示使用转置列名的**第一个组分**作为输出中的变量名（既然要有组分之分，故还得加一个`names_sep`参数）。同时别忘了`values_drop_na = TRUE`参数，因为一个孩子的家庭会出现 `NA`行。\n\n``` r\nhousehold |> \n  pivot_longer(\n    cols = !family, \n    names_to = c(\".value\", \"child\"), \n    names_sep = \"_\", \n    values_drop_na = TRUE\n  )\n#> # A tibble: 9 × 4\n#>   family child  dob        name \n#>    <int> <chr>  <date>     <chr>\n#> 1      1 child1 1998-11-26 Susan\n#> 2      1 child2 2000-01-29 Jose \n#> 3      2 child1 1996-06-22 Mark \n#> 4      3 child1 2002-07-11 Sam  \n#> 5      3 child2 2004-04-05 Seth \n#> 6      4 child1 2004-10-10 Craig\n#> # ℹ 3 more rows\n```\n\n------------------------------------------------------------------------\n\n## pivot_wider()\n\n整个 5.3 节均使用pivot_long()函数对表格进行修整，整体变得更长。下面讨论将数据框变宽的修整情形，以包含医疗保险患者体检数据的数据框为例：\n\n``` r\ncms_patient_experience\n#> # A tibble: 500 × 5\n#>   org_pac_id org_nm                     measure_cd   measure_title   prf_rate\n#>   <chr>      <chr>                      <chr>        <chr>              <dbl>\n#> 1 0446157747 USC CARE MEDICAL GROUP INC CAHPS_GRP_1  CAHPS for MIPS…       63\n#> 2 0446157747 USC CARE MEDICAL GROUP INC CAHPS_GRP_2  CAHPS for MIPS…       87\n#> 3 0446157747 USC CARE MEDICAL GROUP INC CAHPS_GRP_3  CAHPS for MIPS…       86\n#> 4 0446157747 USC CARE MEDICAL GROUP INC CAHPS_GRP_5  CAHPS for MIPS…       57\n#> 5 0446157747 USC CARE MEDICAL GROUP INC CAHPS_GRP_8  CAHPS for MIPS…       85\n#> 6 0446157747 USC CARE MEDICAL GROUP INC CAHPS_GRP_12 CAHPS for MIPS…       24\n#> # ℹ 494 more rows\n```\n\n现在研究的重点是组织名称（org_nm），要确保每个组织名称仅有一行。\n\n此时使用`pivot_wider()`进行修正如下：\n\n``` r\ncms_patient_experience |> \n  pivot_wider(\n    id_cols = starts_with(\"org\"),\n    names_from = measure_cd,\n    values_from = prf_rate\n  )\n#> # A tibble: 95 × 8\n#>   org_pac_id org_nm           CAHPS_GRP_1 CAHPS_GRP_2 CAHPS_GRP_3 CAHPS_GRP_5\n#>   <chr>      <chr>                  <dbl>       <dbl>       <dbl>       <dbl>\n#> 1 0446157747 USC CARE MEDICA…          63          87          86          57\n#> 2 0446162697 ASSOCIATION OF …          59          85          83          63\n#> 3 0547164295 BEAVER MEDICAL …          49          NA          75          44\n#> 4 0749333730 CAPE PHYSICIANS…          67          84          85          65\n#> 5 0840104360 ALLIANCE PHYSIC…          66          87          87          64\n#> 6 0840109864 REX HOSPITAL INC          73          87          84          67\n#> # ℹ 89 more rows\n#> # ℹ 2 more variables: CAHPS_GRP_8 <dbl>, CAHPS_GRP_12 <dbl>\n```\n\n参数说明：\n\n-   `id_cols`表示保留的列的特征，此处仅保留以 org 开头的列，而排除了 measure_title 列\n-   `names_from`表示新列名在原表中所在列的列名\n-   `values_from`表示新列中包含变量值在原表中所在列的列名\n\n### pivot_wider() 的运作原理\n\n为了了解工作原理，再次从一个最简单的数据集开始。假设有两个 id 为 A 和 B 的两名患者，对患者 A 进行了 3 次血压测量，对患者 B 进行了 2 次：\n\n``` r\ndf <- tribble(\n  ~id, ~measurement, ~value,\n  \"A\",        \"bp1\",    100,\n  \"B\",        \"bp1\",    140,\n  \"B\",        \"bp2\",    115, \n  \"A\",        \"bp2\",    120,\n  \"A\",        \"bp3\",    105\n)\n```\n\n下面从 value 列取值，从 measurement 列取列名：\n\n``` r\ndf |> \n  pivot_wider(\n    names_from = measurement,\n    values_from = value\n  )\n#> # A tibble: 2 × 4\n#>   id      bp1   bp2   bp3\n#>   <chr> <dbl> <dbl> <dbl>\n#> 1 A       100   120   105\n#> 2 B       140   115    NA\n```\n\n首先，此过程需要弄清楚新的行和列中的内容。新列的名称将是 measurement 中的唯一值，可通过`distinct()`函数确认：\n\n``` r\ndf |> \n  distinct(measurement) |> \n  pull()\n#> [1] \"bp1\" \"bp2\" \"bp3\"\n```\n\n默认情况下，输出的新行由所有未进入新列名或值的变量决定，这些行称为`id_cols`。如下：\n\n``` r\ndf |> \n  select(-measurement, -value) |> \n  distinct()\n#> # A tibble: 2 × 1\n#>   id   \n#>   <chr>\n#> 1 A    \n#> 2 B\n```\n\n然后，`pivot_wider()`将这些结果组合起来，生成一个空数据框：\n\n``` r\ndf |> \n  select(-measurement, -value) |> \n  distinct() |> \n  mutate(x = NA, y = NA, z = NA)\n#> # A tibble: 2 × 4\n#>   id    x     y     z    \n#>   <chr> <lgl> <lgl> <lgl>\n#> 1 A     NA    NA    NA   \n#> 2 B     NA    NA    NA\n```\n\n最后它会使用输入中的数据填充所有`NA`值。在这种情况下，并非输出中的每个单元格在输入中都有相应的值，因为患者 B 没有第三次血压测量，因此该单元格仍然缺失。\n","srcMarkdownNoYaml":"\n\n## 引言\n\n数据可视化和建模都要求数据处于“整洁”格式（tidy format）。虽然无法控制获取数据的原始结构，但可通过数据整理将其转换为整洁结构。\n\n本章展示：\n\n-   整洁数据的定义与原则；\n-   如何使用 `tidyr` 包中的函数进行数据整洁化；\n-   如何识别和处理缺失值。\n\n`tidyr` 是 `tidyverse` 的核心之一，故我们须先载入`tidyverse`。\n\n``` r\nlibrary(tidyverse)\n```\n\n## 整洁数据\n\n整洁数据具有以下三个核心特征：\n\n-   每个**变量**成一列；\n-   每个**观测值**成一行；\n-   每个**观测单位**成一个表。\n\n```         \ntable1\n#> # A tibble: 6 × 4\n#>   country      year  cases population\n#>   <chr>       <dbl>  <dbl>      <dbl>\n#> 1 Afghanistan  1999    745   19987071\n#> 2 Afghanistan  2000   2666   20595360\n#> 3 Brazil       1999  37737  172006362\n#> 4 Brazil       2000  80488  174504898\n#> 5 China        1999 212258 1272915272\n#> 6 China        2000 213766 1280428583\n```\n\n在 `table1` 中，每行表示一个国家在某一年的观测，有 `country`, `year`, `cases`, `population` 四列，结构清晰，便于进一步处理和可视化。\n\n可以基于已有变量创建**派生变量**。例如：\n\n``` r\n# 计算每万人中的发病率\ntable1 |>\n  mutate(rate = cases / population * 10000)\n#> # A tibble: 6 × 5\n#>   country      year  cases population  rate\n#>   <chr>       <dbl>  <dbl>      <dbl> <dbl>\n#> 1 Afghanistan  1999    745   19987071 0.373\n#> 2 Afghanistan  2000   2666   20595360 1.29 \n#> 3 Brazil       1999  37737  172006362 2.19 \n#> 4 Brazil       2000  80488  174504898 4.61 \n#> 5 China        1999 212258 1272915272 1.67 \n#> 6 China        2000 213766 1280428583 1.67\n\n# 计算每年病例数\ntable1 |> \n  group_by(year) |> \n  summarize(total_cases = sum(cases))\n#> # A tibble: 2 × 2\n#>    year total_cases\n#>   <dbl>       <dbl>\n#> 1  1999      250740\n#> 2  2000      296920\n```\n\n可视化如下：\n\n``` r\n# 可视化\nggplot(table1, aes(x = year, y = cases)) +\n  geom_line(aes(group = country), color = \"grey50\") +\n  geom_point(aes(color = country, shape = country)) +\n  scale_x_continuous(breaks = c(1999, 2000)) # x-axis breaks at 1999 and 2000\n```\n\n![](https://r4ds.hadley.nz/data-tidy_files/figure-html/unnamed-chunk-3-1.png)\n\n## pivot_long()\n\n虽然整洁数据貌似很好实现，但现实中的数据往往不符合整洁格式。两个常见原因：\n\n-   数据为录入/展示方便而设计（如宽格式）\n-   多数数据制作者未系统学习整洁数据的规范\n\n下面逐一介绍相关问题及解决方法。\n\n### 错误其一 \\| 变量作为列名\n\n下面这个名为 billboard 的数据集记录了 2000 年歌曲的公告牌排名：\n\n``` r\nbillboard\n#> # A tibble: 317 × 79\n#>   artist       track               date.entered   wk1   wk2   wk3   wk4   wk5\n#>   <chr>        <chr>               <date>       <dbl> <dbl> <dbl> <dbl> <dbl>\n#> 1 2 Pac        Baby Don't Cry (Ke… 2000-02-26      87    82    72    77    87\n#> 2 2Ge+her      The Hardest Part O… 2000-09-02      91    87    92    NA    NA\n#> 3 3 Doors Down Kryptonite          2000-04-08      81    70    68    67    66\n#> 4 3 Doors Down Loser               2000-10-21      76    76    72    69    67\n#> 5 504 Boyz     Wobble Wobble       2000-04-15      57    34    25    17    17\n#> 6 98^0         Give Me Just One N… 2000-08-19      51    39    34    26    26\n#> # ℹ 311 more rows\n#> # ℹ 71 more variables: wk6 <dbl>, wk7 <dbl>, wk8 <dbl>, wk9 <dbl>, …\n```\n\n表格宽度相当浮夸，因为制表者将不同星期这一变量作为列名，整整列出了76列星期（此处引用的表格仅展示wk1\\~wk5）。显然，星期数是一个变量，将其作为列名很不合理、很不整洁。\n\n使用 `pivot_longer()` 可进行处理，将星期这一变量进行转置：\n\n``` r\nbillboard |> \n  pivot_longer(\n    cols = starts_with(\"wk\"), \n    names_to = \"week\", \n    values_to = \"rank\"\n  )\n#> # A tibble: 24,092 × 5\n#>    artist track                   date.entered week   rank\n#>    <chr>  <chr>                   <date>       <chr> <dbl>\n#>  1 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk1      87\n#>  2 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk2      82\n#>  3 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk3      72\n#>  4 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk4      77\n#>  5 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk5      87\n#>  6 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk6      94\n#>  7 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk7      99\n#>  8 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk8      NA\n#>  9 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk9      NA\n#> 10 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk10     NA\n#> # ℹ 24,082 more rows\n```\n\n参数解释：\n\n-   `cols`用于指定需要转置的列。除了`starts_with(\"wk\")`，也可写成`!c(artist, track, date.entered)`\n\n-   `names_to`用于命名新产生的列，此处将该列命名为`week`\n\n-   `values_to`用于命名存储在原各个列下的变量分离后产生的新列，此处将该列命名为 `rank`\n\n需注意，`week`和`rank`都需要加上引号，因为这是正在创建的新变量。\n\n初步处理完毕，不知道你有没有发现一个问题：如果原表的某个歌曲还未到wk76就已经跌出榜单而观测值为空白，那么转置后岂不是会产生若干只含有`NA`的行？这显然仍需改进。\n\n方法很简单，只需在`pivot_longer()`中加上一个参数：`values_drop_na = TRUE`，即可删去只含`NA`的行。\n\n将转置后表格命名为 billboard_longer 并进行可视化如下图所示：\n\n![](https://r4ds.hadley.nz/data-tidy_files/figure-html/fig-billboard-ranks-1.png)\n\n### pivot_long() 的运作原理\n\n通过上一节的例子能看到`pivot`函数的奇妙之处，让人不禁好奇其原理如何。接下来以另一个数据框为例进行展示。\n\n假设有 3 名患者，id 分别是 A 、 B 和 C，现在对每位患者进行两次血压测量，以此创建 tibble 如下。\n\n``` r\ndf <- tribble(\n  ~id,  ~bp1, ~bp2,\n   \"A\",  100,  120,\n   \"B\",  140,  115,\n   \"C\",  120,  125\n)\n```\n\n> `tribble()`函数用于快捷创建`tibble`。\n\n接下来我们需要将其修整为新的数据框，含有三个变量：id、measurement、value，如下实现：\n\n``` r\ndf |> \n  pivot_longer(\n    cols = bp1:bp2,\n    names_to = \"measurement\",\n    values_to = \"value\"\n  )\n#> # A tibble: 6 × 3\n#>   id    measurement value\n#>   <chr> <chr>       <dbl>\n#> 1 A     bp1           100\n#> 2 A     bp2           120\n#> 3 B     bp1           140\n#> 4 B     bp2           115\n#> 5 C     bp1           120\n#> 6 C     bp2           125\n```\n\n下列组图形象地展现了这一转置过程：\n\n1.  已经是变量的列需要重复，每个转置列重复一次。\n\n![](https://r4ds.hadley.nz/diagrams/tidy-data/variables.png)\n\n2.  转置列的列名将成为新列中的值。对于原始数据集的每一行，这些值需要重复一次。\n\n![](https://r4ds.hadley.nz/diagrams/tidy-data/column-names.png)\n\n单元格值也会成为新变量中的值，其名称由`values_to`定义，且逐行展开。\n\n![](https://r4ds.hadley.nz/diagrams/tidy-data/cell-values.png)\n\n### 错误其二 \\| 列名包含多个变量\n\n有时制表者为了图方便，列名可能一次性塞入了若干变量，导致要素过多而很不整洁。下面以一名为 who2 的整理了结核病的数据框为例。\n\n``` r\nwho2\n#> # A tibble: 7,240 × 58\n#>   country      year sp_m_014 sp_m_1524 sp_m_2534 sp_m_3544 sp_m_4554\n#>   <chr>       <dbl>    <dbl>     <dbl>     <dbl>     <dbl>     <dbl>\n#> 1 Afghanistan  1980       NA        NA        NA        NA        NA\n#> 2 Afghanistan  1981       NA        NA        NA        NA        NA\n#> 3 Afghanistan  1982       NA        NA        NA        NA        NA\n#> 4 Afghanistan  1983       NA        NA        NA        NA        NA\n#> 5 Afghanistan  1984       NA        NA        NA        NA        NA\n#> 6 Afghanistan  1985       NA        NA        NA        NA        NA\n#> # ℹ 7,234 more rows\n#> # ℹ 51 more variables: sp_m_5564 <dbl>, sp_m_65 <dbl>, sp_f_014 <dbl>, …\n```\n\n这里解释一下制表者对第三列及后续列的命名思路：以下划线分为三个部分，第一部分表示诊断方法，第二部分表示性别，第三部分表示年龄范围。比如 sp_m_014 表示诊断方式sp，男性，0\\~14岁。\n\n可见若拆分后该表将包含六个变量：国家、年份、诊断方法、性别、年龄范围、患者数。\n\n下面依然使用`pivot_long()`函数进行修整：\n\n``` r\nwho2 |> \n  pivot_longer(\n    cols = !(country:year),\n    names_to = c(\"diagnosis\", \"gender\", \"age\"), \n    names_sep = \"_\",\n    values_to = \"count\"\n  )\n#> # A tibble: 405,440 × 6\n#>   country      year diagnosis gender age   count\n#>   <chr>       <dbl> <chr>     <chr>  <chr> <dbl>\n#> 1 Afghanistan  1980 sp        m      014      NA\n#> 2 Afghanistan  1980 sp        m      1524     NA\n#> 3 Afghanistan  1980 sp        m      2534     NA\n#> 4 Afghanistan  1980 sp        m      3544     NA\n#> 5 Afghanistan  1980 sp        m      4554     NA\n#> 6 Afghanistan  1980 sp        m      5564     NA\n#> # ℹ 405,434 more rows\n```\n\n这里有新增参数`names_sep`，可将对应列以指定方式进行拆分。\n\n这个例子同时体现了同时命名多个新列的方式，即使用集合`c()`。\n\n### 错误其三 \\| 列名同时包含变量的名称与值\n\n还有更复杂的错误，即变量的名与值相混合。下面以一个名为 household 的记录家庭孩子数与姓名的数据框为例。\n\n``` r\nhousehold\n#> # A tibble: 5 × 5\n#>   family dob_child1 dob_child2 name_child1 name_child2\n#>    <int> <date>     <date>     <chr>       <chr>      \n#> 1      1 1998-11-26 2000-01-29 Susan       Jose       \n#> 2      2 1996-06-22 NA         Mark        <NA>       \n#> 3      3 2002-07-11 2004-04-05 Sam         Seth       \n#> 4      4 2004-10-10 2009-08-27 Craig       Khai       \n#> 5      5 2000-12-05 2005-02-28 Parker      Gracie\n```\n\n可以看出新的挑战是：列名包含两个变量名（dob、name）和另一变量的值（child，值为 1 或 2）。\n\n为解决这一问题，需要在给参数`names_to`提供的向量的首位加一个`.value`，这并不是某一个变量名称，而是表示使用转置列名的**第一个组分**作为输出中的变量名（既然要有组分之分，故还得加一个`names_sep`参数）。同时别忘了`values_drop_na = TRUE`参数，因为一个孩子的家庭会出现 `NA`行。\n\n``` r\nhousehold |> \n  pivot_longer(\n    cols = !family, \n    names_to = c(\".value\", \"child\"), \n    names_sep = \"_\", \n    values_drop_na = TRUE\n  )\n#> # A tibble: 9 × 4\n#>   family child  dob        name \n#>    <int> <chr>  <date>     <chr>\n#> 1      1 child1 1998-11-26 Susan\n#> 2      1 child2 2000-01-29 Jose \n#> 3      2 child1 1996-06-22 Mark \n#> 4      3 child1 2002-07-11 Sam  \n#> 5      3 child2 2004-04-05 Seth \n#> 6      4 child1 2004-10-10 Craig\n#> # ℹ 3 more rows\n```\n\n------------------------------------------------------------------------\n\n## pivot_wider()\n\n整个 5.3 节均使用pivot_long()函数对表格进行修整，整体变得更长。下面讨论将数据框变宽的修整情形，以包含医疗保险患者体检数据的数据框为例：\n\n``` r\ncms_patient_experience\n#> # A tibble: 500 × 5\n#>   org_pac_id org_nm                     measure_cd   measure_title   prf_rate\n#>   <chr>      <chr>                      <chr>        <chr>              <dbl>\n#> 1 0446157747 USC CARE MEDICAL GROUP INC CAHPS_GRP_1  CAHPS for MIPS…       63\n#> 2 0446157747 USC CARE MEDICAL GROUP INC CAHPS_GRP_2  CAHPS for MIPS…       87\n#> 3 0446157747 USC CARE MEDICAL GROUP INC CAHPS_GRP_3  CAHPS for MIPS…       86\n#> 4 0446157747 USC CARE MEDICAL GROUP INC CAHPS_GRP_5  CAHPS for MIPS…       57\n#> 5 0446157747 USC CARE MEDICAL GROUP INC CAHPS_GRP_8  CAHPS for MIPS…       85\n#> 6 0446157747 USC CARE MEDICAL GROUP INC CAHPS_GRP_12 CAHPS for MIPS…       24\n#> # ℹ 494 more rows\n```\n\n现在研究的重点是组织名称（org_nm），要确保每个组织名称仅有一行。\n\n此时使用`pivot_wider()`进行修正如下：\n\n``` r\ncms_patient_experience |> \n  pivot_wider(\n    id_cols = starts_with(\"org\"),\n    names_from = measure_cd,\n    values_from = prf_rate\n  )\n#> # A tibble: 95 × 8\n#>   org_pac_id org_nm           CAHPS_GRP_1 CAHPS_GRP_2 CAHPS_GRP_3 CAHPS_GRP_5\n#>   <chr>      <chr>                  <dbl>       <dbl>       <dbl>       <dbl>\n#> 1 0446157747 USC CARE MEDICA…          63          87          86          57\n#> 2 0446162697 ASSOCIATION OF …          59          85          83          63\n#> 3 0547164295 BEAVER MEDICAL …          49          NA          75          44\n#> 4 0749333730 CAPE PHYSICIANS…          67          84          85          65\n#> 5 0840104360 ALLIANCE PHYSIC…          66          87          87          64\n#> 6 0840109864 REX HOSPITAL INC          73          87          84          67\n#> # ℹ 89 more rows\n#> # ℹ 2 more variables: CAHPS_GRP_8 <dbl>, CAHPS_GRP_12 <dbl>\n```\n\n参数说明：\n\n-   `id_cols`表示保留的列的特征，此处仅保留以 org 开头的列，而排除了 measure_title 列\n-   `names_from`表示新列名在原表中所在列的列名\n-   `values_from`表示新列中包含变量值在原表中所在列的列名\n\n### pivot_wider() 的运作原理\n\n为了了解工作原理，再次从一个最简单的数据集开始。假设有两个 id 为 A 和 B 的两名患者，对患者 A 进行了 3 次血压测量，对患者 B 进行了 2 次：\n\n``` r\ndf <- tribble(\n  ~id, ~measurement, ~value,\n  \"A\",        \"bp1\",    100,\n  \"B\",        \"bp1\",    140,\n  \"B\",        \"bp2\",    115, \n  \"A\",        \"bp2\",    120,\n  \"A\",        \"bp3\",    105\n)\n```\n\n下面从 value 列取值，从 measurement 列取列名：\n\n``` r\ndf |> \n  pivot_wider(\n    names_from = measurement,\n    values_from = value\n  )\n#> # A tibble: 2 × 4\n#>   id      bp1   bp2   bp3\n#>   <chr> <dbl> <dbl> <dbl>\n#> 1 A       100   120   105\n#> 2 B       140   115    NA\n```\n\n首先，此过程需要弄清楚新的行和列中的内容。新列的名称将是 measurement 中的唯一值，可通过`distinct()`函数确认：\n\n``` r\ndf |> \n  distinct(measurement) |> \n  pull()\n#> [1] \"bp1\" \"bp2\" \"bp3\"\n```\n\n默认情况下，输出的新行由所有未进入新列名或值的变量决定，这些行称为`id_cols`。如下：\n\n``` r\ndf |> \n  select(-measurement, -value) |> \n  distinct()\n#> # A tibble: 2 × 1\n#>   id   \n#>   <chr>\n#> 1 A    \n#> 2 B\n```\n\n然后，`pivot_wider()`将这些结果组合起来，生成一个空数据框：\n\n``` r\ndf |> \n  select(-measurement, -value) |> \n  distinct() |> \n  mutate(x = NA, y = NA, z = NA)\n#> # A tibble: 2 × 4\n#>   id    x     y     z    \n#>   <chr> <lgl> <lgl> <lgl>\n#> 1 A     NA    NA    NA   \n#> 2 B     NA    NA    NA\n```\n\n最后它会使用输入中的数据填充所有`NA`值。在这种情况下，并非输出中的每个单元格在输入中都有相应的值，因为患者 B 没有第三次血压测量，因此该单元格仍然缺失。\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":"auto","echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","output-file":"ch5_data_tidying.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.7.32","bibliography":["../references.bib"],"editor":"visual","theme":["cosmo","brand"],"title":"数据整洁化"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}