{"title":"数据导入","markdown":{"yaml":{"title":"数据导入","format":"html"},"headingText":"引言","containsRefs":false,"markdown":"\n\n\n\n\n本章介绍如何读取纯文本矩形数据文件，如何将数据写入文件，以及如何创建数据框。\n\n主要学习`readr`包，同样是`tidyverse`的组成部分。\n\n```R\nlibrary(tidyverse)\n```\n\n## 从文件中读取数据\n\n首先重点介绍最常见的矩形数据文件类型 CSV（Comma-Separated Values）。\n\n下面是一个简单的 CSV 文件。第一行（通常称为标题行）提供列名称，接下的六行提供数据。列之间用逗号分隔。\n\n```csv\nStudent ID,Full Name,favourite.food,mealPlan,AGE\n1,Sunil Huffmann,Strawberry yoghurt,Lunch only,4\n2,Barclay Lynn,French fries,Lunch only,5\n3,Jayendra Lyne,N/A,Breakfast and lunch,7\n4,Leon Rossini,Anchovies,Lunch only,\n5,Chidiegwu Dunkel,Pizza,Breakfast and lunch,five\n6,Güvenç Attila,Ice cream,Lunch only,6\n```\n\n使用`read_csv()`将文件读取到R中。其第一个参数最重要——文件路径（也可以使用URL）。\n\n```R\nstudents <- read_csv(\"data/students.csv\")\nstudents <- read_csv(\"https://pos.it/r4ds-students-csv\")\n```\n\n读入数据后，通常需要先对其进行转换，以便在分析时更易使用。带着这一目的，我们再审视一下这个数据表。\n\n````R\nstudents\n#> # A tibble: 6 × 5\n#>   `Student ID` `Full Name`      favourite.food     mealPlan            AGE  \n#>          <dbl> <chr>            <chr>              <chr>               <chr>\n#> 1            1 Sunil Huffmann   Strawberry yoghurt Lunch only          4    \n#> 2            2 Barclay Lynn     French fries       Lunch only          5    \n#> 3            3 Jayendra Lyne    N/A                Breakfast and lunch 7    \n#> 4            4 Leon Rossini     Anchovies          Lunch only          <NA> \n#> 5            5 Chidiegwu Dunkel Pizza              Breakfast and lunch five \n#> 6            6 Güvenç Attila    Ice cream          Lunch only          6\n````\n\n有两个问题：\n\n- 默认情况下，`read_csv()`会将空字符串`\"\"`识别为 NA，但注意到原表中有个“N/A”，并未在R中显示为NA，可以单独设置将其读取为NA。\n- `Student ID`和`Full Name`两个列名有引号，是因为原表中列名包含空格，不合法，除非在读取时用引号标注。\n\n```R\n> students <- read_csv(\"data/students.csv\", na = c(\"N/A\", \"\"))\n> students |> \n  rename(\n    student_id = `Student ID`,\n    full_name = `Full Name`\n  )\n> students\n#> # A tibble: 6 × 5\n#>   `Student ID` `Full Name`      favourite.food     mealPlan            AGE  \n#>          <dbl> <chr>            <chr>              <chr>               <chr>\n#> 1            1 Sunil Huffmann   Strawberry yoghurt Lunch only          4    \n#> 2            2 Barclay Lynn     French fries       Lunch only          5    \n#> 3            3 Jayendra Lyne    <NA>               Breakfast and lunch 7    \n#> 4            4 Leon Rossini     Anchovies          Lunch only          <NA> \n#> 5            5 Chidiegwu Dunkel Pizza              Breakfast and lunch five \n#> 6            6 Güvenç Attila    Ice cream          Lunch only          6\n```\n\n接下来考虑数据类型与数据本身的校正，有两点需要关注。\n\n- `meal_plan`是一个分类变量，应该在R中表示为因子（fct），而非字符（chr）。\n- age列中有一个数据为five而非数字5。\n\n```R\nstudents |>\n  janitor::clean_names() |>\n  mutate(\n    meal_plan = factor(meal_plan),\n    age = parse_number(if_else(age == \"five\", \"5\", age))\n  )\n#> # A tibble: 6 × 5\n#>   student_id full_name        favourite_food     meal_plan           age  \n#>        <dbl> <chr>            <chr>              <fct>               <chr>\n#> 1          1 Sunil Huffmann   Strawberry yoghurt Lunch only          4    \n#> 2          2 Barclay Lynn     French fries       Lunch only          5    \n#> 3          3 Jayendra Lyne    <NA>               Breakfast and lunch 7    \n#> 4          4 Leon Rossini     Anchovies          Lunch only          <NA> \n#> 5          5 Chidiegwu Dunkel Pizza              Breakfast and lunch five \n#> 6          6 Güvenç Attila    Ice cream          Lunch only          6\n```\n\n这样便基本改完了。\n\n另外`read_csv()`函数可以快捷生成格式化为 CSV 文件的文本字符串：\n\n```R\nread_csv(\n  \"a,b,c\n  1,2,3\n  4,5,6\"\n)\n#> # A tibble: 2 × 3\n#>       a     b     c\n#>   <dbl> <dbl> <dbl>\n#> 1     1     2     3\n#> 2     4     5     6\n```\n\n通常，默认使用数据的第一行作为列名。但是，经常能在文件顶部看到有几行元数据，干扰列名的指定。可以使用`skip = n`跳过前n行，或者使用`cmment = #`丢弃所有以#开头的行：\n\n```R\nread_csv(\n  \"The first line of metadata\n  The second line of metadata\n  x,y,z\n  1,2,3\",\n  skip = 2\n)\n#> # A tibble: 1 × 3\n#>       x     y     z\n#>   <dbl> <dbl> <dbl>\n#> 1     1     2     3\n\nread_csv(\n  \"# A comment I want to skip\n  x,y,z\n  1,2,3\",\n  comment = \"#\"\n)\n#> # A tibble: 1 × 3\n#>       x     y     z\n#>   <dbl> <dbl> <dbl>\n#> 1     1     2     3\n```\n\n在某些情况下，数据可能没有列名。可以使用 `col_names = FALSE`来指出不要将第一行视为标题，而是从X1到Xn按顺序标记它们：\n\n```R\nread_csv(\n  \"1,2,3\n  4,5,6\",\n  col_names = FALSE\n)\n#> # A tibble: 2 × 3\n#>      X1    X2    X3\n#>   <dbl> <dbl> <dbl>\n#> 1     1     2     3\n#> 2     4     5     6\n```\n\n或者，可以传递一个字符向量给`col_names`，从而自定义列名：\n\n```R\nread_csv(\n  \"1,2,3\n  4,5,6\",\n  col_names = c(\"x\", \"y\", \"z\")\n)\n#> # A tibble: 2 × 3\n#>       x     y     z\n#>   <dbl> <dbl> <dbl>\n#> 1     1     2     3\n#> 2     4     5     6\n```\n\n\n\n一旦掌握了`read_csv()`，其他类似函数便迎刃而解。\n\n- `read_csv2()`读取以分号分隔的文件，在用逗号作为较大位数分隔符的国家很常见。\n- `read_tsv()`读取制表符分隔的文件。\n- `read_delim()`读入包含任何分隔符的文件，自动猜测分隔符。\n- `read_fwf()`读取固定宽度的文件。\n- `read_table()`读取固定宽度文件的一种常见变体，其中列由空格分隔。\n- `read_log()`读取 Apache 样式的日志文件。\n\n\n\n## 控制列类型\n\nCSV文件不包含有关变量类型的信息（即它是logical、number、string 等），故readr会自己猜测类型。\n\n但这难免会存在失误。最常见的原因是列中包含意外值，且一般会误判为chr。**如果用`NA`之外的字符表示缺失值也称为意外值。**比如：\n\n```R\n> simple_csv <- \"\n  x\n  10\n  .\n  20\n  30\"\n> read_csv(simple_csv)\n#> # A tibble: 4 × 1\n#>   x    \n#>   <chr>\n#> 1 10   \n#> 2 .    \n#> 3 20   \n#> 4 30\n```\n\n这个表很短，很快能发现预期外字符的位置，当数据特别长时需要一种特定方法。通过`col_types`参数自主指定每列的数据类型，然后看readr在哪报错即可。\n\n```R\ndf <- read_csv(\n  simple_csv, \n  col_types = list(x = col_double()) #指定数据列的类型为双精度浮点数\n)\n#> Warning: One or more parsing issues, call `problems()` on your data frame for\n#> details, e.g.:\n#>   dat <- vroom(...)\n#>   problems(dat)\n```\n\n现在readr指出操作存在问题，并建议我们使用`problems()`函数进一步确认。\n\n```R\nproblems(df)\n#> # A tibble: 1 × 5\n#>     row   col expected actual file                            \n#>   <int> <int> <chr>    <chr>  <chr>                           \n#> 1     3     1 a double .      /tmp/RtmpqR32wU/file2304111d9453\n```\n\n第 3 行第 1 列存在问题，其中 readr 期望得到双精度浮点数，但得到的只是一个`.` 。这表明此数据集使用`.`表示缺失值。所以设置 `na = \".\"`即可让所有意外值回到正轨。\n\n```R\nread_csv(simple_csv, na = \".\")\n#> # A tibble: 4 × 1\n#>       x\n#>   <dbl>\n#> 1    10\n#> 2    NA\n#> 3    20\n#> 4    30\n```\n\n像上面`col_double()`一样的列类型函数共有九种：\n\n- `col_logical()`和`col_double()`读取逻辑量和实数。\n- `col_integer()`读取整数。\n- `col_character()`读取字符串。\n- `col_factor()`、`col_date()`、`col_datetime()` 分别创建因子、日期和时间。\n- `col_number()`是一个数字解析器，它忽略非数字组件，对货币数据特别有用。\n- `col_skip()`跳过一列，使其不包含在结果中，如果有一个大型 CSV 文件并且只想使用某些列，这对于加快读取数据很有效。\n\n除了用`list()`进行指定，还有`cols()`，且用`.default`参数表示所有列：\n\n```R\nanother_csv <- \"\nx,y,z\n1,2,3\"\n\nread_csv(\n  another_csv, \n  col_types = cols(.default = col_character())\n)\n#> # A tibble: 1 × 3\n#>   x     y     z    \n#>   <chr> <chr> <chr>\n#> 1 1     2     3\n```\n\n另外还有`cols_only()`值得一提，它可以只读取我们指定类型的列：\n\n```R\nread_csv(\n  another_csv,\n  col_types = cols_only(x = col_character())\n)\n#> # A tibble: 1 × 1\n#>   x    \n#>   <chr>\n#> 1 1\n```\n\n\n\n## 多个文件读取数据\n\n有时，数据被拆分为多个文件，而不是包含在单个文件中。如下例一次性读取：\n\n```R\nsales_files <- c(\"data/01-sales.csv\", \"data/02-sales.csv\", \"data/03-sales.csv\")\nread_csv(sales_files, id = \"file\")\n#> # A tibble: 19 × 6\n#>   file              month    year brand  item     n\n#>   <chr>             <chr>   <dbl> <dbl> <dbl> <dbl>\n#> 1 data/01-sales.csv January  2019     1  1234     3\n#> 2 data/01-sales.csv January  2019     1  8721     9\n#> 3 data/01-sales.csv January  2019     1  1822     2\n#> 4 data/01-sales.csv January  2019     2  3333     1\n#> 5 data/01-sales.csv January  2019     2  2156     9\n#> 6 data/01-sales.csv January  2019     2  3987     6\n#> # ℹ 13 more rows\n```\n\n注意到`id`参数为表格添加了一个指定名称的新列，该列用于标识数据来自的源文件。\n\n\n\n## 文件写入\n\n要将CSV等文件保存回磁盘，，使用`write_csv()`和`write_tsv()`类型函数。有两个主要参数，一个是数据框，一个是保存的地址。\n\n```R\nwrite_csv(students, \"students.csv\")\n```\n\n但是这样有个弊端。我们都知道CSV文件不包含列的类型，所以即便我们已经修改过表格，而写入后再读取仍会恢复原样。有两种解决办法保留列类型：\n\n- 使用`write_rds()`和`read_rds()`函数。rds是以R自定义的二进制存储格式，所以我们要重新加载时的R对象与当时存储的是完全相同的。\n\n- `arrow`包中的`write_parquet()`和`read_parquet()`函数。这同样是二进制存储格式，且不限于R，可以跨编程语言共享。\n\n## 数据输入\n\n有时会需要我们自己手搓一个tibble，有两个函数来实现。\n\n- `tibble()`。在输入数据时横向排列。\n\n```R\ntibble(\n  x = c(1, 2, 5), \n  y = c(\"h\", \"m\", \"g\"),\n  z = c(0.08, 0.83, 0.60)\n)\n#> # A tibble: 3 × 3\n#>       x y         z\n#>   <dbl> <chr> <dbl>\n#> 1     1 h      0.08\n#> 2     2 m      0.83\n#> 3     5 g      0.6\n```\n\n- `tribble()`。在输入数据时纵向排列，更方便排版。注意输入时列标题以`~`开头。\n\n```R\ntribble(\n  ~x, ~y, ~z,\n  1, \"h\", 0.08,\n  2, \"m\", 0.83,\n  5, \"g\", 0.60\n)\n#> # A tibble: 3 × 3\n#>       x y         z\n#>   <dbl> <chr> <dbl>\n#> 1     1 h      0.08\n#> 2     2 m      0.83\n#> 3     5 g      0.6\n```\n\n> tribble表示：**tr**ansposed t**ibble**\n\n","srcMarkdownNoYaml":"\n\n\n\n## 引言\n\n本章介绍如何读取纯文本矩形数据文件，如何将数据写入文件，以及如何创建数据框。\n\n主要学习`readr`包，同样是`tidyverse`的组成部分。\n\n```R\nlibrary(tidyverse)\n```\n\n## 从文件中读取数据\n\n首先重点介绍最常见的矩形数据文件类型 CSV（Comma-Separated Values）。\n\n下面是一个简单的 CSV 文件。第一行（通常称为标题行）提供列名称，接下的六行提供数据。列之间用逗号分隔。\n\n```csv\nStudent ID,Full Name,favourite.food,mealPlan,AGE\n1,Sunil Huffmann,Strawberry yoghurt,Lunch only,4\n2,Barclay Lynn,French fries,Lunch only,5\n3,Jayendra Lyne,N/A,Breakfast and lunch,7\n4,Leon Rossini,Anchovies,Lunch only,\n5,Chidiegwu Dunkel,Pizza,Breakfast and lunch,five\n6,Güvenç Attila,Ice cream,Lunch only,6\n```\n\n使用`read_csv()`将文件读取到R中。其第一个参数最重要——文件路径（也可以使用URL）。\n\n```R\nstudents <- read_csv(\"data/students.csv\")\nstudents <- read_csv(\"https://pos.it/r4ds-students-csv\")\n```\n\n读入数据后，通常需要先对其进行转换，以便在分析时更易使用。带着这一目的，我们再审视一下这个数据表。\n\n````R\nstudents\n#> # A tibble: 6 × 5\n#>   `Student ID` `Full Name`      favourite.food     mealPlan            AGE  \n#>          <dbl> <chr>            <chr>              <chr>               <chr>\n#> 1            1 Sunil Huffmann   Strawberry yoghurt Lunch only          4    \n#> 2            2 Barclay Lynn     French fries       Lunch only          5    \n#> 3            3 Jayendra Lyne    N/A                Breakfast and lunch 7    \n#> 4            4 Leon Rossini     Anchovies          Lunch only          <NA> \n#> 5            5 Chidiegwu Dunkel Pizza              Breakfast and lunch five \n#> 6            6 Güvenç Attila    Ice cream          Lunch only          6\n````\n\n有两个问题：\n\n- 默认情况下，`read_csv()`会将空字符串`\"\"`识别为 NA，但注意到原表中有个“N/A”，并未在R中显示为NA，可以单独设置将其读取为NA。\n- `Student ID`和`Full Name`两个列名有引号，是因为原表中列名包含空格，不合法，除非在读取时用引号标注。\n\n```R\n> students <- read_csv(\"data/students.csv\", na = c(\"N/A\", \"\"))\n> students |> \n  rename(\n    student_id = `Student ID`,\n    full_name = `Full Name`\n  )\n> students\n#> # A tibble: 6 × 5\n#>   `Student ID` `Full Name`      favourite.food     mealPlan            AGE  \n#>          <dbl> <chr>            <chr>              <chr>               <chr>\n#> 1            1 Sunil Huffmann   Strawberry yoghurt Lunch only          4    \n#> 2            2 Barclay Lynn     French fries       Lunch only          5    \n#> 3            3 Jayendra Lyne    <NA>               Breakfast and lunch 7    \n#> 4            4 Leon Rossini     Anchovies          Lunch only          <NA> \n#> 5            5 Chidiegwu Dunkel Pizza              Breakfast and lunch five \n#> 6            6 Güvenç Attila    Ice cream          Lunch only          6\n```\n\n接下来考虑数据类型与数据本身的校正，有两点需要关注。\n\n- `meal_plan`是一个分类变量，应该在R中表示为因子（fct），而非字符（chr）。\n- age列中有一个数据为five而非数字5。\n\n```R\nstudents |>\n  janitor::clean_names() |>\n  mutate(\n    meal_plan = factor(meal_plan),\n    age = parse_number(if_else(age == \"five\", \"5\", age))\n  )\n#> # A tibble: 6 × 5\n#>   student_id full_name        favourite_food     meal_plan           age  \n#>        <dbl> <chr>            <chr>              <fct>               <chr>\n#> 1          1 Sunil Huffmann   Strawberry yoghurt Lunch only          4    \n#> 2          2 Barclay Lynn     French fries       Lunch only          5    \n#> 3          3 Jayendra Lyne    <NA>               Breakfast and lunch 7    \n#> 4          4 Leon Rossini     Anchovies          Lunch only          <NA> \n#> 5          5 Chidiegwu Dunkel Pizza              Breakfast and lunch five \n#> 6          6 Güvenç Attila    Ice cream          Lunch only          6\n```\n\n这样便基本改完了。\n\n另外`read_csv()`函数可以快捷生成格式化为 CSV 文件的文本字符串：\n\n```R\nread_csv(\n  \"a,b,c\n  1,2,3\n  4,5,6\"\n)\n#> # A tibble: 2 × 3\n#>       a     b     c\n#>   <dbl> <dbl> <dbl>\n#> 1     1     2     3\n#> 2     4     5     6\n```\n\n通常，默认使用数据的第一行作为列名。但是，经常能在文件顶部看到有几行元数据，干扰列名的指定。可以使用`skip = n`跳过前n行，或者使用`cmment = #`丢弃所有以#开头的行：\n\n```R\nread_csv(\n  \"The first line of metadata\n  The second line of metadata\n  x,y,z\n  1,2,3\",\n  skip = 2\n)\n#> # A tibble: 1 × 3\n#>       x     y     z\n#>   <dbl> <dbl> <dbl>\n#> 1     1     2     3\n\nread_csv(\n  \"# A comment I want to skip\n  x,y,z\n  1,2,3\",\n  comment = \"#\"\n)\n#> # A tibble: 1 × 3\n#>       x     y     z\n#>   <dbl> <dbl> <dbl>\n#> 1     1     2     3\n```\n\n在某些情况下，数据可能没有列名。可以使用 `col_names = FALSE`来指出不要将第一行视为标题，而是从X1到Xn按顺序标记它们：\n\n```R\nread_csv(\n  \"1,2,3\n  4,5,6\",\n  col_names = FALSE\n)\n#> # A tibble: 2 × 3\n#>      X1    X2    X3\n#>   <dbl> <dbl> <dbl>\n#> 1     1     2     3\n#> 2     4     5     6\n```\n\n或者，可以传递一个字符向量给`col_names`，从而自定义列名：\n\n```R\nread_csv(\n  \"1,2,3\n  4,5,6\",\n  col_names = c(\"x\", \"y\", \"z\")\n)\n#> # A tibble: 2 × 3\n#>       x     y     z\n#>   <dbl> <dbl> <dbl>\n#> 1     1     2     3\n#> 2     4     5     6\n```\n\n\n\n一旦掌握了`read_csv()`，其他类似函数便迎刃而解。\n\n- `read_csv2()`读取以分号分隔的文件，在用逗号作为较大位数分隔符的国家很常见。\n- `read_tsv()`读取制表符分隔的文件。\n- `read_delim()`读入包含任何分隔符的文件，自动猜测分隔符。\n- `read_fwf()`读取固定宽度的文件。\n- `read_table()`读取固定宽度文件的一种常见变体，其中列由空格分隔。\n- `read_log()`读取 Apache 样式的日志文件。\n\n\n\n## 控制列类型\n\nCSV文件不包含有关变量类型的信息（即它是logical、number、string 等），故readr会自己猜测类型。\n\n但这难免会存在失误。最常见的原因是列中包含意外值，且一般会误判为chr。**如果用`NA`之外的字符表示缺失值也称为意外值。**比如：\n\n```R\n> simple_csv <- \"\n  x\n  10\n  .\n  20\n  30\"\n> read_csv(simple_csv)\n#> # A tibble: 4 × 1\n#>   x    \n#>   <chr>\n#> 1 10   \n#> 2 .    \n#> 3 20   \n#> 4 30\n```\n\n这个表很短，很快能发现预期外字符的位置，当数据特别长时需要一种特定方法。通过`col_types`参数自主指定每列的数据类型，然后看readr在哪报错即可。\n\n```R\ndf <- read_csv(\n  simple_csv, \n  col_types = list(x = col_double()) #指定数据列的类型为双精度浮点数\n)\n#> Warning: One or more parsing issues, call `problems()` on your data frame for\n#> details, e.g.:\n#>   dat <- vroom(...)\n#>   problems(dat)\n```\n\n现在readr指出操作存在问题，并建议我们使用`problems()`函数进一步确认。\n\n```R\nproblems(df)\n#> # A tibble: 1 × 5\n#>     row   col expected actual file                            \n#>   <int> <int> <chr>    <chr>  <chr>                           \n#> 1     3     1 a double .      /tmp/RtmpqR32wU/file2304111d9453\n```\n\n第 3 行第 1 列存在问题，其中 readr 期望得到双精度浮点数，但得到的只是一个`.` 。这表明此数据集使用`.`表示缺失值。所以设置 `na = \".\"`即可让所有意外值回到正轨。\n\n```R\nread_csv(simple_csv, na = \".\")\n#> # A tibble: 4 × 1\n#>       x\n#>   <dbl>\n#> 1    10\n#> 2    NA\n#> 3    20\n#> 4    30\n```\n\n像上面`col_double()`一样的列类型函数共有九种：\n\n- `col_logical()`和`col_double()`读取逻辑量和实数。\n- `col_integer()`读取整数。\n- `col_character()`读取字符串。\n- `col_factor()`、`col_date()`、`col_datetime()` 分别创建因子、日期和时间。\n- `col_number()`是一个数字解析器，它忽略非数字组件，对货币数据特别有用。\n- `col_skip()`跳过一列，使其不包含在结果中，如果有一个大型 CSV 文件并且只想使用某些列，这对于加快读取数据很有效。\n\n除了用`list()`进行指定，还有`cols()`，且用`.default`参数表示所有列：\n\n```R\nanother_csv <- \"\nx,y,z\n1,2,3\"\n\nread_csv(\n  another_csv, \n  col_types = cols(.default = col_character())\n)\n#> # A tibble: 1 × 3\n#>   x     y     z    \n#>   <chr> <chr> <chr>\n#> 1 1     2     3\n```\n\n另外还有`cols_only()`值得一提，它可以只读取我们指定类型的列：\n\n```R\nread_csv(\n  another_csv,\n  col_types = cols_only(x = col_character())\n)\n#> # A tibble: 1 × 1\n#>   x    \n#>   <chr>\n#> 1 1\n```\n\n\n\n## 多个文件读取数据\n\n有时，数据被拆分为多个文件，而不是包含在单个文件中。如下例一次性读取：\n\n```R\nsales_files <- c(\"data/01-sales.csv\", \"data/02-sales.csv\", \"data/03-sales.csv\")\nread_csv(sales_files, id = \"file\")\n#> # A tibble: 19 × 6\n#>   file              month    year brand  item     n\n#>   <chr>             <chr>   <dbl> <dbl> <dbl> <dbl>\n#> 1 data/01-sales.csv January  2019     1  1234     3\n#> 2 data/01-sales.csv January  2019     1  8721     9\n#> 3 data/01-sales.csv January  2019     1  1822     2\n#> 4 data/01-sales.csv January  2019     2  3333     1\n#> 5 data/01-sales.csv January  2019     2  2156     9\n#> 6 data/01-sales.csv January  2019     2  3987     6\n#> # ℹ 13 more rows\n```\n\n注意到`id`参数为表格添加了一个指定名称的新列，该列用于标识数据来自的源文件。\n\n\n\n## 文件写入\n\n要将CSV等文件保存回磁盘，，使用`write_csv()`和`write_tsv()`类型函数。有两个主要参数，一个是数据框，一个是保存的地址。\n\n```R\nwrite_csv(students, \"students.csv\")\n```\n\n但是这样有个弊端。我们都知道CSV文件不包含列的类型，所以即便我们已经修改过表格，而写入后再读取仍会恢复原样。有两种解决办法保留列类型：\n\n- 使用`write_rds()`和`read_rds()`函数。rds是以R自定义的二进制存储格式，所以我们要重新加载时的R对象与当时存储的是完全相同的。\n\n- `arrow`包中的`write_parquet()`和`read_parquet()`函数。这同样是二进制存储格式，且不限于R，可以跨编程语言共享。\n\n## 数据输入\n\n有时会需要我们自己手搓一个tibble，有两个函数来实现。\n\n- `tibble()`。在输入数据时横向排列。\n\n```R\ntibble(\n  x = c(1, 2, 5), \n  y = c(\"h\", \"m\", \"g\"),\n  z = c(0.08, 0.83, 0.60)\n)\n#> # A tibble: 3 × 3\n#>       x y         z\n#>   <dbl> <chr> <dbl>\n#> 1     1 h      0.08\n#> 2     2 m      0.83\n#> 3     5 g      0.6\n```\n\n- `tribble()`。在输入数据时纵向排列，更方便排版。注意输入时列标题以`~`开头。\n\n```R\ntribble(\n  ~x, ~y, ~z,\n  1, \"h\", 0.08,\n  2, \"m\", 0.83,\n  5, \"g\", 0.60\n)\n#> # A tibble: 3 × 3\n#>       x y         z\n#>   <dbl> <chr> <dbl>\n#> 1     1 h      0.08\n#> 2     2 m      0.83\n#> 3     5 g      0.6\n```\n\n> tribble表示：**tr**ansposed t**ibble**\n\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":"auto","echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","output-file":"ch7_data_import.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.7.32","bibliography":["../references.bib"],"editor":"visual","theme":["cosmo","brand"],"title":"数据导入"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}