[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "R4DS Notes from DJ",
    "section": "",
    "text": "序\n恭喜您发现这片蓝海！此站点用于呈现本人研读《R for Data Science》期间所整理的系统化笔记。\n《R for Data Science》由 Hadley Wickham 主编，被视为当代 R 语言生态的关键基石。全书以 tidyverse 为方法论核心，将数据导入、整理、转换、可视化、建模与再现性文档组织为一个一致而清晰的分析工作流，使读者能够在统一的语义框架下理解“以数据为中心”的思维方式。其价值不仅在于介绍函数与语法，更在于重塑 R 社区对数据科学流程的整体认识，是近年来影响力最为深远的 R 语言教材之一。\n自 2025 年 3 月起，本人围绕全书内容持续整理读书笔记。除基础操作外，还重点聚焦 tidy 数据结构、管道化表达、图形语法及工作流设计原则等核心机制，并结合个人实践对部分概念进行再组织与适度延展。近半年的积累逐渐构成一个较为完整的知识框架，故将其汇整于此，与诸君共享。\n若文中有理解偏差或论述不尽之处，诚挚期待指正。若这些笔记能为正在学习 tidyverse 或构建 R 数据分析流程的读者带来参考价值，则深感荣幸！\n本书在线阅读网址：https://r4ds.hadley.nz/\n开场白结束，祝各位阅读愉快。\n丁加\n2025年11月22日于湘雅",
    "crumbs": [
      "序"
    ]
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "1  引言",
    "section": "",
    "text": "引言\n\n上图展示了完成一个数据科学项目的基本模型，也是全书的核心思想。\n\n导入。读取文本文件、数据库或 API 数据，是整个流程的起点。\n规整。通过结构化与清洗，使数据具有一致的语义形式，便于后续分析。\n转换。包含筛选、创建变量、变换尺度、生成汇总统计等操作。\n可视化。以图形揭示模式、验证假设，使数据关系得以直观呈现。\n建模。在可视化基础上进行定量推断，是进一步精确回答问题的工具。\n交流。通过图表、模型与文档向他人清晰传递数据分析的过程与结论。\n\n上述六个步骤均依赖稳定的编程能力。数据科学并非要求精湛的程序设计，但掌握必要的编码技能可显著提升分析效率，使工作流更具连贯性与可复用性。",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>引言</span>"
    ]
  },
  {
    "objectID": "chapters/ch1_data_visualization.html",
    "href": "chapters/ch1_data_visualization.html",
    "title": "2  数据可视化",
    "section": "",
    "text": "2.1 引言\nggplot2是所有R可视化工具中最优雅的之一。 本章需载入下列R包：",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>数据可视化</span>"
    ]
  },
  {
    "objectID": "chapters/ch1_data_visualization.html#引言",
    "href": "chapters/ch1_data_visualization.html#引言",
    "title": "2  数据可视化",
    "section": "",
    "text": "library(tidyverse)\nlibrary(palmerpenguins) # 包含示例数据\nlibrary(ggthemes) # 提供色盲调色板",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>数据可视化</span>"
    ]
  },
  {
    "objectID": "chapters/ch1_data_visualization.html#绘制企鹅数据图",
    "href": "chapters/ch1_data_visualization.html#绘制企鹅数据图",
    "title": "2  数据可视化",
    "section": "2.2 绘制企鹅数据图",
    "text": "2.2 绘制企鹅数据图\n本书开篇甩出一系列问题：企鹅的脚蹼长度和体重之间的关系是怎样的？是线性？非线性？这种关系是否因企鹅的种类而异？与地理位置有关吗？针对这些问题，我们将进行可视化操作以回答。\n首先了解一些术语：\n\n变量(variable)是可以测量的数量、质量等属性。\n值(value)是测量变量时变量的状态。变量的值可能会因测量而异。\n观测值(observation)是在相近条件下进行的一组测量 （通常就是在同一时间对同一对象的所有值）。一个观测值将包含多个值，每个值都与不同的变量相关联。\n表格数据(tabular data)是一组值，每个值都与一个变量和一个观测值相关联。\n\n接下来输入palmerpenguins::penguins以打开示例数据的数据框。注意到并未显示出所有变量。\n&gt; palmerpenguins::penguins\n# A tibble: 344 × 8\n   species island  bill_length_mm bill_depth_mm\n   &lt;fct&gt;   &lt;fct&gt;            &lt;dbl&gt;         &lt;dbl&gt;\n 1 Adelie  Torger…           39.1          18.7\n 2 Adelie  Torger…           39.5          17.4\n 3 Adelie  Torger…           40.3          18  \n 4 Adelie  Torger…           NA            NA  \n 5 Adelie  Torger…           36.7          19.3\n 6 Adelie  Torger…           39.3          20.6\n 7 Adelie  Torger…           38.9          17.8\n 8 Adelie  Torger…           39.2          19.6\n 9 Adelie  Torger…           34.1          18.1\n10 Adelie  Torger…           42            20.2\n# ℹ 334 more rows\n# ℹ 4 more variables: flipper_length_mm &lt;int&gt;,\n#   body_mass_g &lt;int&gt;, sex &lt;fct&gt;, year &lt;int&gt;\n# ℹ Use `print(n = ...)` to see more rows\n也可使用glimpse(penguins)，查看所有变量和每个变量的前几个观测值的替代视图。\n&gt; glimpse(penguins)\nRows: 344\nColumns: 8\n$ species           &lt;fct&gt; Adelie, Adelie, Adelie, Adelie, Ad…\n$ island            &lt;fct&gt; Torgersen, Torgersen, Torgersen, T…\n$ bill_length_mm    &lt;dbl&gt; 39.1, 39.5, 40.3, NA, 36.7, 39.3, …\n$ bill_depth_mm     &lt;dbl&gt; 18.7, 17.4, 18.0, NA, 19.3, 20.6, …\n$ flipper_length_mm &lt;int&gt; 181, 186, 195, NA, 193, 190, 181, …\n$ body_mass_g       &lt;int&gt; 3750, 3800, 3250, NA, 3450, 3650, …\n$ sex               &lt;fct&gt; male, female, female, NA, female, …\n$ year              &lt;int&gt; 2007, 2007, 2007, 2007, 2007, 2007…\n此外还可运行view(penguins)，打开交互式数据查看器。\n我们的目标是用可视化图显示这些企鹅的脚蹼长度和体重、种类之间的关系。所以接下来开始介绍ggplot()这一核心函数。\n第一个参数是data，表示我们绘图所需的数据集，此处即ggplot(data = penguins)。但由于我们还没有声明具体绘图方式，因此现在画布尚为空白。\n第二个参数为mapping，通常与美学函数(aes)成对出现。aes()函数中x和y的参数要分别映射到 x 轴和 y 轴，在本例中，我们将脚蹼长度映射到x，将体重映射到y，ggplot2 会在参数中查找映射的变量。故而输入：\nggplot(\n  data = penguins,\n  mapping = aes(x = flipper_length_mm, y = body_mass_g)\n)\n\n现在画布上出现了坐标轴，脚蹼长度为 x 轴，体重为 y 轴。但是还没有图线，因为尚未设置绘图模板。\n下面定义绘图模板geom (geometric object)。不同类型的图以不同类型的基础几何图形组成。 - 条形图使用条形 geom_bar() - 折线图使用线geom_line() - 箱线图使用箱型 geom_boxplot() - 散点图使用点geom_point()\n注意geom函数与ggplot函数是并列的，二者以加号相连。不妨尝试画一个散点图：\nggplot(\n  data = penguins,\n  mapping = aes(x = flipper_length_mm, y = body_mass_g)\n) +\n  geom_point()\n#&gt; Warning: Removed 2 rows containing missing values or values outside the scale range\n#&gt; (`geom_point()`).\n\n我们注意到生成图像时有警告信息，是因为数据中有两只企鹅缺少体重或脚蹼长度值，ggplot2 无法在图上表示缺失值。ggplot2 贯彻不让任何缺失值静默地缺失这一理念。\n接下来，我们需要将物种这一变量纳入图中，可以通过使用不同颜色的点来表示不同物种。使用color=&lt;变量&gt;参数即可实现。绘制完成后可以发现ggplot2帮我们附上了一个图例。\nggplot(\n  data = penguins,\n  mapping = aes(x = flipper_length_mm, y = body_mass_g, color = species)\n) +\n  geom_point()\n\n为了让图像更直观，最好再添加一个图层，以显示体重和脚蹼长度之间关系的平滑曲线，用geom_smooth()函数表示。由于平滑曲线是一个新的几何对象，与散点图并存，故而函数geom_smooth(method = \"lm\")也应独立，用加号连接。其中lm表示线性模型(linear model)。\nggplot(\n  data = penguins,\n  mapping = aes(x = flipper_length_mm, y = body_mass_g, color = species)\n) +\n  geom_point() +\n  geom_smooth(method = \"lm\")\n\n此代码输出的图包含三条线，分别表示三个物种，看起来颇为凌乱。如果曲线的对象是整个数据，就能做到只输出一条总线，那么如何设置？\n实际上，ggplot函数里的参数是影响所有geom的，而各个geom函数里的参数则各自为营而互不干扰。因此可让颜色只在散点图中作为物种区分，从而不影响平滑曲线：\nggplot(\n  data = penguins,\n  mapping = aes(x = flipper_length_mm, y = body_mass_g)\n) +\n  geom_point(mapping = aes(color = species)) +\n  geom_smooth(method = \"lm\")\n\n现在得到的图像美观多了，但仍有进步空间。考虑到色盲人士，只用颜色区分物种貌似不太妥当，可以将点改为多种形状来区分。使用shape=&lt;变量&gt;参数即可实现。同样也会附上图例。\nggplot(\n  data = penguins,\n  mapping = aes(x = flipper_length_mm, y = body_mass_g)\n) +\n  geom_point(mapping = aes(color = species, shape = species)) +\n  geom_smooth(method = \"lm\")\n\n最后一步，我们可以添加一个用于解释图像的函数labs()，从而为图添加标题和副标题，并以与美学映射匹配的方式添加坐标轴文字，并定义图例的标签等等。此外，还可以使用 ggthemes 包中的函数改进调色板，进一步照顾色盲人士。\n&gt; ggplot(\n+     data = penguins,\n+     mapping = aes(x = flipper_length_mm, y = body_mass_g)\n+ ) +\n+     geom_point(aes(color = species, shape = species)) +\n+     geom_smooth(method = \"lm\") +\n+     labs(\n+         title = \"Body mass and flipper length\",\n+         subtitle = \"Dimensions for Adelie, Chinstrap, and Gentoo Penguins\",\n+         x = \"Flipper length (mm)\", y = \"Body mass (g)\",\n+         color = \"Species\", shape = \"Species\"\n+     ) +\n+     scale_color_colorblind()",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>数据可视化</span>"
    ]
  },
  {
    "objectID": "chapters/ch1_data_visualization.html#调用-ggplot2",
    "href": "chapters/ch1_data_visualization.html#调用-ggplot2",
    "title": "2  数据可视化",
    "section": "2.3 调用 ggplot2",
    "text": "2.3 调用 ggplot2\nggplot函数的核心用法已阐述完毕，下面将以更简洁的形式呈现，省略参数名称（data和mapping）。所以上一节中的某一命令可简化为：\nggplot(\n  data = penguins,\n  mapping = aes(x = flipper_length_mm, y = body_mass_g)\n) +\n  geom_point()\n当然也可以借助R的管道进行简化：\npenguins |&gt; \n  ggplot(aes(x = flipper_length_mm, y = body_mass_g)) + \n  geom_point()",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>数据可视化</span>"
    ]
  },
  {
    "objectID": "chapters/ch1_data_visualization.html#分布可视化",
    "href": "chapters/ch1_data_visualization.html#分布可视化",
    "title": "2  数据可视化",
    "section": "2.4 分布可视化",
    "text": "2.4 分布可视化\n如果要将企鹅的种类等类别变量(categorical variable)可视化，可使用条形图geom_bar()如下：\nggplot(penguins, aes(x = species)) +\n  geom_bar()\n\n如此便可生成对应条形图，但是排列是无序的。借助fct_infreq()函数按照每个类别的数量进行降序排序：\nggplot(penguins, aes(x = fct_infreq(species))) +\n  geom_bar()\n\n如果要对企鹅的体重等数值变量(numerical variable)进行可视化，可使用直方图geom_histogram()：\nggplot(penguins, aes(x = body_mass_g)) +\n  geom_histogram(binwidth = 200)\n\n指令中的 binwidth 参数设置直方图中的间隔宽度。在应用直方图时，需要尝试多种 binwidth参数，以找到最顺眼且最合理的样式。比如设置为20时显然过于密集了：\n\n数值分布还可以用密度图geom_density()进行可视化，相当于连接直方图各个长条的顶点绘制的曲线：\nggplot(penguins, aes(x = body_mass_g)) +\n  geom_density()\n#&gt; Warning: Removed 2 rows containing non-finite outside the scale range\n#&gt; (`stat_density()`).",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>数据可视化</span>"
    ]
  },
  {
    "objectID": "chapters/ch1_data_visualization.html#关系可视化",
    "href": "chapters/ch1_data_visualization.html#关系可视化",
    "title": "2  数据可视化",
    "section": "2.5 关系可视化",
    "text": "2.5 关系可视化\n为了可视化变量间的关系，我们需要将至少两个变量映射到美学。下面将介绍用于可视化两个或多个变量之间关系的常用绘图。\n\n2.5.1 数值变量和类别变量\n要对数值变量和类别变量进行关系可视化，可使用箱线图geom_boxplot()。\n箱线图由以下部分组成：\n\n一个表示数据中间半部分范围的框，该距离称为四分位距 （IQR），从分布的第 25 个百分位数延伸到第 75 个百分位数。框中间有一条横线，显示分布的中位数，即第 50 个百分位数。这三条线体现数据的分散程度，以及分布是关于中位数对称还是偏向于某一侧。\n超过框的任一边缘 IQR 1.5 倍的观测值的数据会以点的形式单独标注，称为outliers。\n从框的两端延伸并到达最远的非异常值点的线称作须线(whisker)。\n\n\n现在使用箱线图将企鹅体重与物种的关系可视化：\nggplot(penguins, aes(x = species, y = body_mass_g)) +\n  geom_boxplot()\n\n关系的可视化也可以使用密度图，不过较前文有所进阶。使用linewidth参数自定义线条粗细：\n&gt; ggplot(penguins, aes(x = body_mass_g, color = species)) +\n+ geom_density(linewidth = 0.75)\n\n可以用fill参数为密度曲线填充颜色，同时使用alpha参数设置填充的透明度：\nggplot(penguins, aes(x = body_mass_g, color = species, fill = species)) +\n  geom_density(alpha = 0.5)\n\n\n\n2.5.2 两个类别变量\n使用堆叠条形图来可视化两个类别变量的关系。例如要处理物种和岛名的关系：\nggplot(penguins, aes(x = island, fill = species)) +\n  geom_bar()\n\n像这样直接生成的条形图反映了绝对数值，但是对于各岛企鹅物种占比的对比不太直观。此时可设置参数position=\"fill\"的方式让相对频率更直观：\nggplot(penguins, aes(x = island, fill = species)) +\n  geom_bar(position = \"fill\")\n\n\n\n2.5.3 两个数值变量\n书中指出，散点图是可视化两个数值变量之间关系的最常用图。\nggplot(penguins, aes(x = flipper_length_mm, y = body_mass_g)) +\n  geom_point()\n\n\n\n2.5.4 三个或更多变量\n针对三个变量，我们可以加入更多美学要素以表示变量，比如用点的颜色表示物种，用点的形状表示岛屿：\nggplot(penguins, aes(x = flipper_length_mm, y = body_mass_g)) +\n  geom_point(aes(color = species, shape = island))\n\n但是这样做的缺陷非常明显，图片十分杂乱，若变量更多则更糟糕。故而有另一种方案：分面。即使用多个子图以表示类别变量。\n要进行分面，则使用facet_wrap()函数，参数为符号~后加上需要分面的类别变量名称。例如将岛屿进行分面：\nggplot(penguins, aes(x = flipper_length_mm, y = body_mass_g)) +\n  geom_point(aes(color = species, shape = species)) +\n  facet_wrap(~island)",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>数据可视化</span>"
    ]
  },
  {
    "objectID": "chapters/ch1_data_visualization.html#保存绘图",
    "href": "chapters/ch1_data_visualization.html#保存绘图",
    "title": "2  数据可视化",
    "section": "2.6 保存绘图",
    "text": "2.6 保存绘图\n使用ggsave()函数保存最近一次所画图像，参数file可设置图像名称及路径。比如：\nggplot(penguins, aes(x = flipper_length_mm, y = body_mass_g)) +\n  geom_point()\nggsave(filename = \"penguin-plot.png\")",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>数据可视化</span>"
    ]
  },
  {
    "objectID": "chapters/ch2_workflow_basics.html",
    "href": "chapters/ch2_workflow_basics.html",
    "title": "3  工作流基础",
    "section": "",
    "text": "3.1 代码基础\n在进一步学习本书前，必须确保具备运行 R 代码的基础能力，并且掌握RStudio中的核心功能。\n数学计算：\n创建新对象：\n创建向量：\n向量的基本算术会应用于其中每个元素：\n创建对象所用的赋值语句都是object &lt;- value格式。R中有一个常用快捷键Alt+-，用于迅速打出&lt;-符号，且前后各自带一个空格。",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>工作流基础</span>"
    ]
  },
  {
    "objectID": "chapters/ch2_workflow_basics.html#代码基础",
    "href": "chapters/ch2_workflow_basics.html#代码基础",
    "title": "3  工作流基础",
    "section": "",
    "text": "&gt; 1 / 200 * 30\n[1] 0.15\n\n&gt; (59 + 73 + 2) / 3\n[1] 44.66667\n\n&gt; sin(pi / 2)\n[1] 1\n\n&gt; x &lt;- 5\n\n&gt; primes &lt;- c(2, 3, 5, 7, 11, 13)\n\n&gt; primes * 2\n[1]  4  6 10 14 22 26",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>工作流基础</span>"
    ]
  },
  {
    "objectID": "chapters/ch2_workflow_basics.html#注释",
    "href": "chapters/ch2_workflow_basics.html#注释",
    "title": "3  工作流基础",
    "section": "3.2 注释",
    "text": "3.2 注释\n#符号后接的内容表示注释，R将忽略该内容。在编写的代码趋于复杂时，务必养成加上注释的习惯，可为日后弄清代码含义节省大量时间。",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>工作流基础</span>"
    ]
  },
  {
    "objectID": "chapters/ch2_workflow_basics.html#对象的名称",
    "href": "chapters/ch2_workflow_basics.html#对象的名称",
    "title": "3  工作流基础",
    "section": "3.3 对象的名称",
    "text": "3.3 对象的名称\n一般来说，对象名称有三种命名方式。\n\n蛇型（单词间用下划线连接，如how_to_name）\n驼峰型（单词首字母大写，如HowToName）\n点分隔型（如how.to.name）\n\n将对象命名后，要再次调用则不用将名称全部输入。输入前几个字母后，按Tab键可以快捷选择对应前缀的对象；或者使用Ctrl+↑快捷键选择过去输入的指令。\nRStudio右上角的environment会显示当前已命名的对象。",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>工作流基础</span>"
    ]
  },
  {
    "objectID": "chapters/ch2_workflow_basics.html#调用函数",
    "href": "chapters/ch2_workflow_basics.html#调用函数",
    "title": "3  工作流基础",
    "section": "3.4 调用函数",
    "text": "3.4 调用函数\nR中调用函数的方式为f_name(arg1 = val1, arg2 = val2, ...)。\n例如使用seq()函数生成规则的数值序列。\n&gt; seq(1,5)\n[1] 1 2 3 4 5\nRStudio有一个很贴心的辅助功能，当输入一个上引号或左括号时能自动生成另一半，防止出错。",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>工作流基础</span>"
    ]
  },
  {
    "objectID": "chapters/ch3_data_transformation.html",
    "href": "chapters/ch3_data_transformation.html",
    "title": "4  数据处理",
    "section": "",
    "text": "4.1 引言\n可视化是数据分析时的重要手段，但前提是数据格式严格符合要求。因此针对格式不当的数据需要进行一些处理。\n本章主要介绍使用dplyr包对数据进行处理，dplyr同样归属于tidyverse。另外为了举例，还需加载含有纽约航班信息的包：\nnycflights13包中包含 2013 年从纽约市出发的所有 336,776 个航班，记录在nycflights13::flights里：\nflights表格是一个 “Tibble”，这是一种特殊的数据框。Tibble 和普通数据框之间最重要的区别是其显示方式，tibble专为大型数据集而设计，因此它们仅显示前几行，并且仅显示适配屏幕大小的列。如果使用 RStudio操作则更方便，会打开一个可交互、可滚动、可筛选的视图。\n注意到表头下方用尖括号标注了数据类型，大致有：\n本章将学习5个dplyr核心函数，用于数据处理，大致为：\n上述5个函数的工作方式大致相同，有以下共通点：\n下面对其一一阐述。",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>数据处理</span>"
    ]
  },
  {
    "objectID": "chapters/ch3_data_transformation.html#引言",
    "href": "chapters/ch3_data_transformation.html#引言",
    "title": "4  数据处理",
    "section": "",
    "text": "&gt; library(nycflights13)\n&gt; library(tidyverse)\n\nflights\n#&gt; # A tibble: 336,776 × 19\n#&gt;    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n#&gt; 1  2013     1     1      517            515         2      830            819\n#&gt; 2  2013     1     1      533            529         4      850            830\n#&gt; 3  2013     1     1      542            540         2      923            850\n#&gt; 4  2013     1     1      544            545        -1     1004           1022\n#&gt; 5  2013     1     1      554            600        -6      812            837\n#&gt; 6  2013     1     1      554            558        -4      740            728\n#&gt; # ℹ 336,770 more rows\n#&gt; # ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, …\n\n\n\nint 表示整数型变量。\ndbl表示双精度浮点数型变量，或称实数。\nchr 表示字符向量，或称字符串。\nlgl表示逻辑型变量，是一个仅包括 TRUE 和 FALSE 的向量。\nfctr 表示因子，R用其来表示具有固定数目的值的分类变量。\ndate 表示日期型变量。\ndttm 表示日期时间(日期+时间)型变量。\n\n\n\n按值筛选(filter())。\n对行进行重新排序(arrange())\n按名称选取变量(select())\n使用现有变量的函数创建新变量(mutate())\n将多个值总结为一个摘要统计量(summarize())\n\n\n\n第一个参数是数据框。\n后续参数使用不带引号的变量名称，描述针对数据框进行的操作。\n输出结果是一个新数据框。",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>数据处理</span>"
    ]
  },
  {
    "objectID": "chapters/ch3_data_transformation.html#行",
    "href": "chapters/ch3_data_transformation.html#行",
    "title": "4  数据处理",
    "section": "4.2 行",
    "text": "4.2 行\n操作数据行的最主要函数为：\n\nfilter()：用于筛选数据。改变的是行的种类，但不改变顺序；\narrange()：用于排序。改变的是行的顺序，但不改变行的内容。\n\n这两个函数仅作用于行，不会修改列。\n此外，还有 distinct() 函数，用于查找具有唯一值的行。与 arrange() 和 filter() 不同，distinct() 在筛选行的同时也可以选择性地修改列。\n\n4.2.1 filter()\nfilter() 函数用于根据列中的值保留数据框中的某些行。第一个参数是数据框，后续的参数是判断各行是否保留的条件。例如，以下代码能找出所有起飞延误超过 120 分钟的航班：\nflights |&gt; \n  filter(dep_delay &gt; 120)\n除了 &gt;（大于）之外，还可以使用以下比较运算符：\n\n&gt;=（大于等于）\n&lt;（小于）\n&lt;=（小于等于）\n==（等于）\n!=（不等于）\n\n还可以使用 & 或 , 表示“与”（同时满足多个条件），使用 | 表示“或”（满足任一条件）。例如要筛选出所有在1月1日起飞的航班：\nflights |&gt; \n  filter(month == 1 & day == 1)\n结合 | 与 == 时，有一个简洁的写法：%in%，用于匹配某个变量是否属于一组值之一。比如筛选1月或2月的航班：\nflights |&gt; \n  filter(month %in% c(1, 2))\n在运行 filter() 时，dplyr 会返回一个新的数据框，而不会修改原始的 flights 数据集。要保存筛选结果，使用赋值操作符 &lt;-：\njan1 &lt;- flights |&gt; \n  filter(month == 1 & day == 1)\n初学者常犯以下两点错误\n\n用 = 判断相等，而非 ==。此时 filter() 会报错提醒：\n\nflights |&gt; \n  filter(month = 1)\n#&gt; Error in `filter()`:\n#&gt; ! We detected a named input.\n#&gt; ℹ This usually means that you've used `=` instead of `==`.\n#&gt; ℹ Did you mean `month == 1`?\n\n像口语一样写“或”条件：\n\nflights |&gt; \n  filter(month == 1 | 2)\n正确写法是 month == 1 | month == 2。\n\n\n4.2.2 arrange()\narrange() 根据某些列的值对行进行排序。它接收数据框及一组列名或表达式。如果提供多个列名，则后面的列用于在前面的列值相同时进一步排序。\n例如，下面的代码按年、月、日和起飞时间排序，得到的是最早起飞的航班排在前面：\nflights |&gt; \n  arrange(year, month, day, dep_time)\n若希望按某列的降序排列，可以用 desc()：\n# 按照起飞延误时间从大到小排序\nflights |&gt; \n  arrange(desc(dep_delay))\n\n\n4.2.3 distinct()\ndistinct() 查找数据框中所有唯一（去重）行。在实际使用中，更常用于获取某些列组合的唯一值，且会保留每组中第一次出现的那一行。\n# 删除重复行\nflights |&gt; \n  distinct()\n# 获取所有起点和终点的组合\nflights |&gt; \n  distinct(origin, dest)\n如需保留其他列信息，可添加 .keep_all = TRUE参数。\n若希望获取各组合的出现次数，使用 count() 更为合适，并可通过 sort = TRUE 参数按频数降序排列：\nflights |&gt;\n  count(origin, dest, sort = TRUE)",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>数据处理</span>"
    ]
  },
  {
    "objectID": "chapters/ch3_data_transformation.html#列操作",
    "href": "chapters/ch3_data_transformation.html#列操作",
    "title": "4  数据处理",
    "section": "4.3 列操作",
    "text": "4.3 列操作\n在数据处理过程中，有四个 dplyr 中的重要函数可用于操作列而不改变行的结构：\n\nmutate()：基于现有列创建新列。\nselect()：筛选保留指定列。\nrename()：重命名列。\nrelocate()：重新排列列的位置。\n\n\n4.3.1 mutate()\nmutate() 用于在数据框中添加新列，这些新列的值是通过现有列计算得出的。例如：\nflights |&gt; \n  mutate(\n    gain = dep_delay - arr_delay,\n    speed = distance / air_time * 60\n  )\n此代码添加了两个新列 gain（“起飞延误”减去“到达延误”）和 speed（飞行速度，单位：mph）。默认情况下，新列会添加在数据框的最右侧。为了便于观察，可以使用 .before 参数控制其插入的位置：\nflights |&gt; \n  mutate(\n    gain = dep_delay - arr_delay,\n    speed = distance / air_time * 60,\n    .before = 1\n  )\n#&gt; # A tibble: 336,776 × 21\n#&gt;    gain speed  year month   day dep_time sched_dep_time dep_delay arr_time\n#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;\n#&gt; 1    -9  370.  2013     1     1      517            515         2      830\n#&gt; 2   -16  374.  2013     1     1      533            529         4      850\n#&gt; 3   -31  408.  2013     1     1      542            540         2      923\n#&gt; 4    17  517.  2013     1     1      544            545        -1     1004\n#&gt; 5    19  394.  2013     1     1      554            600        -6      812\n#&gt; 6   -16  288.  2013     1     1      554            558        -4      740\n#&gt; # ℹ 336,770 more rows\n#&gt; # ℹ 12 more variables: sched_arr_time &lt;int&gt;, arr_delay &lt;dbl&gt;, …\n此外，.after 可用于将新列插入某一指定列之后。.keep 参数可控制哪些列被保留。例如仅保留参与 mutate() 计算的列：\nflights |&gt; \n  mutate(\n    gain = dep_delay - arr_delay,\n    hours = air_time / 60,\n    gain_per_hour = gain / hours,\n    .keep = \"used\"\n  )\n\n注意：若未将结果赋值回对象（如 flights 或新对象），新生成的变量仅在当前操作中可见，不会永久保存。\n\n\n\n\n4.3.2 select()\n在处理包含大量变量的数据集时，select() 可用于快速提取需要研究的列。常见用法包括：\n# 指定列名\nselect(year, month, day)\n\n# 选择连续区间\nselect(year:day)\n\n# 排除某一列区间\nselect(!year:day)\n\n# 选择字符型列\nselect(where(is.character))\n还可使用辅助函数进行模式匹配：\n\nstarts_with(\"abc\")：匹配以 abc 开头的列名。\nends_with(\"xyz\")：匹配以 xyz 结尾的列名。\ncontains(\"ijk\")：包含 ijk 的列名。\nnum_range(\"x\", 1:3)：匹配 x1, x2, x3。\n\n此外，也可在 select() 中重命名列，但是只保留被选择的列，未被选中的列会被移除。\nflights |&gt; \n  select(tail_num = tailnum)\n\n\n4.3.3 rename()\n若只想重命名部分列而保留所有现有列，可使用 rename()：\nflights |&gt; \n  rename(tail_num = tailnum)\n相比 select()，rename() 不会改变列的数量，仅修改名称。\n若存在大量命名不规范的列名，可考虑使用 janitor::clean_names() 进行批量清洗。\n\n4.3.3.1 relocate()\nrelocate() 用于调整列的顺序，可以将某些更关键的列移动到前面：\nflights |&gt; \n  relocate(time_hour, air_time)\n#&gt; # A tibble: 336,776 × 19\n#&gt;   time_hour           air_time  year month   day dep_time sched_dep_time\n#&gt;   &lt;dttm&gt;                 &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;\n#&gt; 1 2013-01-01 05:00:00      227  2013     1     1      517            515\n#&gt; 2 2013-01-01 05:00:00      227  2013     1     1      533            529\n#&gt; 3 2013-01-01 05:00:00      160  2013     1     1      542            540\n#&gt; 4 2013-01-01 05:00:00      183  2013     1     1      544            545\n#&gt; 5 2013-01-01 06:00:00      116  2013     1     1      554            600\n#&gt; 6 2013-01-01 05:00:00      150  2013     1     1      554            558\n#&gt; # ℹ 336,770 more rows\n#&gt; # ℹ 12 more variables: dep_delay &lt;dbl&gt;, arr_time &lt;int&gt;, …\n.before 或 .after 精确定位：\nflights |&gt; \n  relocate(year:dep_time, .after = time_hour)\nflights |&gt; \n  relocate(starts_with(\"arr\"), .before = dep_time)",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>数据处理</span>"
    ]
  },
  {
    "objectID": "chapters/ch3_data_transformation.html#管道符",
    "href": "chapters/ch3_data_transformation.html#管道符",
    "title": "4  数据处理",
    "section": "4.4 管道符",
    "text": "4.4 管道符\n管道符提升代码的可读性、简洁性和逻辑性，避免嵌套调用。\n\n4.4.1 Base R 管道操作符 |&gt;\n自 R 4.1.0 起，R 语言原生支持管道符 |&gt;。其核心原理是“把前一步的结果作为后一个函数的第一个参数”。\n举例，找出飞往 IAH 的航班中速度最快的几架飞机：\nflights |&gt;\n  filter(dest == \"IAH\") |&gt;\n  mutate(speed = distance / air_time * 60) |&gt;\n  select(year:day, dep_time, carrier, flight, speed) |&gt;\n  arrange(desc(speed))\n等价于嵌套写法：\narrange(\n  select(\n    mutate(\n      filter(flights, dest == \"IAH\"),\n      speed = distance / air_time * 60\n    ),\n    year:day, dep_time, carrier, flight, speed\n  ),\n  desc(speed)\n)\n\n\n4.4.2 |&gt; 与 %&gt;% 的区别\n|&gt; 是 base R 提供的原生操作符，不依赖任何包。\n%&gt;% 来源于 magrittr 包（tidyverse 的一部分），功能更强。比如可使用.占位符传递非首参数。\n不过，如果只在 dplyr 和 ggplot2 语境下处理数据，|&gt; 通常已足够。",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>数据处理</span>"
    ]
  },
  {
    "objectID": "chapters/ch3_data_transformation.html#分组操作与汇总",
    "href": "chapters/ch3_data_transformation.html#分组操作与汇总",
    "title": "4  数据处理",
    "section": "4.5 分组操作与汇总",
    "text": "4.5 分组操作与汇总\n管道操作仅简化流程，但对某些任务，如“对每个月统计平均延误时间”，则需要借助分组与汇总函数。\n\n4.5.1 group_by()\n示例：按月份分组\nflights |&gt;\n  group_by(month)\n此时返回的 tibble 看似不变，但其实多了一个“分组结构”属性，后续函数如 summarize() 将以此分组为单位运算。\n\n\n4.5.2 summarize()\n用于计算每组的统计量，如平均数、个数、最大值等。\nflights |&gt;\n  group_by(month) |&gt;\n  summarize(\n    avg_delay = mean(dep_delay, na.rm = TRUE),\n    flight_count = n()\n  )\n\n\nna.rm = TRUE 用于忽略缺失值；\nn() 返回当前分组的行数（即航班数）；\n默认情况下 summarize() 会“剥离”最后一个分组变量。\n\n\n\n\n4.5.3 多重分组与 .groups 参数\n可同时按多个变量分组：\nflights |&gt;\n  group_by(year, month, day) |&gt;\n  summarize(avg_delay = mean(dep_delay, na.rm = TRUE))\n可通过 .groups 参数明确控制输出是否保留某层分组：\nsummarize(..., .groups = \"drop_last\")  # 保留上层分组\nsummarize(..., .groups = \"drop\")       # 全部取消分组\nsummarize(..., .groups = \"keep\")       # 保留所有分组\n\n\n4.5.4 ungroup()移除分组结构\n若后续不再需分组操作，需要使用 ungroup() 函数进行声明，避免出现意外。\ndaily_summary |&gt;\n  ungroup() |&gt;\n  summarize(total_flights = sum(n))\n\n\n4.5.5 slice_*() 系列函数：获取组内特定行\nslice_*() 系列函数常用于提取组内最值、样本等，结果保留原始列结构。\n\nslice_head(n = 1)：每组取最前一行\nslice_tail(n = 1)：每组取最后一行\nslice_max(order_by, n = 1)：每组取最大值\nslice_min(order_by, n = 1)：每组取最小值\nslice_sample(n = 1)：每组随机取一行\n\n例如，找出每个目的地到达延误最长的航班：\nflights |&gt;\n  group_by(dest) |&gt;\n  slice_max(arr_delay, n = 1) |&gt;\n  relocate(dest)\n默认行为中，若多个航班并列最大延误，则全部保留。若需限制为仅一行，可加 with_ties = FALSE。\n\n\n4.5.6 .by 参数\ndplyr 1.1.0 引入 .by 参数，提供了一种更简洁、局部化的分组操作语法。与传统 group_by() 不同，.by 仅在当前动词范围内生效，不影响后续操作的分组状态，适合一次性分组计算。\n基本用法如下例所示：\nflights |&gt; \n  summarize(\n    delay = mean(dep_delay, na.rm = TRUE), \n    n = n(),\n    .by = month\n  )\n可支持多变量分组：\nflights |&gt; \n  summarize(\n    delay = mean(dep_delay, na.rm = TRUE), \n    n = n(),\n    .by = c(origin, dest)\n  )\n.by参数特性总结如下：\n\n作用范围限于当前动词，运算结束即“自动取消分组”；\n可用于 summarize()、mutate()、filter() 等所有动词；\n避免了 .groups 警告信息，简化结果处理流程；\n写法更贴近函数式风格，便于封装与组合。\n\n以下是两种写法的对比：\n\n传统写法：\n\nflights |&gt; \n  group_by(month) |&gt; \n  summarize(delay = mean(dep_delay, na.rm = TRUE)) |&gt; \n  ungroup()\n\n.by 简化：\n\n``` r flights |&gt; summarize(delay = mean(dep_delay, na.rm = TRUE), .by = month)",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>数据处理</span>"
    ]
  },
  {
    "objectID": "chapters/ch4_workflow_code_style.html",
    "href": "chapters/ch4_workflow_code_style.html",
    "title": "5  工作流之代码格式",
    "section": "",
    "text": "5.1 命名规范\n代码的编写格式往往直接影响代码的可读性和维护性。对于编程新手，建议从一开始就养成规范的书写习惯，这不仅有利于团队协作，也能让自己在回顾旧代码时更加轻松。\n本章整理了 tidyverse 推荐的格式，并作为全书的统一准则。初期遵循规范可能略感繁琐，但通过持续练习，这些规范将逐步内化为自然习惯。\n可借助 styler 包自动格式化代码。\n装载后，在 RStudio 中使用快捷键 Ctrl + Shift + P 打开命令面板，输入 “styler” 即可快速查看 styler 提供的所有快捷方式。\n命名变量建议使用小写字母、数字与下划线 _，下划线用于分隔单词：\n变量名应具备描述性，长不是问题，总比晦涩的缩写更易理解。在命名一组相关变量时，推荐使用统一前缀而非后缀，以提升自动补全功能的效率：",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>工作流之代码格式</span>"
    ]
  },
  {
    "objectID": "chapters/ch4_workflow_code_style.html#命名规范",
    "href": "chapters/ch4_workflow_code_style.html#命名规范",
    "title": "5  工作流之代码格式",
    "section": "",
    "text": "# 推荐\nshort_flights &lt;- flights |&gt; filter(air_time &lt; 60)\n\n# 不推荐\nSHORTFLIGHTS &lt;- flights |&gt; filter(air_time &lt; 60)\n\ndep_time, dep_delay, dep_gate  # 推荐\ntime_dep, delay_dep, gate_dep  # 不推荐",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>工作流之代码格式</span>"
    ]
  },
  {
    "objectID": "chapters/ch4_workflow_code_style.html#空格",
    "href": "chapters/ch4_workflow_code_style.html#空格",
    "title": "5  工作流之代码格式",
    "section": "5.2 空格",
    "text": "5.2 空格\n运算符（如 +, -, == 等）两侧需保留空格，唯独幂运算符 ^ 可不加。赋值符号 &lt;- 左右也应空格分隔：\nz &lt;- (a + b)^2 / d\n函数调用中，括号内不加空格，逗号后需空格：\nmean(x, na.rm = TRUE)\nmutate() 等参数较多的函数，可通过空格对齐等号以提升可读性：\nflights |&gt; \n  mutate(\n    speed      = distance / air_time,\n    dep_hour   = dep_time %/% 100,\n    dep_minute = dep_time %%  100\n  )",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>工作流之代码格式</span>"
    ]
  },
  {
    "objectID": "chapters/ch4_workflow_code_style.html#管道符",
    "href": "chapters/ch4_workflow_code_style.html#管道符",
    "title": "5  工作流之代码格式",
    "section": "5.3 管道符",
    "text": "5.3 管道符\nRStuido中管道符快捷键为 Ctrl + Shift + M。\ntidyverse 推荐使用原生管道 |&gt;，符号前后各留一个空格。管道符通常置于行尾，方便续写。例如：\nflights |&gt;  \n  filter(!is.na(arr_delay), !is.na(tailnum)) |&gt; \n  count(dest)\n若函数（如 summarize()）包含命名参数，每个参数独立成行。而无命名参数（如 filter()）可根据行的长度决定是否换行。\n管道中各层缩进两格。若参数分行书写，则进一步缩进。闭括号 ) 建议单独成行。下方代码格式为例：\nflights |&gt;  \n  group_by(tailnum) |&gt; \n  summarize(\n    delay = mean(arr_delay, na.rm = TRUE),\n    n = n()\n  )\n尽管有些简单操作可一行完成，但建议从一开始就分层书写，为后续扩展留出余地：\n# 简洁但维护性差\ndf |&gt; mutate(y = x + 1)\n\n# 更推荐写法\ndf |&gt; \n  mutate(\n    y = x + 1\n  )\n若管道超过 10–15 行，建议引入中间变量，分阶段处理，尤其是在数据结构发生重大变化时（如 pivot, summarize）。",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>工作流之代码格式</span>"
    ]
  },
  {
    "objectID": "chapters/ch4_workflow_code_style.html#ggplot2-格式规范",
    "href": "chapters/ch4_workflow_code_style.html#ggplot2-格式规范",
    "title": "5  工作流之代码格式",
    "section": "5.4 ggplot2 格式规范",
    "text": "5.4 ggplot2 格式规范\nggplot2 中的图层添加使用 +，应置于行尾，格式上与管道 |&gt; 保持一致：\nflights |&gt; \n  group_by(month) |&gt; \n  summarize(delay = mean(arr_delay, na.rm = TRUE)) |&gt; \n  ggplot(aes(x = month, y = delay)) +\n  geom_point() +\n  geom_line()\n参数较多时建议换行并对齐，提升可读性：\nflights |&gt; \n  group_by(dest) |&gt; \n  summarize(\n    distance = mean(distance),\n    speed = mean(distance / air_time, na.rm = TRUE)\n  ) |&gt; \n  ggplot(aes(x = distance, y = speed)) +\n  geom_smooth(\n    method = \"loess\",\n    span = 0.5,\n    se = FALSE, \n    color = \"white\", \n    linewidth = 4\n  ) +\n  geom_point()\n需注意，+ 与 |&gt; 的格式有时无法完全统一，因为 ggplot2 比管道符出现得更早，故尚难以在设计上兼容。",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>工作流之代码格式</span>"
    ]
  },
  {
    "objectID": "chapters/ch4_workflow_code_style.html#分节注释",
    "href": "chapters/ch4_workflow_code_style.html#分节注释",
    "title": "5  工作流之代码格式",
    "section": "5.5 分节注释",
    "text": "5.5 分节注释\n在脚本较长时，可用注释划分逻辑区域，例如：\n# Load data --------------------------------------\n\n# Plot data --------------------------------------\nRStudio 支持导航栏跳转：使用 Ctrl + Shift + R 插入分节注释，并快速定位不同部分。",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>工作流之代码格式</span>"
    ]
  },
  {
    "objectID": "chapters/ch4_workflow_code_style.html#练手",
    "href": "chapters/ch4_workflow_code_style.html#练手",
    "title": "5  工作流之代码格式",
    "section": "5.6 练手",
    "text": "5.6 练手\n示例一：\n原始代码：\nflights|&gt;filter(dest==\"IAH\")|&gt;group_by(year,month,day)|&gt;summarize(n=n(),\ndelay=mean(arr_delay,na.rm=TRUE))|&gt;filter(n&gt;10)\n规范格式：\nflights |&gt; \n  filter(dest == \"IAH\") |&gt; \n  group_by(year, month, day) |&gt; \n  summarize(\n    n = n(),\n    delay = mean(arr_delay, na.rm = TRUE)\n  ) |&gt; \n  filter(n &gt; 10)\n示例二：\n原始代码：\nflights|&gt;filter(carrier==\"UA\",dest%in%c(\"IAH\",\"HOU\"),sched_dep_time&gt;\n0900,sched_arr_time&lt;2000)|&gt;group_by(flight)|&gt;summarize(delay=mean(\narr_delay,na.rm=TRUE),cancelled=sum(is.na(arr_delay)),n=n())|&gt;filter(n&gt;10)\n规范格式：\nflights |&gt; \n  filter(\n    carrier == \"UA\",\n    dest %in% c(\"IAH\", \"HOU\"),\n    sched_dep_time &gt;  0900,\n    sched_arr_time &lt; 2000\n  ) |&gt; \n  group_by(flight) |&gt; \n  summarize(\n    delay = mean(arr_delay, na.rm = TRUE),\n    cancelled = sum(is.na(arr_delay)),\n    n = n()\n  ) |&gt; \n  filter(n &gt; 10)",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>工作流之代码格式</span>"
    ]
  },
  {
    "objectID": "chapters/ch5_data_tidying.html",
    "href": "chapters/ch5_data_tidying.html",
    "title": "6  数据整洁化",
    "section": "",
    "text": "6.1 引言\n数据可视化和建模都要求数据处于“整洁”格式（tidy format）。虽然无法控制获取数据的原始结构，但可通过数据整理将其转换为整洁结构。\n本章展示：\ntidyr 是 tidyverse 的核心之一，故我们须先载入tidyverse。",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>数据整洁化</span>"
    ]
  },
  {
    "objectID": "chapters/ch5_data_tidying.html#引言",
    "href": "chapters/ch5_data_tidying.html#引言",
    "title": "6  数据整洁化",
    "section": "",
    "text": "整洁数据的定义与原则；\n如何使用 tidyr 包中的函数进行数据整洁化；\n如何识别和处理缺失值。\n\n\nlibrary(tidyverse)",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>数据整洁化</span>"
    ]
  },
  {
    "objectID": "chapters/ch5_data_tidying.html#整洁数据",
    "href": "chapters/ch5_data_tidying.html#整洁数据",
    "title": "6  数据整洁化",
    "section": "6.2 整洁数据",
    "text": "6.2 整洁数据\n整洁数据具有以下三个核心特征：\n\n每个变量成一列；\n每个观测值成一行；\n每个观测单位成一个表。\n\ntable1\n#&gt; # A tibble: 6 × 4\n#&gt;   country      year  cases population\n#&gt;   &lt;chr&gt;       &lt;dbl&gt;  &lt;dbl&gt;      &lt;dbl&gt;\n#&gt; 1 Afghanistan  1999    745   19987071\n#&gt; 2 Afghanistan  2000   2666   20595360\n#&gt; 3 Brazil       1999  37737  172006362\n#&gt; 4 Brazil       2000  80488  174504898\n#&gt; 5 China        1999 212258 1272915272\n#&gt; 6 China        2000 213766 1280428583\n在 table1 中，每行表示一个国家在某一年的观测，有 country, year, cases, population 四列，结构清晰，便于进一步处理和可视化。\n可以基于已有变量创建派生变量。例如：\n# 计算每万人中的发病率\ntable1 |&gt;\n  mutate(rate = cases / population * 10000)\n#&gt; # A tibble: 6 × 5\n#&gt;   country      year  cases population  rate\n#&gt;   &lt;chr&gt;       &lt;dbl&gt;  &lt;dbl&gt;      &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1 Afghanistan  1999    745   19987071 0.373\n#&gt; 2 Afghanistan  2000   2666   20595360 1.29 \n#&gt; 3 Brazil       1999  37737  172006362 2.19 \n#&gt; 4 Brazil       2000  80488  174504898 4.61 \n#&gt; 5 China        1999 212258 1272915272 1.67 \n#&gt; 6 China        2000 213766 1280428583 1.67\n\n# 计算每年病例数\ntable1 |&gt; \n  group_by(year) |&gt; \n  summarize(total_cases = sum(cases))\n#&gt; # A tibble: 2 × 2\n#&gt;    year total_cases\n#&gt;   &lt;dbl&gt;       &lt;dbl&gt;\n#&gt; 1  1999      250740\n#&gt; 2  2000      296920\n可视化如下：\n# 可视化\nggplot(table1, aes(x = year, y = cases)) +\n  geom_line(aes(group = country), color = \"grey50\") +\n  geom_point(aes(color = country, shape = country)) +\n  scale_x_continuous(breaks = c(1999, 2000)) # x-axis breaks at 1999 and 2000",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>数据整洁化</span>"
    ]
  },
  {
    "objectID": "chapters/ch5_data_tidying.html#pivot_long",
    "href": "chapters/ch5_data_tidying.html#pivot_long",
    "title": "6  数据整洁化",
    "section": "6.3 pivot_long()",
    "text": "6.3 pivot_long()\n虽然整洁数据貌似很好实现，但现实中的数据往往不符合整洁格式。两个常见原因：\n\n数据为录入/展示方便而设计（如宽格式）\n多数数据制作者未系统学习整洁数据的规范\n\n下面逐一介绍相关问题及解决方法。\n\n6.3.1 错误其一 | 变量作为列名\n下面这个名为 billboard 的数据集记录了 2000 年歌曲的公告牌排名：\nbillboard\n#&gt; # A tibble: 317 × 79\n#&gt;   artist       track               date.entered   wk1   wk2   wk3   wk4   wk5\n#&gt;   &lt;chr&gt;        &lt;chr&gt;               &lt;date&gt;       &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1 2 Pac        Baby Don't Cry (Ke… 2000-02-26      87    82    72    77    87\n#&gt; 2 2Ge+her      The Hardest Part O… 2000-09-02      91    87    92    NA    NA\n#&gt; 3 3 Doors Down Kryptonite          2000-04-08      81    70    68    67    66\n#&gt; 4 3 Doors Down Loser               2000-10-21      76    76    72    69    67\n#&gt; 5 504 Boyz     Wobble Wobble       2000-04-15      57    34    25    17    17\n#&gt; 6 98^0         Give Me Just One N… 2000-08-19      51    39    34    26    26\n#&gt; # ℹ 311 more rows\n#&gt; # ℹ 71 more variables: wk6 &lt;dbl&gt;, wk7 &lt;dbl&gt;, wk8 &lt;dbl&gt;, wk9 &lt;dbl&gt;, …\n表格宽度相当浮夸，因为制表者将不同星期这一变量作为列名，整整列出了76列星期（此处引用的表格仅展示wk1~wk5）。显然，星期数是一个变量，将其作为列名很不合理、很不整洁。\n使用 pivot_longer() 可进行处理，将星期这一变量进行转置：\nbillboard |&gt; \n  pivot_longer(\n    cols = starts_with(\"wk\"), \n    names_to = \"week\", \n    values_to = \"rank\"\n  )\n#&gt; # A tibble: 24,092 × 5\n#&gt;    artist track                   date.entered week   rank\n#&gt;    &lt;chr&gt;  &lt;chr&gt;                   &lt;date&gt;       &lt;chr&gt; &lt;dbl&gt;\n#&gt;  1 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk1      87\n#&gt;  2 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk2      82\n#&gt;  3 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk3      72\n#&gt;  4 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk4      77\n#&gt;  5 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk5      87\n#&gt;  6 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk6      94\n#&gt;  7 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk7      99\n#&gt;  8 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk8      NA\n#&gt;  9 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk9      NA\n#&gt; 10 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk10     NA\n#&gt; # ℹ 24,082 more rows\n参数解释：\n\ncols用于指定需要转置的列。除了starts_with(\"wk\")，也可写成!c(artist, track, date.entered)\nnames_to用于命名新产生的列，此处将该列命名为week\nvalues_to用于命名存储在原各个列下的变量分离后产生的新列，此处将该列命名为 rank\n\n需注意，week和rank都需要加上引号，因为这是正在创建的新变量。\n初步处理完毕，不知道你有没有发现一个问题：如果原表的某个歌曲还未到wk76就已经跌出榜单而观测值为空白，那么转置后岂不是会产生若干只含有NA的行？这显然仍需改进。\n方法很简单，只需在pivot_longer()中加上一个参数：values_drop_na = TRUE，即可删去只含NA的行。\n将转置后表格命名为 billboard_longer 并进行可视化如下图所示：\n\n\n\n6.3.2 pivot_long() 的运作原理\n通过上一节的例子能看到pivot函数的奇妙之处，让人不禁好奇其原理如何。接下来以另一个数据框为例进行展示。\n假设有 3 名患者，id 分别是 A 、 B 和 C，现在对每位患者进行两次血压测量，以此创建 tibble 如下。\ndf &lt;- tribble(\n  ~id,  ~bp1, ~bp2,\n   \"A\",  100,  120,\n   \"B\",  140,  115,\n   \"C\",  120,  125\n)\n\ntribble()函数用于快捷创建tibble。\n\n接下来我们需要将其修整为新的数据框，含有三个变量：id、measurement、value，如下实现：\ndf |&gt; \n  pivot_longer(\n    cols = bp1:bp2,\n    names_to = \"measurement\",\n    values_to = \"value\"\n  )\n#&gt; # A tibble: 6 × 3\n#&gt;   id    measurement value\n#&gt;   &lt;chr&gt; &lt;chr&gt;       &lt;dbl&gt;\n#&gt; 1 A     bp1           100\n#&gt; 2 A     bp2           120\n#&gt; 3 B     bp1           140\n#&gt; 4 B     bp2           115\n#&gt; 5 C     bp1           120\n#&gt; 6 C     bp2           125\n下列组图形象地展现了这一转置过程：\n\n已经是变量的列需要重复，每个转置列重复一次。\n\n\n\n转置列的列名将成为新列中的值。对于原始数据集的每一行，这些值需要重复一次。\n\n\n单元格值也会成为新变量中的值，其名称由values_to定义，且逐行展开。\n\n\n\n6.3.3 错误其二 | 列名包含多个变量\n有时制表者为了图方便，列名可能一次性塞入了若干变量，导致要素过多而很不整洁。下面以一名为 who2 的整理了结核病的数据框为例。\nwho2\n#&gt; # A tibble: 7,240 × 58\n#&gt;   country      year sp_m_014 sp_m_1524 sp_m_2534 sp_m_3544 sp_m_4554\n#&gt;   &lt;chr&gt;       &lt;dbl&gt;    &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;\n#&gt; 1 Afghanistan  1980       NA        NA        NA        NA        NA\n#&gt; 2 Afghanistan  1981       NA        NA        NA        NA        NA\n#&gt; 3 Afghanistan  1982       NA        NA        NA        NA        NA\n#&gt; 4 Afghanistan  1983       NA        NA        NA        NA        NA\n#&gt; 5 Afghanistan  1984       NA        NA        NA        NA        NA\n#&gt; 6 Afghanistan  1985       NA        NA        NA        NA        NA\n#&gt; # ℹ 7,234 more rows\n#&gt; # ℹ 51 more variables: sp_m_5564 &lt;dbl&gt;, sp_m_65 &lt;dbl&gt;, sp_f_014 &lt;dbl&gt;, …\n这里解释一下制表者对第三列及后续列的命名思路：以下划线分为三个部分，第一部分表示诊断方法，第二部分表示性别，第三部分表示年龄范围。比如 sp_m_014 表示诊断方式sp，男性，0~14岁。\n可见若拆分后该表将包含六个变量：国家、年份、诊断方法、性别、年龄范围、患者数。\n下面依然使用pivot_long()函数进行修整：\nwho2 |&gt; \n  pivot_longer(\n    cols = !(country:year),\n    names_to = c(\"diagnosis\", \"gender\", \"age\"), \n    names_sep = \"_\",\n    values_to = \"count\"\n  )\n#&gt; # A tibble: 405,440 × 6\n#&gt;   country      year diagnosis gender age   count\n#&gt;   &lt;chr&gt;       &lt;dbl&gt; &lt;chr&gt;     &lt;chr&gt;  &lt;chr&gt; &lt;dbl&gt;\n#&gt; 1 Afghanistan  1980 sp        m      014      NA\n#&gt; 2 Afghanistan  1980 sp        m      1524     NA\n#&gt; 3 Afghanistan  1980 sp        m      2534     NA\n#&gt; 4 Afghanistan  1980 sp        m      3544     NA\n#&gt; 5 Afghanistan  1980 sp        m      4554     NA\n#&gt; 6 Afghanistan  1980 sp        m      5564     NA\n#&gt; # ℹ 405,434 more rows\n这里有新增参数names_sep，可将对应列以指定方式进行拆分。\n这个例子同时体现了同时命名多个新列的方式，即使用集合c()。\n\n\n6.3.4 错误其三 | 列名同时包含变量的名称与值\n还有更复杂的错误，即变量的名与值相混合。下面以一个名为 household 的记录家庭孩子数与姓名的数据框为例。\nhousehold\n#&gt; # A tibble: 5 × 5\n#&gt;   family dob_child1 dob_child2 name_child1 name_child2\n#&gt;    &lt;int&gt; &lt;date&gt;     &lt;date&gt;     &lt;chr&gt;       &lt;chr&gt;      \n#&gt; 1      1 1998-11-26 2000-01-29 Susan       Jose       \n#&gt; 2      2 1996-06-22 NA         Mark        &lt;NA&gt;       \n#&gt; 3      3 2002-07-11 2004-04-05 Sam         Seth       \n#&gt; 4      4 2004-10-10 2009-08-27 Craig       Khai       \n#&gt; 5      5 2000-12-05 2005-02-28 Parker      Gracie\n可以看出新的挑战是：列名包含两个变量名（dob、name）和另一变量的值（child，值为 1 或 2）。\n为解决这一问题，需要在给参数names_to提供的向量的首位加一个.value，这并不是某一个变量名称，而是表示使用转置列名的第一个组分作为输出中的变量名（既然要有组分之分，故还得加一个names_sep参数）。同时别忘了values_drop_na = TRUE参数，因为一个孩子的家庭会出现 NA行。\nhousehold |&gt; \n  pivot_longer(\n    cols = !family, \n    names_to = c(\".value\", \"child\"), \n    names_sep = \"_\", \n    values_drop_na = TRUE\n  )\n#&gt; # A tibble: 9 × 4\n#&gt;   family child  dob        name \n#&gt;    &lt;int&gt; &lt;chr&gt;  &lt;date&gt;     &lt;chr&gt;\n#&gt; 1      1 child1 1998-11-26 Susan\n#&gt; 2      1 child2 2000-01-29 Jose \n#&gt; 3      2 child1 1996-06-22 Mark \n#&gt; 4      3 child1 2002-07-11 Sam  \n#&gt; 5      3 child2 2004-04-05 Seth \n#&gt; 6      4 child1 2004-10-10 Craig\n#&gt; # ℹ 3 more rows",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>数据整洁化</span>"
    ]
  },
  {
    "objectID": "chapters/ch5_data_tidying.html#pivot_wider",
    "href": "chapters/ch5_data_tidying.html#pivot_wider",
    "title": "6  数据整洁化",
    "section": "6.4 pivot_wider()",
    "text": "6.4 pivot_wider()\n整个 5.3 节均使用pivot_long()函数对表格进行修整，整体变得更长。下面讨论将数据框变宽的修整情形，以包含医疗保险患者体检数据的数据框为例：\ncms_patient_experience\n#&gt; # A tibble: 500 × 5\n#&gt;   org_pac_id org_nm                     measure_cd   measure_title   prf_rate\n#&gt;   &lt;chr&gt;      &lt;chr&gt;                      &lt;chr&gt;        &lt;chr&gt;              &lt;dbl&gt;\n#&gt; 1 0446157747 USC CARE MEDICAL GROUP INC CAHPS_GRP_1  CAHPS for MIPS…       63\n#&gt; 2 0446157747 USC CARE MEDICAL GROUP INC CAHPS_GRP_2  CAHPS for MIPS…       87\n#&gt; 3 0446157747 USC CARE MEDICAL GROUP INC CAHPS_GRP_3  CAHPS for MIPS…       86\n#&gt; 4 0446157747 USC CARE MEDICAL GROUP INC CAHPS_GRP_5  CAHPS for MIPS…       57\n#&gt; 5 0446157747 USC CARE MEDICAL GROUP INC CAHPS_GRP_8  CAHPS for MIPS…       85\n#&gt; 6 0446157747 USC CARE MEDICAL GROUP INC CAHPS_GRP_12 CAHPS for MIPS…       24\n#&gt; # ℹ 494 more rows\n现在研究的重点是组织名称（org_nm），要确保每个组织名称仅有一行。\n此时使用pivot_wider()进行修正如下：\ncms_patient_experience |&gt; \n  pivot_wider(\n    id_cols = starts_with(\"org\"),\n    names_from = measure_cd,\n    values_from = prf_rate\n  )\n#&gt; # A tibble: 95 × 8\n#&gt;   org_pac_id org_nm           CAHPS_GRP_1 CAHPS_GRP_2 CAHPS_GRP_3 CAHPS_GRP_5\n#&gt;   &lt;chr&gt;      &lt;chr&gt;                  &lt;dbl&gt;       &lt;dbl&gt;       &lt;dbl&gt;       &lt;dbl&gt;\n#&gt; 1 0446157747 USC CARE MEDICA…          63          87          86          57\n#&gt; 2 0446162697 ASSOCIATION OF …          59          85          83          63\n#&gt; 3 0547164295 BEAVER MEDICAL …          49          NA          75          44\n#&gt; 4 0749333730 CAPE PHYSICIANS…          67          84          85          65\n#&gt; 5 0840104360 ALLIANCE PHYSIC…          66          87          87          64\n#&gt; 6 0840109864 REX HOSPITAL INC          73          87          84          67\n#&gt; # ℹ 89 more rows\n#&gt; # ℹ 2 more variables: CAHPS_GRP_8 &lt;dbl&gt;, CAHPS_GRP_12 &lt;dbl&gt;\n参数说明：\n\nid_cols表示保留的列的特征，此处仅保留以 org 开头的列，而排除了 measure_title 列\nnames_from表示新列名在原表中所在列的列名\nvalues_from表示新列中包含变量值在原表中所在列的列名\n\n\n6.4.1 pivot_wider() 的运作原理\n为了了解工作原理，再次从一个最简单的数据集开始。假设有两个 id 为 A 和 B 的两名患者，对患者 A 进行了 3 次血压测量，对患者 B 进行了 2 次：\ndf &lt;- tribble(\n  ~id, ~measurement, ~value,\n  \"A\",        \"bp1\",    100,\n  \"B\",        \"bp1\",    140,\n  \"B\",        \"bp2\",    115, \n  \"A\",        \"bp2\",    120,\n  \"A\",        \"bp3\",    105\n)\n下面从 value 列取值，从 measurement 列取列名：\ndf |&gt; \n  pivot_wider(\n    names_from = measurement,\n    values_from = value\n  )\n#&gt; # A tibble: 2 × 4\n#&gt;   id      bp1   bp2   bp3\n#&gt;   &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1 A       100   120   105\n#&gt; 2 B       140   115    NA\n首先，此过程需要弄清楚新的行和列中的内容。新列的名称将是 measurement 中的唯一值，可通过distinct()函数确认：\ndf |&gt; \n  distinct(measurement) |&gt; \n  pull()\n#&gt; [1] \"bp1\" \"bp2\" \"bp3\"\n默认情况下，输出的新行由所有未进入新列名或值的变量决定，这些行称为id_cols。如下：\ndf |&gt; \n  select(-measurement, -value) |&gt; \n  distinct()\n#&gt; # A tibble: 2 × 1\n#&gt;   id   \n#&gt;   &lt;chr&gt;\n#&gt; 1 A    \n#&gt; 2 B\n然后，pivot_wider()将这些结果组合起来，生成一个空数据框：\ndf |&gt; \n  select(-measurement, -value) |&gt; \n  distinct() |&gt; \n  mutate(x = NA, y = NA, z = NA)\n#&gt; # A tibble: 2 × 4\n#&gt;   id    x     y     z    \n#&gt;   &lt;chr&gt; &lt;lgl&gt; &lt;lgl&gt; &lt;lgl&gt;\n#&gt; 1 A     NA    NA    NA   \n#&gt; 2 B     NA    NA    NA\n最后它会使用输入中的数据填充所有NA值。在这种情况下，并非输出中的每个单元格在输入中都有相应的值，因为患者 B 没有第三次血压测量，因此该单元格仍然缺失。",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>数据整洁化</span>"
    ]
  },
  {
    "objectID": "chapters/ch6_workflow_scripts_projects.html",
    "href": "chapters/ch6_workflow_scripts_projects.html",
    "title": "7  脚本与项目",
    "section": "",
    "text": "7.0.0.0.1 6.1.1 运行代码\n本章介绍用于组织代码的两个基本要素：脚本、项目。\n##脚本\n当工作变得更加复杂时，只用控制台运行代码显得力不从心，此时可使用脚本。在 RStudio 中，点击“文件”菜单，选择新建 R 脚本即可出现空白脚本。此时共有四个窗口，如图所示。\n脚本编辑器是构建复杂ggplot图或长管道的最佳位置。\n快捷键如下：\n建议使用library(所需的包)作为脚本开头。这样，如果要共享代码，可以让他人知晓需要安装的软件包。但绝不应包含在共享脚本中加install.packages(\"包\")，不太厚道。",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>脚本与项目</span>"
    ]
  },
  {
    "objectID": "chapters/ch6_workflow_scripts_projects.html#项目",
    "href": "chapters/ch6_workflow_scripts_projects.html#项目",
    "title": "7  脚本与项目",
    "section": "7.1 项目",
    "text": "7.1 项目\n有时我们需要暂时退出 R，稍后再返回分析；有时我们需要将外部数据导入 R，处理后再对外反馈。\n要处理这两种情况，需要认清两个问题：\n\n真理的源头是什么？或者说什么文件能够永久记录我们曾做过的工作？\n我们所做的分析位于何处？\n\n\n7.1.1 真理的源头\n作为初学者，可以依靠当前 R 环境来保留在整个分析过程中创建的所有对象。但是为了更轻松地处理大型项目或与他人协作，真理的源头应该是 R 脚本。\n使用 R 脚本（和数据文件），我们才能重新创建环境。相反，仅使用当前环境，重新创建 R 脚本则要困难得多，要么必须从内存中重新键入大量代码（在此过程中不可避免地会犯错误），要么必须仔细挖掘 R 历史记录。\n为了保证让 R 脚本成为一切事实的根据，强烈建议设置不要在 RStudio 会话之间保留工作区。即做到两点：\n\n取消勾选RData into workspace\n设置Save workspace to .RData on exit:为Never\n\n如下图所示即可：\n\n或许这会带来一些短期的不便，因为现在重新启动 RStudio 时，它将不再记住上次运行的代码，所创建的对象或读取的数据集也将无影无踪。\n但是短期的不便可以省去长期的痛苦，它会迫使我们在代码中专注于所有重要的过程。\n书中在此推荐两个快捷键：\n\n按 Cmd/Ctrl + Shift + 0/F10 重新启动 R。\n按 Cmd/Ctrl + Shift + S 重新运行当前脚本。\n\n\nRStudio 服务器\n如果使用的是 RStudio 服务器，则默认情况下永远不会重新启动 R 会话。当关闭 RStudio 服务器选项卡时，实际上服务器仍会在后台运行。下次返回时，会发现与上次离开的地方一模一样。因此定期重启变得更加重要，这样才便于从头开始。\n\n\n7.1.1.0.1 6.2.2 分析文件位于何处？\nR 的工作目录概念绝不可忽视。这是 R 查找要求它加载的文件的位置，以及它所放置的保存文件的位置。RStudio 在控制台顶部显示当前工作目录：\n\n可以通过运行getwd()命令打印工作目录：\n&gt; getwd()\n[1] \"C:/Users/LENOVO/Desktop/r_packages/BLIT/blit/R\"\n可以从 R 中设置工作目录，但书中不建议这样做：\n&gt; setwd(\"/path/to/my/CoolProject\")\n因为有更好的方法管理工作——RStudio项目。\n\n\n\n7.1.2 RStudio项目\n将项目的所有相关文件（输入数据、R 脚本、分析结果）全部保存在同一个目录中是非常明智的做法， RStudio 也对此提供了内置支持。\n下面实操为例，创建一个阅读本书剩余部分时专用的项目：\n\n随后在脚本编辑器中输入以下命令并保存文件，将其命名为 “diamonds.R”。再创建一个名为 “data” 的新文件夹。最后，运行完整脚本，该脚本会将相关 PNG 和 CSV 文件保存到项目目录中。本书后续会对这些文件进行探索。\nlibrary(tidyverse)\n\nggplot(diamonds, aes(x = carat, y = price)) + \n  geom_hex()\nggsave(\"diamonds.png\")\n\nwrite_csv(diamonds, \"data/diamonds.csv\")\n退出 RStudio，在电脑上找到该项目文件夹，双击.Rproj文件即可重新打开项目。\n\n\n7.1.3 相对和绝对路径\n一旦进入项目，就最好只使用相对路径，而非绝对路径。\n为什么？举例说明：如果一个叫 Dingjia 的人做了个项目，编辑了一个data/diamonds.csv文件，显然使用的是相对路径，而其绝对路径为/Users/Dingjia/Documents/r4ds/data/diamonds。现在协作者 Zhangsan 要在自己的电脑上运行代码，即可正常进行，因为相对路径指向的绝对路径为/Users/Zhangsan/Documents/r4ds/data/diamonds。\n从以上例子可以看出，使用相对路径对于共享协作意义非凡。\n但还有一点要注意，不同操作系统的分隔符存在差异，例如Mac 和 Linux 使用正斜杠（/），Windows 使用反斜杠（\\ ）。在 R 中，反斜杠需要连续键入两个才可被识别，这很繁琐恼人，故建议直接使用正斜杠。",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>脚本与项目</span>"
    ]
  },
  {
    "objectID": "chapters/ch7_data_import.html",
    "href": "chapters/ch7_data_import.html",
    "title": "8  数据导入",
    "section": "",
    "text": "8.1 引言\n本章介绍如何读取纯文本矩形数据文件，如何将数据写入文件，以及如何创建数据框。\n主要学习readr包，同样是tidyverse的组成部分。",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>数据导入</span>"
    ]
  },
  {
    "objectID": "chapters/ch7_data_import.html#引言",
    "href": "chapters/ch7_data_import.html#引言",
    "title": "8  数据导入",
    "section": "",
    "text": "library(tidyverse)",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>数据导入</span>"
    ]
  },
  {
    "objectID": "chapters/ch7_data_import.html#从文件中读取数据",
    "href": "chapters/ch7_data_import.html#从文件中读取数据",
    "title": "8  数据导入",
    "section": "8.2 从文件中读取数据",
    "text": "8.2 从文件中读取数据\n首先重点介绍最常见的矩形数据文件类型 CSV（Comma-Separated Values）。\n下面是一个简单的 CSV 文件。第一行（通常称为标题行）提供列名称，接下的六行提供数据。列之间用逗号分隔。\nStudent ID,Full Name,favourite.food,mealPlan,AGE\n1,Sunil Huffmann,Strawberry yoghurt,Lunch only,4\n2,Barclay Lynn,French fries,Lunch only,5\n3,Jayendra Lyne,N/A,Breakfast and lunch,7\n4,Leon Rossini,Anchovies,Lunch only,\n5,Chidiegwu Dunkel,Pizza,Breakfast and lunch,five\n6,Güvenç Attila,Ice cream,Lunch only,6\n使用read_csv()将文件读取到R中。其第一个参数最重要——文件路径（也可以使用URL）。\nstudents &lt;- read_csv(\"data/students.csv\")\nstudents &lt;- read_csv(\"https://pos.it/r4ds-students-csv\")\n读入数据后，通常需要先对其进行转换，以便在分析时更易使用。带着这一目的，我们再审视一下这个数据表。\nstudents\n#&gt; # A tibble: 6 × 5\n#&gt;   `Student ID` `Full Name`      favourite.food     mealPlan            AGE  \n#&gt;          &lt;dbl&gt; &lt;chr&gt;            &lt;chr&gt;              &lt;chr&gt;               &lt;chr&gt;\n#&gt; 1            1 Sunil Huffmann   Strawberry yoghurt Lunch only          4    \n#&gt; 2            2 Barclay Lynn     French fries       Lunch only          5    \n#&gt; 3            3 Jayendra Lyne    N/A                Breakfast and lunch 7    \n#&gt; 4            4 Leon Rossini     Anchovies          Lunch only          &lt;NA&gt; \n#&gt; 5            5 Chidiegwu Dunkel Pizza              Breakfast and lunch five \n#&gt; 6            6 Güvenç Attila    Ice cream          Lunch only          6\n有两个问题：\n\n默认情况下，read_csv()会将空字符串\"\"识别为 NA，但注意到原表中有个“N/A”，并未在R中显示为NA，可以单独设置将其读取为NA。\nStudent ID和Full Name两个列名有引号，是因为原表中列名包含空格，不合法，除非在读取时用引号标注。\n\n&gt; students &lt;- read_csv(\"data/students.csv\", na = c(\"N/A\", \"\"))\n&gt; students |&gt; \n  rename(\n    student_id = `Student ID`,\n    full_name = `Full Name`\n  )\n&gt; students\n#&gt; # A tibble: 6 × 5\n#&gt;   `Student ID` `Full Name`      favourite.food     mealPlan            AGE  \n#&gt;          &lt;dbl&gt; &lt;chr&gt;            &lt;chr&gt;              &lt;chr&gt;               &lt;chr&gt;\n#&gt; 1            1 Sunil Huffmann   Strawberry yoghurt Lunch only          4    \n#&gt; 2            2 Barclay Lynn     French fries       Lunch only          5    \n#&gt; 3            3 Jayendra Lyne    &lt;NA&gt;               Breakfast and lunch 7    \n#&gt; 4            4 Leon Rossini     Anchovies          Lunch only          &lt;NA&gt; \n#&gt; 5            5 Chidiegwu Dunkel Pizza              Breakfast and lunch five \n#&gt; 6            6 Güvenç Attila    Ice cream          Lunch only          6\n接下来考虑数据类型与数据本身的校正，有两点需要关注。\n\nmeal_plan是一个分类变量，应该在R中表示为因子（fct），而非字符（chr）。\nage列中有一个数据为five而非数字5。\n\nstudents |&gt;\n  janitor::clean_names() |&gt;\n  mutate(\n    meal_plan = factor(meal_plan),\n    age = parse_number(if_else(age == \"five\", \"5\", age))\n  )\n#&gt; # A tibble: 6 × 5\n#&gt;   student_id full_name        favourite_food     meal_plan           age  \n#&gt;        &lt;dbl&gt; &lt;chr&gt;            &lt;chr&gt;              &lt;fct&gt;               &lt;chr&gt;\n#&gt; 1          1 Sunil Huffmann   Strawberry yoghurt Lunch only          4    \n#&gt; 2          2 Barclay Lynn     French fries       Lunch only          5    \n#&gt; 3          3 Jayendra Lyne    &lt;NA&gt;               Breakfast and lunch 7    \n#&gt; 4          4 Leon Rossini     Anchovies          Lunch only          &lt;NA&gt; \n#&gt; 5          5 Chidiegwu Dunkel Pizza              Breakfast and lunch five \n#&gt; 6          6 Güvenç Attila    Ice cream          Lunch only          6\n这样便基本改完了。\n另外read_csv()函数可以快捷生成格式化为 CSV 文件的文本字符串：\nread_csv(\n  \"a,b,c\n  1,2,3\n  4,5,6\"\n)\n#&gt; # A tibble: 2 × 3\n#&gt;       a     b     c\n#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1     1     2     3\n#&gt; 2     4     5     6\n通常，默认使用数据的第一行作为列名。但是，经常能在文件顶部看到有几行元数据，干扰列名的指定。可以使用skip = n跳过前n行，或者使用cmment = #丢弃所有以#开头的行：\nread_csv(\n  \"The first line of metadata\n  The second line of metadata\n  x,y,z\n  1,2,3\",\n  skip = 2\n)\n#&gt; # A tibble: 1 × 3\n#&gt;       x     y     z\n#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1     1     2     3\n\nread_csv(\n  \"# A comment I want to skip\n  x,y,z\n  1,2,3\",\n  comment = \"#\"\n)\n#&gt; # A tibble: 1 × 3\n#&gt;       x     y     z\n#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1     1     2     3\n在某些情况下，数据可能没有列名。可以使用 col_names = FALSE来指出不要将第一行视为标题，而是从X1到Xn按顺序标记它们：\nread_csv(\n  \"1,2,3\n  4,5,6\",\n  col_names = FALSE\n)\n#&gt; # A tibble: 2 × 3\n#&gt;      X1    X2    X3\n#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1     1     2     3\n#&gt; 2     4     5     6\n或者，可以传递一个字符向量给col_names，从而自定义列名：\nread_csv(\n  \"1,2,3\n  4,5,6\",\n  col_names = c(\"x\", \"y\", \"z\")\n)\n#&gt; # A tibble: 2 × 3\n#&gt;       x     y     z\n#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1     1     2     3\n#&gt; 2     4     5     6\n一旦掌握了read_csv()，其他类似函数便迎刃而解。\n\nread_csv2()读取以分号分隔的文件，在用逗号作为较大位数分隔符的国家很常见。\nread_tsv()读取制表符分隔的文件。\nread_delim()读入包含任何分隔符的文件，自动猜测分隔符。\nread_fwf()读取固定宽度的文件。\nread_table()读取固定宽度文件的一种常见变体，其中列由空格分隔。\nread_log()读取 Apache 样式的日志文件。",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>数据导入</span>"
    ]
  },
  {
    "objectID": "chapters/ch7_data_import.html#控制列类型",
    "href": "chapters/ch7_data_import.html#控制列类型",
    "title": "8  数据导入",
    "section": "8.3 控制列类型",
    "text": "8.3 控制列类型\nCSV文件不包含有关变量类型的信息（即它是logical、number、string 等），故readr会自己猜测类型。\n但这难免会存在失误。最常见的原因是列中包含意外值，且一般会误判为chr。如果用NA之外的字符表示缺失值也称为意外值。比如：\n&gt; simple_csv &lt;- \"\n  x\n  10\n  .\n  20\n  30\"\n&gt; read_csv(simple_csv)\n#&gt; # A tibble: 4 × 1\n#&gt;   x    \n#&gt;   &lt;chr&gt;\n#&gt; 1 10   \n#&gt; 2 .    \n#&gt; 3 20   \n#&gt; 4 30\n这个表很短，很快能发现预期外字符的位置，当数据特别长时需要一种特定方法。通过col_types参数自主指定每列的数据类型，然后看readr在哪报错即可。\ndf &lt;- read_csv(\n  simple_csv, \n  col_types = list(x = col_double()) #指定数据列的类型为双精度浮点数\n)\n#&gt; Warning: One or more parsing issues, call `problems()` on your data frame for\n#&gt; details, e.g.:\n#&gt;   dat &lt;- vroom(...)\n#&gt;   problems(dat)\n现在readr指出操作存在问题，并建议我们使用problems()函数进一步确认。\nproblems(df)\n#&gt; # A tibble: 1 × 5\n#&gt;     row   col expected actual file                            \n#&gt;   &lt;int&gt; &lt;int&gt; &lt;chr&gt;    &lt;chr&gt;  &lt;chr&gt;                           \n#&gt; 1     3     1 a double .      /tmp/RtmpqR32wU/file2304111d9453\n第 3 行第 1 列存在问题，其中 readr 期望得到双精度浮点数，但得到的只是一个. 。这表明此数据集使用.表示缺失值。所以设置 na = \".\"即可让所有意外值回到正轨。\nread_csv(simple_csv, na = \".\")\n#&gt; # A tibble: 4 × 1\n#&gt;       x\n#&gt;   &lt;dbl&gt;\n#&gt; 1    10\n#&gt; 2    NA\n#&gt; 3    20\n#&gt; 4    30\n像上面col_double()一样的列类型函数共有九种：\n\ncol_logical()和col_double()读取逻辑量和实数。\ncol_integer()读取整数。\ncol_character()读取字符串。\ncol_factor()、col_date()、col_datetime() 分别创建因子、日期和时间。\ncol_number()是一个数字解析器，它忽略非数字组件，对货币数据特别有用。\ncol_skip()跳过一列，使其不包含在结果中，如果有一个大型 CSV 文件并且只想使用某些列，这对于加快读取数据很有效。\n\n除了用list()进行指定，还有cols()，且用.default参数表示所有列：\nanother_csv &lt;- \"\nx,y,z\n1,2,3\"\n\nread_csv(\n  another_csv, \n  col_types = cols(.default = col_character())\n)\n#&gt; # A tibble: 1 × 3\n#&gt;   x     y     z    \n#&gt;   &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;\n#&gt; 1 1     2     3\n另外还有cols_only()值得一提，它可以只读取我们指定类型的列：\nread_csv(\n  another_csv,\n  col_types = cols_only(x = col_character())\n)\n#&gt; # A tibble: 1 × 1\n#&gt;   x    \n#&gt;   &lt;chr&gt;\n#&gt; 1 1",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>数据导入</span>"
    ]
  },
  {
    "objectID": "chapters/ch7_data_import.html#多个文件读取数据",
    "href": "chapters/ch7_data_import.html#多个文件读取数据",
    "title": "8  数据导入",
    "section": "8.4 多个文件读取数据",
    "text": "8.4 多个文件读取数据\n有时，数据被拆分为多个文件，而不是包含在单个文件中。如下例一次性读取：\nsales_files &lt;- c(\"data/01-sales.csv\", \"data/02-sales.csv\", \"data/03-sales.csv\")\nread_csv(sales_files, id = \"file\")\n#&gt; # A tibble: 19 × 6\n#&gt;   file              month    year brand  item     n\n#&gt;   &lt;chr&gt;             &lt;chr&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1 data/01-sales.csv January  2019     1  1234     3\n#&gt; 2 data/01-sales.csv January  2019     1  8721     9\n#&gt; 3 data/01-sales.csv January  2019     1  1822     2\n#&gt; 4 data/01-sales.csv January  2019     2  3333     1\n#&gt; 5 data/01-sales.csv January  2019     2  2156     9\n#&gt; 6 data/01-sales.csv January  2019     2  3987     6\n#&gt; # ℹ 13 more rows\n注意到id参数为表格添加了一个指定名称的新列，该列用于标识数据来自的源文件。",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>数据导入</span>"
    ]
  },
  {
    "objectID": "chapters/ch7_data_import.html#文件写入",
    "href": "chapters/ch7_data_import.html#文件写入",
    "title": "8  数据导入",
    "section": "8.5 文件写入",
    "text": "8.5 文件写入\n要将CSV等文件保存回磁盘，，使用write_csv()和write_tsv()类型函数。有两个主要参数，一个是数据框，一个是保存的地址。\nwrite_csv(students, \"students.csv\")\n但是这样有个弊端。我们都知道CSV文件不包含列的类型，所以即便我们已经修改过表格，而写入后再读取仍会恢复原样。有两种解决办法保留列类型：\n\n使用write_rds()和read_rds()函数。rds是以R自定义的二进制存储格式，所以我们要重新加载时的R对象与当时存储的是完全相同的。\narrow包中的write_parquet()和read_parquet()函数。这同样是二进制存储格式，且不限于R，可以跨编程语言共享。",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>数据导入</span>"
    ]
  },
  {
    "objectID": "chapters/ch7_data_import.html#数据输入",
    "href": "chapters/ch7_data_import.html#数据输入",
    "title": "8  数据导入",
    "section": "8.6 数据输入",
    "text": "8.6 数据输入\n有时会需要我们自己手搓一个tibble，有两个函数来实现。\n\ntibble()。在输入数据时横向排列。\n\ntibble(\n  x = c(1, 2, 5), \n  y = c(\"h\", \"m\", \"g\"),\n  z = c(0.08, 0.83, 0.60)\n)\n#&gt; # A tibble: 3 × 3\n#&gt;       x y         z\n#&gt;   &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt;\n#&gt; 1     1 h      0.08\n#&gt; 2     2 m      0.83\n#&gt; 3     5 g      0.6\n\ntribble()。在输入数据时纵向排列，更方便排版。注意输入时列标题以~开头。\n\ntribble(\n  ~x, ~y, ~z,\n  1, \"h\", 0.08,\n  2, \"m\", 0.83,\n  5, \"g\", 0.60\n)\n#&gt; # A tibble: 3 × 3\n#&gt;       x y         z\n#&gt;   &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt;\n#&gt; 1     1 h      0.08\n#&gt; 2     2 m      0.83\n#&gt; 3     5 g      0.6\n\ntribble表示：transposed tibble",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>数据导入</span>"
    ]
  },
  {
    "objectID": "chapters/ch8_workflow_getting_help.html",
    "href": "chapters/ch8_workflow_getting_help.html",
    "title": "9  工作流：获取帮助",
    "section": "",
    "text": "9.1 8.1 Google\n本章介绍获取R相关知识的途径。\n用Google限定关键词搜索，如R包名称等。当R报错时，可直接将报错信息进行检索，大概率会有人曾遇到一样的问题。\n运行Sys.setenv(LANGUAGE = \"en\")命令将报错信息以英文呈现，从而便于检索到更多信息。\n另外 Stack Overflow 网站是一个与程序相关的 IT 技术问答网站，可以在这获取帮助。",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>工作流：获取帮助</span>"
    ]
  },
  {
    "objectID": "chapters/ch8_workflow_getting_help.html#创建-reprex",
    "href": "chapters/ch8_workflow_getting_help.html#创建-reprex",
    "title": "9  工作流：获取帮助",
    "section": "9.2 8.2 创建 reprex",
    "text": "9.2 8.2 创建 reprex\n如果谷歌没有搜到有帮助的信息，则需要自己准备一个 reprex 去提问。所谓 reprex 就是：minimal reproducible example 。\n手动创建 reprex 时，很容易不小心遗漏某些内容，可能导致代码无法在其他人的计算机上运行。使用 reprex 包可以避免这个问题，它也是 tidyverse 包的一部分。\n假设将此代码复制到剪贴板上：\ny &lt;- 1:4\nmean(y)\n然后在R中输入reprex::reprex()，一个渲染好的 HTML 预览会显示在 RStudio 的查看器或默认浏览器中。同时，reprex 会自动复制到剪贴板。剪贴板内容如下：\n``` r\ny &lt;- 1:4\nmean(y)\n#&gt; [1] 2.5\n```\n\n&lt;sup&gt;Created on 2025-06-01 with [reprex v2.1.1](https://reprex.tidyverse.org \"reprex v2.1.1\")&lt;/sup&gt;\n\n其实就是markdown格式的代码块。\n\n要使示例具有可重复性，需要包含三项内容：必需的包、数据和代码。\n\n包要在脚本开头加载。要检查软件包是否使用的是最新版，可以运行tidyverse_update()函数。\n使用能揭示问题的最小数据子集。\n确保代码易于其他人阅读：\n\n规范使用空格，变量名称简洁但信息丰富。\n使用注释。\n尽量删除与问题无关的所有内容。",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>工作流：获取帮助</span>"
    ]
  },
  {
    "objectID": "chapters/ch8_workflow_getting_help.html#自我投资",
    "href": "chapters/ch8_workflow_getting_help.html#自我投资",
    "title": "9  工作流：获取帮助",
    "section": "9.3 8.3 自我投资",
    "text": "9.3 8.3 自我投资\n每天花点时间学习 R。\ntidyverse博客：https://www.tidyverse.org/blog/\nR Weekly：https://rweekly.org/",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>工作流：获取帮助</span>"
    ]
  },
  {
    "objectID": "chapters/ch9_layers.html",
    "href": "chapters/ch9_layers.html",
    "title": "10  图层",
    "section": "",
    "text": "10.1 引言\n本章将在学习图形的分层语法时扩展ggplot2基础，从更深入地研究美学映射、几何对象和分面开始。然后介绍 ggplot2 在创建绘图时在后台进行的统计转换，这些变换用于计算要绘制的新值，例如条形图中条形的高度或箱形图中的中位数。另外还将了解位置调整，用于修改几何在绘图中的显示方式。最后，简要介绍坐标系相关内容。",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>图层</span>"
    ]
  },
  {
    "objectID": "chapters/ch9_layers.html#美学映射",
    "href": "chapters/ch9_layers.html#美学映射",
    "title": "10  图层",
    "section": "10.2 美学映射",
    "text": "10.2 美学映射\n\n“The greatest value of a picture is when it forces us to notice what we never expected to see.” — John Tukey\n\nmpg数据框与ggplot2包捆绑，包含 38 个汽车模型的 234 个观测值。\nmpg\n#&gt; # A tibble: 234 × 11\n#&gt;   manufacturer model displ  year   cyl trans      drv     cty   hwy fl   \n#&gt;   &lt;chr&gt;        &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt;      &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt;\n#&gt; 1 audi         a4      1.8  1999     4 auto(l5)   f        18    29 p    \n#&gt; 2 audi         a4      1.8  1999     4 manual(m5) f        21    29 p    \n#&gt; 3 audi         a4      2    2008     4 manual(m6) f        20    31 p    \n#&gt; 4 audi         a4      2    2008     4 auto(av)   f        21    30 p    \n#&gt; 5 audi         a4      2.8  1999     6 auto(l5)   f        16    26 p    \n#&gt; 6 audi         a4      2.8  1999     6 manual(m5) f        18    26 p    \n#&gt; # ℹ 228 more rows\n#&gt; # ℹ 1 more variable: class &lt;chr&gt;\n变量解释：\n\ndispl：汽车的发动机尺寸，以升为单位。数值变量。\nhwy：汽车在高速公路上的燃油效率，以每加仑英里数 （mpg） 为单位。当它们行驶相同的距离时，燃油效率低的汽车比燃油效率高的汽车消耗更多的燃料。数值变量。\nclass： 汽车类型。分类变量。\n\n下面先初步可视化displ和hwy的关系。用散点图即可，数值变量映射到x和y美学，分类变量映射到color或shape美学。\n# 上图\nggplot(mpg, aes(x = displ, y = hwy, color = class)) +\n  geom_point()\n\n# 下图\nggplot(mpg, aes(x = displ, y = hwy, shape = class)) +\n  geom_point()\n#&gt; Warning: The shape palette can deal with a maximum of 6 discrete values because more\n#&gt; than 6 becomes difficult to discriminate\n#&gt; ℹ you have requested 7 values. Consider specifying shapes manually if you\n#&gt;   need that many of them.\n#&gt; Warning: Removed 62 rows containing missing values or values outside the scale range\n#&gt; (`geom_point()`).\n\n\n当映射到class和shape时，收到两个警告：\n\n形状调色板最多可以处理 6 个离散值，因为超过 6 个就很难区分；现在有 7 个。如果必须具有形状，请考虑手动指定形状。\ngeom_point()删除了包含缺失值的 62 行。\n\n同样，我们也可以将class映射到 size或alpha 美学，分别控制点的大小和透明度。\n# 上图\nggplot(mpg, aes(x = displ, y = hwy, size = class)) +\n  geom_point()\n#&gt; Warning: Using size for a discrete variable is not advised.\n\n# 下图\nggplot(mpg, aes(x = displ, y = hwy, alpha = class)) +\n  geom_point()\n#&gt; Warning: Using alpha for a discrete variable is not advised.\n\n\n也会产生警告：\n\n不建议对离散变量使用 alpha。\n\n还可以手动将 geom 的视觉属性设置参数。例如，我们可以将绘图中的所有点设为蓝色：\nggplot(mpg, aes(x = displ, y = hwy)) + \n  geom_point(color = \"blue\")\n\n在这里，颜色不传达有关变量的信息，而只是更改绘图外观。\n\n字符串形式的颜色名称，例如color = \"blue\"\n以 mm 为单位的点的大小，例如size = 1\n点的形状以数字表示，例如shape = 1。更多形状如图所示。",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>图层</span>"
    ]
  },
  {
    "objectID": "chapters/ch9_layers.html#几何对象",
    "href": "chapters/ch9_layers.html#几何对象",
    "title": "10  图层",
    "section": "10.3 几何对象",
    "text": "10.3 几何对象\n\n10.3.1 相似点图分析\n\n\n两幅图都展示了汽车高速燃油效率与发动机排量的关系。上边的图是散点图，下边的图显示了跟随这些变量关系轨迹的平滑曲线，并且周围还显示了置信区间。\n虽然两幅图描述的是相同的数据，但它们并不完全相同。每幅图使用不同的几何对象(geom)来表示数据。左边的图使用点几何对象(point geom)，右边的图使用平滑几何对象(smooth geom)，即一条拟合数据的平滑线。\n要改变图中的几何对象，可以更改ggplot()中的几何函数。例如，要分别创建上述两幅图，可以使用以下代码：\n# 上图\nggplot(mpg, aes(x = displ, y = hwy)) + \n  geom_point()\n\n# 下图\nggplot(mpg, aes(x = displ, y = hwy)) + \n  geom_smooth()\n\n\n10.3.2 映射\nggplot2中的每个几何函数都接受一个映射参数，可以在几何层中局部定义，也可以在ggplot()层中全局定义。然而，并非每个美学属性都适用于每个几何对象。例如，可以设置点的形状，但不能设置所谓线的“type”。如果这样做，ggplot2会忽略该美学映射。\n但是话又说回来，可以设置线的“linetype”。\n\n\n以下代码展示了如何使用不同的线型来表示不同类型驱动系统的汽车：\n# 上图\nggplot(mpg, aes(x = displ, y = hwy, shape = drv)) + \n  geom_smooth()\n\n# 下图\nggplot(mpg, aes(x = displ, y = hwy, linetype = drv)) + \n  geom_smooth()\n而且可以在同一图形中包含多个几何对象。例如，以下代码将原始数据点和平滑曲线叠加在一起：\nggplot(mpg, aes(x = displ, y = hwy, color = drv)) + \n  geom_point() +\n  geom_smooth(aes(linetype = drv))\n\n\n\n10.3.3 分组\n许多几何函数，如geom_smooth()，使用单个几何对象来显示多行数据。对于这些函数，可以将其美学设置为分类变量来绘制多个对象。实践中，当将美学映射到离散变量时，ggplot2会自动为这些几何对象分组数据。\nggplot(mpg, aes(x = displ, y = hwy)) +\n  geom_smooth(aes(color = drv), show.legend = FALSE)\n\n\n\n10.3.4 几何对象变换\n几何对象是ggplot2的基本构建块。通过改变几何对象可改变图形的外观，从而揭示数据的不同特征。例如，下面的直方图和密度图揭示了高速里程的分布是双峰且右偏的，而箱线图则揭示了两个潜在的离群值。\n\n\n\n# 上图：直方图\nggplot(mpg, aes(x = hwy)) +\n  geom_histogram(binwidth = 2)\n\n# 中图：密度图\nggplot(mpg, aes(x = hwy)) +\n  geom_density()\n\n# 下图：箱线图\nggplot(mpg, aes(x = hwy)) +\n  geom_boxplot()\n\n\n10.3.5 扩展几何对象\nggplot2提供了40多种几何对象，但这些并不涵盖所有可能的图形。如果需要不同的几何对象，建议首先查看扩展包，看看是否有人已经实现了。例如，ggridges包可用于制作山脊线图，这对于可视化分类变量不同水平的数值变量的密度很有效。\nlibrary(ggridges)\n\nggplot(mpg, aes(x = hwy, y = drv, fill = drv, color = drv)) +\n  geom_density_ridges(alpha = 0.5, show.legend = FALSE)",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>图层</span>"
    ]
  },
  {
    "objectID": "chapters/ch9_layers.html#分面",
    "href": "chapters/ch9_layers.html#分面",
    "title": "10  图层",
    "section": "10.4 分面",
    "text": "10.4 分面\n第一章介绍了使用facet_wrap()进行分面，它将图形分割为子图，每个子图基于一个分类变量显示数据的一个子集。\nggplot(mpg, aes(x = displ, y = hwy)) + \n  geom_point() + \n  facet_wrap(~cyl)\n\n要用两个变量的组合对图形进行分面，可以从facet_wrap()切换到facet_grid()。facet_grid()的第一个参数形如行~列。\nggplot(mpg, aes(x = displ, y = hwy)) + \n  geom_point() + \n  facet_grid(drv ~ cyl)\n\n默认情况下，每个分面共享相同的x轴和y轴比例和范围。这在想要跨分面比较数据时很有效，但当想要更好地可视化每个分面内的关系时可能会受限制。在分面函数中设置scales参数为\"free_x\"可允许跨列的不同x轴比例，\"free_y\"可允许跨行的不同y轴比例，\"free\"则表示两者共存。\nggplot(mpg, aes(x = displ, y = hwy)) + \n  geom_point() + \n  facet_grid(drv ~ cyl, scales = \"free\")",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>图层</span>"
    ]
  },
  {
    "objectID": "chapters/ch9_layers.html#统计变换",
    "href": "chapters/ch9_layers.html#统计变换",
    "title": "10  图层",
    "section": "10.5 统计变换",
    "text": "10.5 统计变换\n以一个基础的柱状图为例，通过 geom_bar() 或 geom_col() 绘制。下图展示了 diamonds 数据集中按照切工（cut）分组的钻石总数。该数据集来自 ggplot2 包，包含约 5.4 万颗钻石的信息，包括每颗钻石的价格（price）、克拉数（carat）、颜色（color）、净度（clarity）和切工（cut）。图中显示，相较于低质量切工，拥有高质量切工的钻石更多。\nggplot(diamonds, aes(x = cut)) + \n  geom_bar()\n\n图的 x 轴是来自 diamonds 数据集的 cut 变量，而 y 轴显示的是 count，但 count 并不是 diamonds 中的变量！那么 count 是从哪里来的？\n许多图形（如散点图）会绘制数据集中的原始值。而另一些图形（如柱状图）则会计算新的值进行绘图：\n\n柱状图、直方图与频率多边图 会将数据分箱（bin），然后绘制每个箱中数据点的数量；\n平滑曲线（smoothers） 会拟合模型并绘制模型预测值；\n箱线图（boxplots） 会计算分布的五数摘要（最小值、下四分位数、中位数、上四分位数、最大值），并以特定格式的箱体呈现。\n\n用于为图形计算新值的算法称为 stat，即统计变换（statistical transformation）的简称。下图展示了 geom_bar() 中这一过程的工作机制。\n\n\n绘制柱状图的三个步骤： 第一步，geom_bar() 从原始数据集 diamonds 开始； 第二步，geom_bar() 使用 count 这个 stat 对数据进行转换，生成一个包含 cut 值与 count 值的数据集； 第三步，geom_bar() 使用这个经过变换的数据来构建图形：cut 映射到 x 轴，count 映射到 y 轴。\n简言之，当我们创建柱状图时，首先从原始数据出发，接着聚合以统计每个柱状的观测数，最后将这些计算所得的变量映射到图形属性上。\n\n可以通过查看 stat 参数的默认值来了解某个 geom 使用了哪个 stat。例如，运行 ?geom_bar 可看到其默认的 stat 是 \"count\"，这意味着 geom_bar() 实际上使用的是 stat_count()。stat_count() 的文档与 geom_bar() 在同一页面上。如果向下滚动，可以在“Computed variables”（计算变量）部分看到该 stat 计算出两个新变量：count 与 prop。\n每个 geom 都有一个默认的 stat，每个 stat 也有一个默认的 geom。因此，通常在使用 geoms 时无需考虑背后的统计变换。但在以下三种情形下，可能需要显式使用 stat：\n\n重设默认的 stat\n\n在下面的代码中，将 geom_bar() 的 stat 从默认的 \"count\" 更改为 \"identity\"。这样可以将柱子的高度直接映射为某个变量的原始值，而非自动统计得到的数量。\ndiamonds |&gt;\n  count(cut) |&gt;\n  ggplot(aes(x = cut, y = n)) +\n  geom_bar(stat = \"identity\")\n\n\n重写变换后变量的美学映射\n\n例如，可能希望绘制柱状图显示每类钻石的比例，而不是数量：\nggplot(diamonds, aes(x = cut, y = after_stat(prop), group = 1)) + \n  geom_bar()\n\n\n在代码中明确突出统计变换的过程\n\n例如，可以使用 stat_summary() 来强调正在对 y 值进行摘要计算：该 stat 会对每个唯一的 x 值进行汇总。\nggplot(diamonds) + \n  stat_summary(\n    aes(x = cut, y = depth),\n    fun.min = min,\n    fun.max = max,\n    fun = median\n  )\n\nggplot2 提供了超过 20 种 stat 可供使用。每一个 stat 都是一个函数，因此可以通过 ?stat_bin 的形式获取帮助文档。",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>图层</span>"
    ]
  },
  {
    "objectID": "chapters/ch9_layers.html#位置调整",
    "href": "chapters/ch9_layers.html#位置调整",
    "title": "10  图层",
    "section": "10.6 位置调整",
    "text": "10.6 位置调整\n条形图可通过颜色美学（color）或填充美学（fill）着色。例如：\n# 上图\nggplot(mpg, aes(x = drv, color = drv)) + \n  geom_bar()\n\n# 下图\nggplot(mpg, aes(x = drv, fill = drv)) + \n  geom_bar()\n\n\n上图的条形仅显示彩色边框，下图的条形则填充了颜色。条形高度对应每种驱动类型（drv）的汽车数量。\n如果将填充美学映射到另一个变量（如 class），条形会自动堆叠：\nggplot(mpg, aes(x = drv, fill = class)) + \n  geom_bar()\n\n堆叠条形图显示汽车驱动类型，每个条形按汽车类别（class）填充颜色。条形总高度表示驱动类型的车辆总数，各色块高度表示该驱动类型下不同类别的车辆数量。\n堆叠效果由 position 参数自动控制。若需取消堆叠，有三种方式：\n\nposition = \"identity\"\n将每个对象精确绘制在其原始位置（条形会重叠，需配合透明度使用）：\n# 上图：半透明填充\nggplot(mpg, aes(x = drv, fill = class)) + \n  geom_bar(alpha = 1/5, position = \"identity\")\n\n# 下图：无填充仅边框\nggplot(mpg, aes(x = drv, color = class)) + \n  geom_bar(fill = NA, position = \"identity\")\n\n\nposition = \"fill\"\n堆叠并标准化高度为1，各色块高度表示类别在驱动类型中的占比：\nggplot(mpg, aes(x = drv, fill = class)) + \n  geom_bar(position = \"fill\")\n\nposition = \"dodge\"\n并列排列重叠对象，便于直接比较数值：\nggplot(mpg, aes(x = drv, fill = class)) + \n  geom_bar(position = \"dodge\")\n\n\n有时散点图存在过度绘制问题，如下图中数据取整导致点重叠。\n\n通过 position = \"jitter\" 添加轻微随机扰动可缓解：\nggplot(mpg, aes(x = displ, y = hwy)) + \n  geom_point(position = \"jitter\")\n\n抖动散点图显示发动机排量（displ）与高速油耗（hwy）的负相关。虽然小尺度精度下降，但大尺度分布更清晰。另有快捷函数 geom_jitter() 等效于 geom_point(position = \"jitter\")。",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>图层</span>"
    ]
  },
  {
    "objectID": "chapters/ch9_layers.html#坐标系系统",
    "href": "chapters/ch9_layers.html#坐标系系统",
    "title": "10  图层",
    "section": "10.7 坐标系系统",
    "text": "10.7 坐标系系统\nggplot2 默认使用笛卡尔坐标系（Cartesian），x 和 y 轴独立定位点位置。此外还有两种特殊坐标系：\n\n地理地图矫正：coord_quickmap()\n\n绘制地理空间数据时，可通过此函数校正长宽比例（保持地图不变形）。以下以新西兰地图为例：\n\n\nnz &lt;- map_data(\"nz\")\n\n# 未校正比例（上图）\nggplot(nz, aes(x = long, y = lat, group = group)) +\n  geom_polygon(fill = \"white\", color = \"black\")\n\n# 校正比例（下图）\nggplot(nz, aes(x = long, y = lat, group = group)) +\n  geom_polygon(fill = \"white\", color = \"black\") +\n  coord_quickmap()\n两图对比新西兰边界：左图比例失真，右图通过 coord_quickmap() 保持正确地理比例。\n\n极坐标系：coord_polar()\n\n将条形图转换为玫瑰图（Coxcomb chart），可揭示数据分布的周期性，每个类别对应一个扇形区域。\n# 基础条形图（长宽比设为1:1）\nbar &lt;- ggplot(diamonds) + \n  geom_bar(\n    aes(x = clarity, fill = clarity), \n    show.legend = FALSE,\n    width = 1\n  ) + \n  theme(aspect.ratio = 1)\n\n# 横向条形图（上图）\nbar + coord_flip()\n\n# 极坐标转换的玫瑰图（下图）\nbar + coord_polar()",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>图层</span>"
    ]
  },
  {
    "objectID": "chapters/ch10_exploratory_data_analysis.html",
    "href": "chapters/ch10_exploratory_data_analysis.html",
    "title": "11  探索性数据分析",
    "section": "",
    "text": "11.1 简介\n本章将介绍如何通过可视化和数据转换系统化地探索数据，这一过程在统计学中称为探索性数据分析（Exploratory Data Analysis, EDA）。EDA是一个迭代循环的过程，包含以下步骤：\nEDA是数据分析的核心环节，能帮助评估数据质量。例如，数据清洗本质上就是EDA的应用：通过质疑数据是否符合预期，利用可视化、转换和建模工具识别并解决问题。",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>探索性数据分析</span>"
    ]
  },
  {
    "objectID": "chapters/ch10_exploratory_data_analysis.html#简介",
    "href": "chapters/ch10_exploratory_data_analysis.html#简介",
    "title": "11  探索性数据分析",
    "section": "",
    "text": "提出问题：针对数据生成初步问题；\n探索答案：通过可视化、数据转换和建模寻找答案；\n迭代优化：根据发现的问题调整或生成新问题。",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>探索性数据分析</span>"
    ]
  },
  {
    "objectID": "chapters/ch10_exploratory_data_analysis.html#问题的艺术",
    "href": "chapters/ch10_exploratory_data_analysis.html#问题的艺术",
    "title": "11  探索性数据分析",
    "section": "11.2 问题的艺术",
    "text": "11.2 问题的艺术\n在EDA过程中，核心目标是理解数据，而提问是引导探索的最佳工具。每个问题都会聚焦到数据的特定方面，进而选择恰当的可视化、模型或数据转换方法。\nEDA本质上是创造性过程，提出高质量问题的关键在于追求问题数量。虽然由于尚未了解数据中隐藏信息，初期问题可能较肤浅，但每个新问题都会揭示新视角。通过连续追问可逐步深入数据。\n提问没有固定模板，但以下两类问题一般最有研究价值：\n\n变异（Variation）\n例如：某变量的分布形态如何？是否存在异常值？\n“顾客年龄范围是多少？80岁的记录是真实数据还是输入错误？”\n共变（Covariation）\n例如：两个变量是否存在关联？关联强度如何？\n“产品销量与广告支出是否同步变化？季节性影响是否显著？”",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>探索性数据分析</span>"
    ]
  },
  {
    "objectID": "chapters/ch10_exploratory_data_analysis.html#变异",
    "href": "chapters/ch10_exploratory_data_analysis.html#变异",
    "title": "11  探索性数据分析",
    "section": "11.3 变异",
    "text": "11.3 变异\n变异（Variation）指变量在不同测量中取值的波动现象。现实中所有连续变量都会存在变异，结果也会因微小误差而不同。理解变异的关键在于可视化的值分布。\n以钻石重量（carat）为例，通过直方图观察其分布：\n# 全数据集直方图（右偏分布）\nggplot(diamonds, aes(x = carat)) +\n  geom_histogram(binwidth = 0.5)\n\n# 聚焦小克拉钻石（窄binwidth揭示细节）\nsmaller &lt;- diamonds |&gt;\n  filter(carat &lt; 3)\n\nggplot(smaller, aes(x = carat)) +\n  geom_histogram(binwidth = 0.01)\n\n根据可视化图形，我们就可以进一步观察与追问。比如：\n\n峰值现象\n为什么克拉数为整数或常见分数（如0.5、1）的钻石更多？\n可能钻石切割标准或消费者偏好导致特定重量更常见。\n右偏特征\n每个峰值右侧的钻石为何比左侧多？\n可能切割时倾向于略微超重而非不足。\n诸如此类。\n\n图中若出现异常值，可能是错误数据或某些特殊现象。以钻石尺寸（y轴长度）为例：\n# 基础直方图（异常值被掩盖）\nggplot(diamonds, aes(x = y)) + \n  geom_histogram(binwidth = 0.5)\n\n# 聚焦y轴低频区域（暴露出异常）\nggplot(diamonds, aes(x = y)) + \n  geom_histogram(binwidth = 0.5) +\n  coord_cartesian(ylim = c(0, 50))\n\n# 根据图形提取异常记录\nunusual &lt;- diamonds |&gt; \n  filter(y &lt; 3 | y &gt; 20) |&gt; \n  select(price, x, y, z) |&gt;\n  arrange(y)\n提取完异常值，可按照以下思路针对性分析。\n\n零值\n尺寸为0mm的钻石（y=0）显然是数据错误，应转换为NA。\n极端值\n长达30mm+的钻石若价格不足万元，可能需核实：\n\n是否单位错误（如英寸误录为毫米）\n是否测量设备故障\n\n\n通过这种分析，我们不仅发现了数据质量问题（如零值），还可能识别出特殊钻石类别（如超大但低价的异常记录），为进一步处理提供方向。",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>探索性数据分析</span>"
    ]
  },
  {
    "objectID": "chapters/ch10_exploratory_data_analysis.html#异常值处理",
    "href": "chapters/ch10_exploratory_data_analysis.html#异常值处理",
    "title": "11  探索性数据分析",
    "section": "11.4 异常值处理",
    "text": "11.4 异常值处理\n数据中的异常值需要继续处理，有两种方式。\n\n直接删除整行\n\ndiamonds2 &lt;- diamonds |&gt; \n  filter(between(y, 3, 20))\n但是存在隐患，毕竟单个变量的异常不代表整行数据无效。\n\n替换为缺失值(NA)\n\ndiamonds2 &lt;- diamonds |&gt; \n  mutate(y = if_else(y &lt; 3 | y &gt; 20, NA, y))\n这一方法就更合理，能够保留其他变量的有效信息。\n排除缺失值后再次可视化，ggplot2默认移除缺失值并给出警告：\nggplot(diamonds2, aes(x = x, y = y)) + \n  geom_point()\n#&gt; Warning: Removed 9 rows containing missing values or values outside the scale range\n\n可通过na.rm = TRUE隐藏警告：\nggplot(diamonds2, aes(x = x, y = y)) + \n  geom_point(na.rm = TRUE)\n而有时缺失值本身也具有意义。例如航班数据中，dep_time为NA时，表示航班取消。",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>探索性数据分析</span>"
    ]
  },
  {
    "objectID": "chapters/ch10_exploratory_data_analysis.html#共变",
    "href": "chapters/ch10_exploratory_data_analysis.html#共变",
    "title": "11  探索性数据分析",
    "section": "11.5 共变",
    "text": "11.5 共变\n共变（Covariation）描述变量间的协同变化关系，是探索数据多维模式的核心工具。本节探索钻石价格与切工质量的关系，通过两种可视化方法揭示反常现象及其原因。\n\n频率多边形（Density标准化）\n\n我们首先进行初次尝试：\nggplot(diamonds, aes(x = price)) + \n  geom_freqpoly(aes(color = cut), binwidth = 500, linewidth = 0.75)\n\n这张图存在两点问题：\n\n不同切工等级的样本量差异大（如Ideal切工钻石最多），导致频数难以直接比较。\n图形重叠严重，无法清晰观察分布形态差异。\n\n如下改进：\nggplot(diamonds, aes(x = price, y = after_stat(density))) + \n  geom_freqpoly(aes(color = cut), binwidth = 500, linewidth = 0.75)\n\n将y轴从绝对计数转换为相对密度，使得每条曲线下的面积均为1。\n\n\n这样便可进行分析：\n\nFair切工（最低等级）的钻石价格密度分布右移，均值最高，较为反常。\n其他切工等级在1500美元附近出现高峰。\n\n\n箱线图\n\nggplot(diamonds, aes(x = cut, y = price)) +\n  geom_boxplot()\n\n分析可得：\n\n中位数价格：Fair &gt; Good &gt; Very Good &gt; Premium &gt; Ideal（随切工等级提升而下降）。\n分布形态：所有切工等级均右偏，但Fair切工的离群点更多。\n\n针对箱线图，还有一些扩展技巧如下。\n示例：车辆油耗（hwy）按车型（class）分类\n# 默认无序排列\nggplot(mpg, aes(x = class, y = hwy)) + geom_boxplot()\n\n# 按中位数排序\nggplot(mpg, aes(x = fct_reorder(class, hwy, median), y = hwy)) +\n  geom_boxplot()\n\n# 若名称过长，可翻转坐标轴\nggplot(mpg, aes(x = hwy, y = fct_reorder(class, hwy, median))) +\n  geom_boxplot()\n\n下面对变量关系进一步分析，但首先应确认变量类型。\n若要对两个分类变量的关系进行分析，有以下两种方法。\n\n气泡图（geom_count()）\nggplot(diamonds, aes(x = cut, y = color)) +\n  geom_count()\n\n每个气泡大小表示组合频数（如G色Ideal切工钻石最多）。虽然直观，但当类别过多时，气泡可能重叠。\n热图（geom_tile()）\ndiamonds |&gt; \n  count(color, cut) |&gt;  \n  ggplot(aes(x = color, y = cut, fill = n)) +\n  geom_tile() +\n  scale_fill_viridis_c()  # 优化颜色梯度\n\n颜色深浅直观反映频数差异，适合展示高维组合。\n例如根据上图可分析出：\n\nIdeal切工在D-G色中更常见，而J色几乎无Ideal切工。\nFair切工在低色级（I-J）占比更高。\n\n\n若要对两个数值变量的关系进行分析，有以下两种方法。\n\n过绘制（Overplotting）\n\nggplot(smaller, aes(x = carat, y = price)) + \n  geom_point(alpha = 0.01)  # 调整透明度，揭示数据密集区域\n\n\n二维分箱\n\n\n矩形分箱（geom_bin2d()）\nggplot(smaller, aes(x = carat, y = price)) +\n  geom_bin2d() +\n  scale_fill_gradient(low = \"lightblue\", high = \"darkred\")\n\n六边形分箱（geom_hex()）\nlibrary(hexbin)\nggplot(smaller, aes(x = carat, y = price)) +\n  geom_hex()  # 相邻单元过渡更自然\n\n\n\n离散化+箱线图\n\nggplot(smaller, aes(x = carat, y = price)) + \n  geom_boxplot(aes(group = cut_width(carat, 0.1)), varwidth = TRUE)\n\n\n关键参数\ncut_width(x, width)：按固定宽度分箱。\nvarwidth = TRUE：箱宽反映样本量。",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>探索性数据分析</span>"
    ]
  },
  {
    "objectID": "chapters/ch10_exploratory_data_analysis.html#模式与模型",
    "href": "chapters/ch10_exploratory_data_analysis.html#模式与模型",
    "title": "11  探索性数据分析",
    "section": "11.6 模式与模型",
    "text": "11.6 模式与模型\n当数据中出现系统性关系时，它会表现为某种模式(pattern)。发现模式后，需追问以下问题：\n\n该模式是否因巧合产生？\n如何描述该模式暗示的关系？\n这种关系的相关性强度如何？\n是否有其他变量影响该关系？\n在不同数据子组中，该关系是否不同？\n\n要解决以上问题，我们需创建模型(model)。\n比如现在对钻石进行分析，其价格（price）同时受克拉（carat）和切工（cut）影响，而克拉与切工又存在关联（高切工等级的钻石通常较小）。直接观察cut与price的关系会产生误导，因此我们建立预测模型，用克拉预测价格，提取残差并分析。残差会反映出反常的价格波动，此时再探索切工的影响。\nlibrary(tidymodels)\n\n# 对数变换后建模（更适合指数关系）\ndiamonds &lt;- diamonds |&gt;\n  mutate(\n    log_price = log(price),\n    log_carat = log(carat)\n  )\n\n# 拟合线性模型\ndiamonds_fit &lt;- linear_reg() |&gt;\n  fit(log_price ~ log_carat, data = diamonds)\n\n# 计算残差并逆变换\ndiamonds_aug &lt;- augment(diamonds_fit, new_data = diamonds) |&gt;\n  mutate(.resid = exp(.resid))  # 残差还原为原始价格尺度\n\n# 可视化残差与克拉的关系\nggplot(diamonds_aug, aes(x = carat, y = .resid)) + \n  geom_point(alpha = 0.1) +\n  labs(y = \"Price Residuals (adjusted for carat)\")\n\n根据可视化图形可发现，大克拉钻石的残差普遍更低。\n可见，创建模型后，更方便进一步确认变量间的模式。",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>探索性数据分析</span>"
    ]
  },
  {
    "objectID": "chapters/ch11_communication.html",
    "href": "chapters/ch11_communication.html",
    "title": "12  解释性图表",
    "section": "",
    "text": "12.1 引言\n通过前一章节我们知道如何分析数据，接下来就需要将自己的理解传达给他人。由于我们的受众可能不具备相关背景知识，所以要确保图表尽可能一目了然，从而帮助他们快速建立对数据的准确认知。\n简言之，目标是：将探索性图表转化为解释性图表。\n必要工具包：",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>解释性图表</span>"
    ]
  },
  {
    "objectID": "chapters/ch11_communication.html#引言",
    "href": "chapters/ch11_communication.html#引言",
    "title": "12  解释性图表",
    "section": "",
    "text": "library(tidyverse)    # 含ggplot2\nlibrary(scales)       # 调整坐标轴刻度/标签\nlibrary(ggrepel)      # 智能标签防重叠\nlibrary(patchwork)    # 多图排版",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>解释性图表</span>"
    ]
  },
  {
    "objectID": "chapters/ch11_communication.html#标签labels",
    "href": "chapters/ch11_communication.html#标签labels",
    "title": "12  解释性图表",
    "section": "12.2 标签（Labels）",
    "text": "12.2 标签（Labels）\n使用labs()为图表添加标签，增强图形可读性：\nggplot(mpg, aes(x = displ, y = hwy)) +\n  geom_point(aes(color = class)) +\n  geom_smooth(se = FALSE) +\n  labs(\n    x = \"Engine displacement (L)\",\n    y = \"Highway fuel economy (mpg)\",\n    color = \"Car type\",\n    title = \"Fuel efficiency generally decreases with engine size\",\n    subtitle = \"Two seaters (sports cars) are an exception because of their light weight\",\n    caption = \"Data from fueleconomy.gov\"\n  )\n\n图表标题的作用是概括核心内容。注意标题不能仅描述图表类型（如“发动机排量与燃油经济性的散点图”）。\n除了主标题，还有两种标签：\n\nsubtitle：在主标题下方以较小字体添加补充说明\ncaption：在图表右下角添加文字（通常用于注明数据来源）\n\n通过labs()函数也可以修改坐标轴和图例标题。建议将简短的变量名替换为更详细的描述，并包含单位信息。\n此外，还可以使用数学公式代替普通文本标签。只需将引号替换为quote()，具体语法可参考?plotmath。\ndf &lt;- tibble(\n  x = 1:10,\n  y = cumsum(x^2)\n)\n\nggplot(df, aes(x, y)) +\n  geom_point() +\n  labs(\n    x = quote(x[i]),\n    y = quote(sum(x[i]^2, i==1, n))\n  )",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>解释性图表</span>"
    ]
  },
  {
    "objectID": "chapters/ch11_communication.html#注释annotations",
    "href": "chapters/ch11_communication.html#注释annotations",
    "title": "12  解释性图表",
    "section": "12.3 注释（Annotations）",
    "text": "12.3 注释（Annotations）\n除了标签外，对个别观测值或观测值组进行注释也很有用。基础函数是geom_text()，它与geom_point()类似，但多了一个label美学属性，可以在图表中添加文字注释。\n注释有两种方法。\n第一种是使用专门准备的标注数据框。例如，我们提取每种驱动类型中发动机排量最大的车型信息：\nlabel_info &lt;- mpg |&gt;\n  group_by(drv) |&gt;\n  arrange(desc(displ)) |&gt;\n  slice_head(n = 1) |&gt;\n  mutate(\n    drive_type = case_when(\n      drv == \"f\" ~ \"front-wheel drive\",\n      drv == \"r\" ~ \"rear-wheel drive\",\n      drv == \"4\" ~ \"4-wheel drive\"\n    )\n  ) |&gt;\n  select(displ, hwy, drv, drive_type)\n\nlabel_info\n#&gt; # A tibble: 3 × 4\n#&gt; # Groups:   drv [3]\n#&gt;   displ   hwy drv   drive_type       \n#&gt;   &lt;dbl&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt;            \n#&gt; 1   6.5    17 4     4-wheel drive    \n#&gt; 2   5.3    25 f     front-wheel drive\n#&gt; 3   7      24 r     rear-wheel drive\n然后直接在图表上标注这三组数据，用注释代替图例。通过调整字体大小(size)和粗细(fontface)可以突出注释：\nggplot(mpg, aes(x = displ, y = hwy, color = drv)) +\n  geom_point(alpha = 0.3) +\n  geom_smooth(se = FALSE) +\n  geom_text(\n    data = label_info,\n    aes(label = drive_type),\n    fontface = \"bold\", size = 5, hjust = \"right\", vjust = \"bottom\" # 控制标注对齐\n  ) +\n  theme(legend.position = \"none\")  # 隐藏图例\n\n注意到注释与散点重叠，此时可以使用ggrepel包的geom_label_repel()自动调整位置：\nggplot(mpg, aes(x = displ, y = hwy, color = drv)) +\n  geom_point(alpha = 0.3) +\n  geom_smooth(se = FALSE) +\n  geom_label_repel(\n    data = label_info,\n    aes(label = drive_type),\n    fontface = \"bold\", size = 5,\n    nudge_y = 2  # 垂直偏移\n  ) +\n  theme(legend.position = \"none\")\n\n结合geom_text_repel()和特殊标记则可以突出异常点：\npotential_outliers &lt;- mpg |&gt; filter(hwy &gt; 40 | (hwy &gt; 20 & displ &gt; 5))\n\nggplot(mpg, aes(x = displ, y = hwy)) +\n  geom_point() +\n  geom_text_repel(data = potential_outliers, aes(label = model)) +\n  geom_point(\n    data = potential_outliers, \n    color = \"red\", size = 3, shape = \"circle open\"  # 空心红圈标记\n  )\n\n其他标注特殊点的方法：\n\n参考线：使用geom_hline()/geom_vline()\n矩形标记：使用geom_rect()或ggforce::geom_mark_hull()\n箭头指示：使用geom_segment(arrow = arrow())\n\n注释的第二种方法是使用annotate函数。\nannotate()适合添加少量独立标注元素。例如添加趋势说明：\ntrend_text &lt;- \"Larger engine sizes tend to have lower fuel economy.\" |&gt;\n  str_wrap(width = 30)\ntrend_text\n#&gt; [1] \"Larger engine sizes tend to\\nhave lower fuel economy.\"\nggplot(mpg, aes(x = displ, y = hwy)) +\n  geom_point() +\n  annotate(\n    geom = \"label\", x = 3.5, y = 38,\n    label = trend_text,\n    hjust = \"left\", color = \"red\"\n  ) +\n  annotate(\n    geom = \"segment\",\n    x = 3, y = 35, xend = 5, yend = 25, color = \"red\", # 给箭头定位\n    arrow = arrow(type = \"closed\")\n  )",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>解释性图表</span>"
    ]
  },
  {
    "objectID": "chapters/ch11_communication.html#比例尺scales",
    "href": "chapters/ch11_communication.html#比例尺scales",
    "title": "12  解释性图表",
    "section": "12.4 比例尺（Scales）",
    "text": "12.4 比例尺（Scales）\n比例尺也可调整美学映射的视觉表现形式。\n\n12.4.1 默认比例\nggplot2 默认添加的比例尺如下：\nggplot(mpg, aes(x = displ, y = hwy)) +\n  geom_point(aes(color = class)) +\n  scale_x_continuous() +\n  scale_y_continuous() +\n  scale_color_discrete()\n命名规则：scale_ + 美学名称（如 x、color） + _ + 比例尺类型（如 continuous、discrete）。\n\ncontinuous 表示将数值以连续刻度形式映射。\ndiscrete 表示基于每个离散变量类别进行分配。\n\n默认比例尺适用于大多数情况。\n\n\n12.4.2 轴刻度和图例键\n坐标轴和图例统称为引导元素（guides）。其中坐标轴用于呈现x和y美学映射，而图例则负责展示其他所有美学映射。\n影响坐标轴刻度线和图例显示的两个主要参数是： breaks 和 labels。breaks参数用于控制刻度线的位置或与图例相关联的数值；labels参数则控制每个刻度线或图例对应的文本标签。\n以下分别为例：\n# break修改y轴刻度间隔\nggplot(mpg, aes(x = displ, y = hwy)) +\n  geom_point() +\n  scale_y_continuous(breaks = seq(15, 40, by = 5))\n\nggplot(mpg, aes(x = displ, y = hwy, color = drv)) +\n  geom_point() +\n  scale_x_continuous(labels = NULL) +\n  scale_y_continuous(labels = NULL) +\n  scale_color_discrete(labels = c(\"4\" = \"4-wheel\", \"f\" = \"front\", \"r\" = \"rear\"))\n\nlabels参数与scales包中的标签格式化函数结合使用时，能有效实现数值的货币化（如添加美元符号）、百分比化等格式转换。比如label_dollar()函数效果如下，通过将美元数值除以1000并添加”K”，同时自定义刻度间隔点（breaks参数仍基于原始标度设置）。\nlibrary(scales)\nggplot(diamonds, aes(x = price, y = cut)) +\n  geom_boxplot() +\n  scale_x_continuous(labels = label_dollar(scale = 1/1000, suffix = \"K\"))\n\n另一个实用的函数是 label_percent()，将标签改为百分比形式。\nggplot(diamonds, aes(x = cut, fill = clarity)) +\n  geom_bar(position = \"fill\") +\n  scale_y_continuous(name = \"Percentage\", labels = label_percent())\n\n另外，breaks 参数还有另一个用途。当数据点较少时可精确标注观测值位置。以展示美国总统任期起止时间的图表为例：\npresidential |&gt;\n  mutate(id = 33 + row_number()) |&gt;\n  ggplot(aes(x = start, y = id)) +\n  geom_point() +\n  geom_segment(aes(xend = end, yend = id)) +\n  scale_x_date(name = NULL, breaks = presidential$start, date_labels = \"'%y\")\n\n\n\n12.4.3 图例布局\nbreaks和labels参数最常用于调整坐标轴，虽然它们也可用于图例，但图例调整通常需要其他方法。\n控制图例整体位置需使用theme()设置（在本章末尾详述，它主要用于控制图形的非数据元素）。通过theme()的legend.position参数可指定图例位置：\nbase &lt;- ggplot(mpg, aes(x = displ, y = hwy)) +\n  geom_point(aes(color = class))\n\n# 默认右侧显示\nbase + theme(legend.position = \"right\")  \n# 左侧显示\nbase + theme(legend.position = \"left\")\n# 顶部显示并控制图例分3行排列\nbase + theme(legend.position = \"top\") +\n  guides(color = guide_legend(nrow = 3))\n# 底部显示并控制图例分3行排列\nbase + theme(legend.position = \"bottom\") +\n  guides(color = guide_legend(nrow = 3))\n布局建议：\n\n宽幅图形建议图例置于顶部或底部\n窄幅图形建议图例置于左侧或右侧\n使用legend.position = \"none\"可完全隐藏图例\n\n通过guides()配合guide_legend()或guide_colorbar()可控制单个图例显示。以下示例展示两个关键设置：\n\n用nrow更改图例行数\n用override.aes更改美学设置（如增大图例点大小）\n\nggplot(mpg, aes(x = displ, y = hwy)) +\n  geom_point(aes(color = class), alpha = 0.5) +  # 半透明显示密集点\n  geom_smooth(se = FALSE) +\n  theme(legend.position = \"bottom\") +\n  guides(color = guide_legend(\n    nrow = 2, \n    override.aes = list(size = 4)  # 图例点尺寸设为4倍\n  ))\n\n\n特别注意：guides()中的参数名称必须与对应的美学映射名称完全匹配。\n\n\n\n12.4.4 替换比例尺\n除了微调参数外，还可以直接替换整个比例尺。最常需要替换的比例尺主要有两种：连续位置比例尺和颜色比例尺。\n1. 连续位置比例尺\n使用对数变换（保留原始刻度标签）：\nggplot(diamonds, aes(x = carat, y = price)) +\n  geom_point() +\n  scale_x_log10() + \n  scale_y_log10()\n\n\n\nPlot of price versus carat of diamonds. Data binned and the color of the rectangles representing each bin based on the number of points that fall into that bin. The axis labels are on the original data scale.\n\n\n2. 颜色比例尺\n\n离散型：使用 ColorBrewer 调色板（对色盲友好）：\nggplot(mpg, aes(x = displ, y = hwy)) +\n  geom_point(aes(color = drv)) +\n  scale_color_brewer(palette = \"Set1\") # 适配红绿色盲\n当需要自定义数值与颜色的映射关系时，应使用 scale_color_manual()。例如在总统政党数据可视化中，红色代表共和党，蓝色代表民主党，可以写成：\nscale_color_manual(values = c(Republican = \"#E81B23\", Democratic = \"#00AEF3\")\n连续型：使用内置的 scale_color_gradient() 或 scale_fill_gradient() 函数。如果需要发散的（diverging）颜色比例尺，则应当使用 scale_color_gradient2()，该函数允许为正负值分配不同颜色（例如区分高于或低于均值的数据点）。\n另一个推荐方案是采用 viridis 色标体系。设计者 Nathaniel Smith 和 Stéfan van der Walt 精心打造的这些连续色标具有以下特性：\n\n适配各类色盲患者的视觉需求\n在彩色和黑白模式下均保持感知均匀性\n在 ggplot2 中提供三种变体：\n\n连续型（后缀 _c）\n离散型（后缀 _d）\n分箱型（后缀 _b）\n\n\n应用示例如下：\ndf &lt;- tibble(\n  x = rnorm(10000),\n  y = rnorm(10000)\n)\n\nggplot(df, aes(x, y)) +\n  geom_hex() +\n  coord_fixed() +\n  labs(title = \"Default, continuous\", x = NULL, y = NULL)\n\nggplot(df, aes(x, y)) +\n  geom_hex() +\n  coord_fixed() +\n  scale_fill_viridis_b() +\n  labs(title = \"Viridis, binned\", x = NULL, y = NULL)\n\n\n\n\n\n12.4.5 缩放视图\n控制图形显示范围主要有两个方法：\n\n调整绘图数据范围\n设置比例尺限制\n\n比如当分别绘制SUV和小轿车的油耗数据时，两张图的坐标轴范围和图例显示不一致，SUV的x轴范围是4.0-6.5，轿车则是1.8-4.0；且图例也不同，SUV只有四驱和后驱，轿车只有前驱和四驱。两张图不能直接比较，需进行标度统一。\n# 创建共享比例尺\nx_scale &lt;- scale_x_continuous(limits = range(mpg$displ))\ny_scale &lt;- scale_y_continuous(limits = range(mpg$hwy))\ncol_scale &lt;- scale_color_discrete(limits = unique(mpg$drv))\n\n# 应用至分面图形\nggplot(suv, aes(displ, hwy, color = drv)) +\n  geom_point() +\n  x_scale + y_scale + col_scale\n\nggplot(compact, aes(displ, hwy, color = drv)) +\n  geom_point() +\n  x_scale + y_scale + col_scale",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>解释性图表</span>"
    ]
  },
  {
    "objectID": "chapters/ch11_communication.html#主题themes",
    "href": "chapters/ch11_communication.html#主题themes",
    "title": "12  解释性图表",
    "section": "12.5 主题（Themes）",
    "text": "12.5 主题（Themes）\n主题（theme）用于自定义图表的非数据元素（如背景、网格线、字体等）。\nggplot2 提供8种内置主题，默认是 theme_gray()。常用主题包括：\n\n\n\n主题函数\n效果描述\n\n\n\n\ntheme_gray()\n灰色背景（默认）\n\n\ntheme_bw()\n白色背景 + 灰色网格线\n\n\ntheme_classic()\n经典风格（无网格线，仅坐标轴）\n\n\ntheme_minimal()\n极简风格（无背景和边框）\n\n\ntheme_void()\n完全空白（仅显示几何对象）\n\n\n\n通过 theme() 函数可以精细控制图表外观，例如：\n\n调整图例\n\nggplot(mpg, aes(x = displ, y = hwy, color = drv)) +\n  geom_point() +\n  theme(\n    legend.position = c(0.6, 0.7),  # 图例位置（坐标范围0~1）\n    legend.direction = \"horizontal\", # 图例水平排列\n    legend.box.background = element_rect(color = \"black\")  # 图例边框\n  )\n\n坐标轴和网格线\n\ntheme(\n  axis.text.x = element_text(angle = 45, hjust = 1),  # X轴标签旋转45度\n  panel.grid.major = element_line(color = \"gray80\"),  # 主网格线颜色\n  panel.background = element_rect(fill = \"white\")     # 绘图区背景色\n要快速预览当前主题效果可用如下函数：\nggplot2::theme_get()",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>解释性图表</span>"
    ]
  },
  {
    "objectID": "chapters/ch11_communication.html#多图布局layout",
    "href": "chapters/ch11_communication.html#多图布局layout",
    "title": "12  解释性图表",
    "section": "12.6 多图布局（Layout）",
    "text": "12.6 多图布局（Layout）\n当需要将多个图表组合成一个图形时，可以使用 patchwork 包。\n\n让两个子图合并，并排显示\n\nlibrary(patchwork)\nlibrary(ggplot2)\n\n# 创建两个图表对象\np1 &lt;- ggplot(mpg, aes(x = displ, y = hwy)) + \n  geom_point() + \n  labs(title = \"散点图：发动机排量 vs. 油耗\")\n\np2 &lt;- ggplot(mpg, aes(x = drv, y = hwy)) + \n  geom_boxplot() + \n  labs(title = \"箱线图：驱动类型 vs. 油耗\")\n\n# 并排显示\np1 + p2\n\n复杂布局（| 和 /)\n\np3 &lt;- ggplot(mpg, aes(x = cty, y = hwy)) + \n  geom_point() + \n  labs(title = \"散点图：城市油耗 vs. 高速油耗\")\n\n(p1 | p3) / p2\n# 第一行：p1 | p3，第二行：p2\n\n\n| 横向排列，/ 纵向排列\n用括号 () 明确分组优先级\n\n\n\n统一图例、定义尺寸\n\n通过 plot_layout(guides = \"collect\") 合并多个子图的图例，并用 & theme() 统一调整位置：\n(p1 + p2 + p3) + \n  plot_layout(guides = \"collect\") &  # 合并所有图例\n  theme(legend.position = \"top\")    # 图例置顶\n\n运算符区别：\n\n+添加图层或组合子图\n&批量修改主题（适用于 patchwork 全局）\n\n\n拼图的图例区域称为（guide_area），是专门为图例预留的区域，通常与顶部布局结合：\n(guide_area() / (p1 + p2)) +  # 图例在上，p1和p2在下\n  plot_layout(guides = \"collect\", heights = c(1, 4))  # 图例区高度1，主图区高度4\n另外还可自定义子图尺寸，通过 heights 和 widths 按比例分配空间：\n(p1 | p2 | p3) + \n  plot_layout(\n    widths = c(2, 1, 1),  # 第一个图宽度占2份\n    heights = c(3, 2)      # 适用于纵向布局\n  )",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>解释性图表</span>"
    ]
  },
  {
    "objectID": "chapters/ch12_logical_vectors.html",
    "href": "chapters/ch12_logical_vectors.html",
    "title": "13  逻辑向量",
    "section": "",
    "text": "13.1 引言\n逻辑向量中的元素只有三种值：TRUE、FALSE、NA。\n本章用到下列R包：",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>逻辑向量</span>"
    ]
  },
  {
    "objectID": "chapters/ch12_logical_vectors.html#引言",
    "href": "chapters/ch12_logical_vectors.html#引言",
    "title": "13  逻辑向量",
    "section": "",
    "text": "library(tidyverse)\nlibrary(nycflights13) #航班数据",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>逻辑向量</span>"
    ]
  },
  {
    "objectID": "chapters/ch12_logical_vectors.html#比较运算",
    "href": "chapters/ch12_logical_vectors.html#比较运算",
    "title": "13  逻辑向量",
    "section": "13.2 比较运算",
    "text": "13.2 比较运算\n创建逻辑向量的最常用方法是使用比较运算符：&lt;、&lt;=、&gt;、&gt;=、!= 和 ==。\n比如在filter()函数中的比较运算符用于筛选数据：\nflights |&gt; \n  filter(dep_time &gt; 600 & dep_time &lt; 2000 & abs(arr_delay) &lt; 20)\n或者在mutate()函数中用于限定：\nflights |&gt; \n  mutate(\n    daytime = dep_time &gt; 600 & dep_time &lt; 2000,\n    approx_ontime = abs(arr_delay) &lt; 20,\n    .keep = \"used\"\n  )\n在进行比较运算时，注意与浮点数相关的运算不能用==，因为计算机表示小数时存在精度误差。错误示范：\nx &lt;- c(1 / 49 * 49, sqrt(2) ^ 2)\nx == c(1, 2)\n#&gt; [1] FALSE FALSE\n解决方法是使用 dplyr::near() 函数，可忽略极小的数值差异：\nnear(x, c(1, 2))\n#&gt; [1] TRUE TRUE\nNA表示”未知“，与其相关的比较运算结果都是NA：\nNA &gt; 5        #&gt; NA\n10 == NA      #&gt; NA\nNA == NA      #&gt; NA （不表示相等，而是“未知是否相等”）\n因此，不能用 == NA 检测缺失值。如下代码无效：\nflights |&gt; filter(dep_time == NA)\n#&gt; 返回0行，因为 dep_time == NA 得到 NA，filter 会忽略\n要检测缺失值要使用is.na()函数，比如：\nis.na(c(TRUE, NA, FALSE))   #&gt; FALSE TRUE FALSE\nis.na(c(1, NA, 3))          #&gt; FALSE TRUE FALSE\nis.na()函数可用于辅助排序：\n# 将 NA 排在前面\nflights |&gt; \n  filter(month == 1, day == 1) |&gt; \n  arrange(desc(is.na(dep_time)), dep_time)",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>逻辑向量</span>"
    ]
  },
  {
    "objectID": "chapters/ch12_logical_vectors.html#布尔代数",
    "href": "chapters/ch12_logical_vectors.html#布尔代数",
    "title": "13  逻辑向量",
    "section": "13.3 布尔代数",
    "text": "13.3 布尔代数\n使用布尔代数可将多个逻辑向量进行组合。\n\n&：与（and）\n|：或（or）\n!：非（not）\nxor()：异或（exclusive or）\n\n\n另外还有&&和||，但它们是短路逻辑操作符，只返回一个布尔值，故适用于编程控制流（如 if 语句），而非数据分析。\n在布尔运算中，与NA相关的运算颇为抽象，如下：\n\nNA | TRUE = TRUE：因为 NA 可能是 TRUE，总有一项为真；\nNA | FALSE = NA：因为结果取决于 NA 的真假，无法确定；\nNA & TRUE = NA：是否为真依赖 NA 的真假，无法确定；\nNA & FALSE = FALSE：一项为假，整体为假。\n\n书写布尔代数表达式时注意不要用日常说话的语序，比如若要筛选11月或12月的航班，错误示例：\nflights |&gt; filter(month == 11 | 12)\n正确写法：\nflights |&gt; filter(month == 11 | month == 12)\n或更推荐：\nflights |&gt; filter(month %in% c(11, 12))\nx %in% y 判断 x 中的每个元素是否在向量 y 中，返回逻辑向量。等价于多个 == 和 | 联合使用，但语法更简洁，逻辑更清晰。比如：\n1:12 %in% c(1, 5, 11)\n#&gt; TRUE FALSE ... TRUE ... TRUE\n同时注意与NA相关的运算，比如：\nc(1, 2, NA) %in% NA\n#&gt; FALSE FALSE TRUE",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>逻辑向量</span>"
    ]
  },
  {
    "objectID": "chapters/ch12_logical_vectors.html#逻辑汇总",
    "href": "chapters/ch12_logical_vectors.html#逻辑汇总",
    "title": "13  逻辑向量",
    "section": "13.4 逻辑汇总",
    "text": "13.4 逻辑汇总\n\n逻辑汇总函数\nany(x) 相当于逻辑“或”，只要 x 中存在任意一个 TRUE 就返回 TRUE。 all(x) 相当于逻辑“与”，只有当 x 中所有值都是 TRUE 时才返回 TRUE。\n数值汇总函数\n逻辑向量在数值情境下会自动转换：TRUE 变成 1，FALSE 变成 0。从而可用sum() 统计 TRUE 的个数，mean() 计算 TRUE 的比例\n逻辑子集筛选\n逻辑向量可以用来对单个变量进行子集筛选，主要利用中括号[]。形如：\narr_delay[arr_delay &lt; 0]",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>逻辑向量</span>"
    ]
  },
  {
    "objectID": "chapters/ch12_logical_vectors.html#条件转换",
    "href": "chapters/ch12_logical_vectors.html#条件转换",
    "title": "13  逻辑向量",
    "section": "13.5 条件转换",
    "text": "13.5 条件转换\n若想在某个条件为 TRUE 时使用一个值，为 FALSE 时使用另一个值时，可以使用 dplyr::if_else()函数。\n主要用 if_else() 前三个参数：\n\ncondition ：逻辑向量；\n&lt;true&gt; ：条件为 TRUE 时输出的值或向量；\n&lt;false&gt; ：条件为 FALSE 时输出的值或向量。\n\n例如：\n&gt; x &lt;- c(-2:2, NA)\n&gt; if_else(x &gt; 0, \"非负\", \"负\")\n[1] \"负\"   \"负\"   \"负\"   \"非负\" \"非负\" NA \n可选的第四个参数称为为 missing，可用自定义值替换NA 值：\n&gt; if_else(x &gt; 0, \"非负\", \"负\", \"secret\")\n[1] \"负\"    \"负\"    \"负\"    \"非负\"  \"非负\"  \"secret\"\n还有一种条理更清晰的函数case_when()，使用方式为：条件 ~ 输出，类似分段函数。\n&gt; case_when(\n+     x == 0   ~ \"0\",\n+     x &lt; 0    ~ \"-\", \n+     x &gt; 0    ~ \"+\",\n+     is.na(x) ~ \"secret\"\n+ )\n[1] \"-\"      \"-\"      \"0\"      \"+\"      \"+\"     \"secret\"\n若想提供默认值，可使用 .default = \"&lt;默认值&gt;\"\n如果有多个条件同时为 TRUE，只会对应第一个匹配的。\n需要注意，TRUE和FALSE对应输出的值必须兼容，比如字符串和数值不兼容。以下为常见的兼容类型：\n\n数值与逻辑向量兼容\n字符串与因子类型兼容\nNA 与所有类型兼容",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>逻辑向量</span>"
    ]
  },
  {
    "objectID": "chapters/ch13_numbers.html",
    "href": "chapters/ch13_numbers.html",
    "title": "14  数值处理",
    "section": "",
    "text": "14.1 引言\n数值向量是数据科学的核心，本章系统学习它们在 R 中的用法。\n本章需要用到以下R包：",
    "crumbs": [
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>数值处理</span>"
    ]
  },
  {
    "objectID": "chapters/ch13_numbers.html#引言",
    "href": "chapters/ch13_numbers.html#引言",
    "title": "14  数值处理",
    "section": "",
    "text": "library(tidyverse)\nlibrary(nycflights13) #航班数据",
    "crumbs": [
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>数值处理</span>"
    ]
  },
  {
    "objectID": "chapters/ch13_numbers.html#创建数值",
    "href": "chapters/ch13_numbers.html#创建数值",
    "title": "14  数值处理",
    "section": "14.2 创建数值",
    "text": "14.2 创建数值\n大多数情况下，数值会以 R 的标准数值类型（如 integer 或 double）形式存在。但有时会遇到字符串形式的数字，可能是从列名透视过来的数据，或者数据导入过程中出现了错误。\nreadr 包提供了两个函数可将字符串转换为数值：parse_double() 和 parse_number()。\n\n如果字符串是纯数字（可含有小数点或科学计数法），使用 parse_double()：\n\nx &lt;- c(\"1.2\", \"5.6\", \"1e3\")\nparse_double(x)\n#&gt; [1]    1.2    5.6 1000.0\n\n如果字符串中包含需忽略的非数字字符（如货币符号或百分号），使用 parse_number()：\n\nx &lt;- c(\"$1,234\", \"USD 3,513\", \"59%\")\nparse_number(x)\n#&gt; [1] 1234 3513   59",
    "crumbs": [
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>数值处理</span>"
    ]
  },
  {
    "objectID": "chapters/ch13_numbers.html#计数",
    "href": "chapters/ch13_numbers.html#计数",
    "title": "14  数值处理",
    "section": "14.3 计数",
    "text": "14.3 计数\n数据分析仅靠简单计数和基础运算就能完成很多工作。因此 dplyr 提供了极为便捷的 count() 函数，能快速在数据分析中统计频次，结果将显示每个目的地（dest）对应的航班数量（n）：\nflights |&gt; count(dest)\n#&gt; # A tibble: 105 × 2\n#&gt;   dest      n\n#&gt;   &lt;chr&gt; &lt;int&gt;\n#&gt; 1 ABQ     254\n#&gt; 2 ACK     265\n#&gt; ...\n\n尽管第 4 章建议分行书写长命令，但 count() 一般用于交互式快速查看，因此常将其写在一行中。\n\n想查看出现次数最多的前几项，可以加上 sort = TRUE：\nflights |&gt; count(dest, sort = TRUE)\n#&gt;   dest      n\n#&gt; 1 ORD   17283\n#&gt; 2 ATL   17215\n#&gt; 3 LAX   16174\n#&gt; ...\n如果想一次性查看全部值，可以使用 flights |&gt; View() 打开交互窗口，或 flights |&gt; print(n = Inf) 输出全部结果。\n除了 count()，也可以手动组合 group_by()、summarize() 和 n() 来完成相同操作。这种方式更灵活，可以同时进行其他统计：\nflights |&gt; \n  group_by(dest) |&gt; \n  summarize(\n    n = n(),\n    delay = mean(arr_delay, na.rm = TRUE)\n  )\n这里 n() 是一个特殊的汇总函数，不需要任何参数，它会统计当前分组的行数。它只能在 dplyr 的函数（如 mutate()、filter()、summarize()）中使用，否则会报错：\nn()\n#&gt; Error: Must only be used inside data-masking verbs like `mutate()`, `filter()`, and `group_by()`.\n另外还有n_distinct(x)函数统计某变量中特定值的数量。例如，想知道哪些目的地有最多航空公司服务，如下可列出各个目的地以及服务它的不同航空公司数量。：\nflights |&gt; \n  group_by(dest) |&gt; \n  summarize(carriers = n_distinct(carrier)) |&gt; \n  arrange(desc(carriers))\n有时还需要对某个变量进行“加权计数”，本质上就是求和。例如，可以统计每架飞机飞行的总里程：\nflights |&gt; \n  group_by(tailnum) |&gt; \n  summarize(miles = sum(distance))\ncount() 函数也支持这种加权方式，通过 wt 参数实现：\nflights |&gt; count(tailnum, wt = distance)\n若要统计缺失值的数量，可以结合 sum() 和 is.na()。比如通过判断出发时间是否缺失，统计每个目的地取消的航班数量：\nflights |&gt; \n  group_by(dest) |&gt; \n  summarize(n_cancelled = sum(is.na(dep_time)))",
    "crumbs": [
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>数值处理</span>"
    ]
  },
  {
    "objectID": "chapters/ch13_numbers.html#数值变换",
    "href": "chapters/ch13_numbers.html#数值变换",
    "title": "14  数值处理",
    "section": "14.4 数值变换",
    "text": "14.4 数值变换\n对于基本运算，R中存在“扩展规则”，当两个向量进行基本运算时，若向量所含元素数目不相同， R 会将少元素向量自动扩展（recycle）与另一向量一样长，从而逐个元素进行计算。举例如下：\nx &lt;- c(1, 2, 10, 20)\nx / 5\n# 等价于\nx / c(5, 5, 5, 5)\n#&gt; [1] 0.2 0.4 2.0 4.0\n只有当较长向量的长度是较短向量的整数倍时才不会报错或发出警告：\nx * c(1, 2)\n#&gt; [1]  1  4 10 40\n\nx * c(1, 2, 3)\n#&gt; Warning: longer object length is not a multiple of shorter\n#&gt; [1]  1  4 30 20\n此规则同样适用于逻辑比较（==、&lt;、!= 等）。如果不小心用 == 代替 %in%，并且数据框的行数刚好是“错误的倍数”，就可能出现悄无声息的逻辑错误：\nflights |&gt; filter(month == c(1, 2))  # 本想选出1月和2月的航班\n这段代码实际上会选出奇数行中 month == 1 的航班、偶数行中 month == 2 的航班，但不会报错！因为 flights 的行数正好是 2 的倍数，自发执行扩展规则。这种“沉默的失败”是数据分析中最难察觉的陷阱之一。\n\n区分==和%in%：\n\n== 是逐个元素一一比较，用于判断两个向量的对应位置元素是否相等：\n\nc(1, 2, 3) == c(2, 3, 4)\n#&gt; [1] FALSE FALSE FALSE\n\n%in% 是用来判断是否属于的：\n\nc(1, 2, 3) %in% c(2, 3, 4)\n#&gt; [1] FALSE  TRUE  TRUE\n\n除了基本运算，还可以用 pmin() 和 pmax() 来逐行求最小值或最大值：\ndf &lt;- tribble(\n  ~x, ~y,\n  1,  3,\n  5,  2,\n  7, NA\n)\n\ndf |&gt; mutate(\n  min = pmin(x, y, na.rm = TRUE),\n  max = pmax(x, y, na.rm = TRUE)\n)\n区别在于：\n\npmin()/pmax()：按行比较返回每行的最小/最大值\nmin()/max()：整体取最小/最大，会返回一个标量\n\n另外，模运算（modular arithmetic）是处理“整除和余数”的工具。在 R 中：\n\n%/% 表示整除，取商\n%% 表示取余\n\n1:10 %/% 3\n#&gt; [1] 0 0 1 1 1 2 2 2 3 3\n\n1:10 %% 3\n#&gt; [1] 1 2 0 1 2 0 1 2 0 1\n以及对数变换，广泛用于：缩放数量级差异较大的数据，或将指数增长转化为线性增长。\nR 提供了三种对数函数：\n\nlog()：自然对数（以 e 为底）\nlog2()：以 2 为底\nlog10()：以 10 为底\n\n对应的反函数：\n\nexp()：log() 的反函数\n2^x、10^x：分别为 log2() 和 log10() 的反函数\n\n要对运算结果进行四舍五入，可使用 round() 函数，默认取整：\nround(123.456)  # [1] 123\n可以用第二个参数 digits 控制小数位数：\nround(123.456, 2)  # 保留两位小数 -&gt; 123.46\nround(123.456, -2) # 取整到百位 -&gt; 100\n注意，R 默认采用“四舍六入，五取偶”的修约策略，如下为例：\n&gt; round(1.35,1)\n[1] 1.4\n&gt; round(1.45,1)\n[1] 1.4\n此外还有：\n\nfloor(x)：向下取整\nceiling(x)：向上取整\n\n这些函数没有 digits 参数，因此要通过缩放再还原的方式控制小数精度：\n# 向下保留两位小数\nfloor(x / 0.01) * 0.01\n# 向上保留两位小数\nceiling(x / 0.01) * 0.01\n可使用 cut() 可以将连续变量划分为多个区间（分箱）：\nx &lt;- c(1, 2, 5, 10, 15, 20)\ncut(x, breaks = c(0, 5, 10, 15, 20))\n#&gt; [1] (0,5]   (0,5]   (0,5]   (5,10]  (10,15] (15,20]\n也可以给每一段设置分段标签：\ncut(x, breaks = c(0, 5, 10, 15, 20), \n    labels = c(\"sm\", \"md\", \"lg\", \"xl\"))\n超出分段范围的值会返回 NA：\nx &lt;- c(1, 2, 5, 10, 15, 30)\ncut(x, breaks = c(0, 5, 10, 15, 20))\n#&gt; [1] (0,5]   (0,5]   (0,5]   (5,10]  (10,15] &lt;NA&gt;   \n还可以通过参数控制区间是否包含端点，如：\n\nright = FALSE 表示区间是 [a, b)\ninclude.lowest = TRUE 表示包括最小值\n\n此外，base R 提供了常见的累积函数：\n\ncumsum()：累加\ncumprod()：累乘\ncummin()：累积最小\ncummax()：累积最大\n\ndplyr 还提供了 cummean() 用于计算累积平均值。\nx &lt;- 1:10\ncumsum(x)\n#&gt; [1] 1 3 6 10 15 21 28 36 45 55\ncummean(x)\n#&gt; [1] 1.0 1.5 2.0 2.5 3.0 3.5 4.0 4.5 5.0 5.5",
    "crumbs": [
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>数值处理</span>"
    ]
  },
  {
    "objectID": "chapters/ch13_numbers.html#通用变换",
    "href": "chapters/ch13_numbers.html#通用变换",
    "title": "14  数值处理",
    "section": "14.5 通用变换",
    "text": "14.5 通用变换\ndplyr 提供了一系列参考 SQL 的排名函数，比如 min_rank()从小到大排名，且处理并列值的方法符合常理。\nx &lt;- c(1, 2, 2, 3, 4, NA)\nmin_rank(x)\n#&gt; [1]  1  2  2  4  5 NA\n若想从大到小，可追加使用 desc(x)：\nmin_rank(desc(x))\n#&gt; [1]  5  3  3  2  1 NA\n还有以下变体函数：\n\nrow_number()：不保留并列，按顺序排名相同值\ndense_rank()：将并列的若干值视为一体，下一个名次不跳号\npercent_rank()：按百分比标准化排名\ncume_dist()：累计分布，表示当前值小于等于多少比例\n\n这些函数的行为类似于 base R 的 rank()，可通过设置 ties.method 和 na.last = \"keep\" 来实现同样的功能。\n此外，在 dplyr 管道中使用 row_number() 不带参数时，表示“当前行号”。结合 %/% 与 %% 可以实现按行号分组，例如：\ndf &lt;- tibble(id = 1:10)\ndf |&gt; mutate(\n  row0 = row_number() - 1,\n  three_groups = row0 %% 3,         # 三组标记（循环编号）\n  three_in_each_group = row0 %/% 3  # 每组3个（等分分组）\n)\nlead()函数可以将当前向量向前移动一定单位，默认1位，加上参数 n 可实现多位偏移； lag()则向后移动。返回向量长度与输入一致，并在开头或结尾填充 NA：\nx &lt;- c(2, 5, 11, 11, 19, 35)\nlag(x)\n#&gt; [1] NA  2  5 11 11 19\nlead(x)\n#&gt; [1]  5 11 11 19 35 NA\n有时需要在满足某个条件时开始新的分组。例如，分析网站访问行为时，若两次访问间隔超过某一阈值（如5分钟），就认为是新的访问会话：\nevents &lt;- tibble(time = c(0, 1, 2, 3, 5, 10, 12, 15, 17, 19, 20, 27, 28, 30))\n\nevents &lt;- events |&gt; mutate(\n  diff = time - lag(time, default = first(time)),\n  has_gap = diff &gt;= 5\n)\n生成的 has_gap 是逻辑值，表示是否存在5分钟间隔。接下来使用 cumsum() 为每段会话生成连续编号：\nevents |&gt; mutate(group = cumsum(has_gap))\n另一个办法是使用 consecutive_id()，此函数给连续的相同元素编相同的号：\ndf &lt;- tibble(\n  x = c(\"a\", \"a\", \"a\", \"b\", \"c\", \"c\", \"d\", \"e\", \"a\", \"a\", \"b\", \"b\"),\n  y = c(1, 2, 3, 2, 4, 1, 3, 9, 4, 8, 10, 199)\n)\n\ndf |&gt; \n  group_by(id = consecutive_id(x)) |&gt; \n  slice_head(n = 1)  # 保留每一组重复元素的第一个\n\n14.5.0.1 13.6 数值函数\n下面总结不同数值函数的用途与适用场景。\n\nmean(): 平均数，对极端值敏感，适合对称分布。\nmedian(): 中位数，不受极端值影响，适合偏态分布。\nmin() / max(): 最小/最大值；\nquantile(x, p): 分位数，常用于排除极端值影响。p取值为[0,1]。\nsd(x): 标准差，衡量总体波动。\nIQR(x): 四分位距 = Q3 - Q1，衡量中间 50% 数据的跨度。\nfirst(x) / last(x) / nth(x, n): 提取每组数据中的第一个、最后一个、第 n 个元素。支持以下参数：\n\nna_rm = TRUE：跳过缺失值；\ndefault = ...：位置不存在时提供默认值；\norder_by = ...：更改排序方式；\n\n\n以上函数不仅用于 summarize()，也常用于 mutate() 实现标准化变换：\n\n\n\n变换形式\n效果\n\n\n\n\nx / sum(x)\n转换为比例\n\n\n(x - mean(x)) / sd(x)\n转换为标准分数（Z-score）\n\n\n(x - min(x)) / (max(x) - min(x))\n归一化到 [0, 1]\n\n\nx / first(x)\n转换为指数增长（以首值为基准）",
    "crumbs": [
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>数值处理</span>"
    ]
  },
  {
    "objectID": "chapters/ch14_strings.html",
    "href": "chapters/ch14_strings.html",
    "title": "15  字符串处理",
    "section": "",
    "text": "15.1 引言\n本章深入介绍如何创建、处理和提取字符串，重点使用 stringr 包（属于tidyverse）提供的一系列以 str_ 开头的函数。\n本章需要用到以下R包：",
    "crumbs": [
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>字符串处理</span>"
    ]
  },
  {
    "objectID": "chapters/ch14_strings.html#引言",
    "href": "chapters/ch14_strings.html#引言",
    "title": "15  字符串处理",
    "section": "",
    "text": "ibrary(tidyverse)\nlibrary(babynames)  # 婴儿名字数据",
    "crumbs": [
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>字符串处理</span>"
    ]
  },
  {
    "objectID": "chapters/ch14_strings.html#创建字符串",
    "href": "chapters/ch14_strings.html#创建字符串",
    "title": "15  字符串处理",
    "section": "15.2 创建字符串",
    "text": "15.2 创建字符串\n字符串可使用单引号或双引号创建，一般情况建议统一使用双引号：\nstring1 &lt;- \"This is a string\"\nstring2 &lt;- 'Use single quotes if the string contains \"quotes\"'\n若未闭合引号，控制台将显示 + 作为继续提示，按 Esc 可退出。\n若字符串中包含引号或反斜杠 \\，需使用转义字符：\ndouble_quote &lt;- \"\\\"\"  # 双引号\nsingle_quote &lt;- '\\''  # 单引号\nbackslash &lt;- \"\\\\\"     # 反斜杠\n注意：R 打印时会自动显示转义字符，但真实内容并不包含它们。可以使用 str_view() 查看，显示的是实际字符，而不是转义形式：\nx &lt;- c(single_quote, double_quote, backslash)\nstr_view(x)\n[1] │ '\n[2] │ \"\n[3] │ \\\n另有其他转义符如下：\n\n\n\n转义序列\n含义\n\n\n\n\n\\n\n换行符\n\n\n\\t\n制表符\n\n\n\\uXXXX\nUnicode 字符\n\n\n\nx &lt;- c(\"one\\ntwo\", \"one\\ttwo\", \"\\u00b5\", \"\\U0001f604\")\nstr_view(x)\n[1] │ one\n    │ two\n[2] │ one{\\t}two\n[3] │ µ\n[4] │ 😄\n\n其中 {} 是 str_view() 用来清晰显示不可见字符（如 tab）的可视化处理方式。\n\n字符串中若包含大量引号或反斜杠（如嵌入代码片段），会出现所谓“倾斜牙签综合征”（leaning toothpick syndrome），即转义符过多导致难以阅读。可用原始字符串语法解决。\n原始字符串以 r\"()\" 包裹，括号内部的转义符失效。如 \\n 不会被解释为换行，而是字面意义上的两个字符。但是若内容中包含 )\"，仍需规避，可使用 r\"[]\"、r\"{}\" 或r\"---()---\"，提高灵活性。",
    "crumbs": [
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>字符串处理</span>"
    ]
  },
  {
    "objectID": "chapters/ch14_strings.html#构造字符串",
    "href": "chapters/ch14_strings.html#构造字符串",
    "title": "15  字符串处理",
    "section": "15.3 构造字符串",
    "text": "15.3 构造字符串\nstr_c()函数用于拼接字符串。它可接收若干向量作为参数，返回一个字符向量。例如：\nstr_c(\"x\", \"y\", \"z\")           # \"xyz\"\nstr_c(\"Hello \", c(\"John\", \"Susan\"))\n#&gt; \"Hello John\" \"Hello Susan\"\nstr_c(c(\"Hello \",\"Hi \"), c(\"John\", \"Susan\"))\n#&gt; \"Hello John\" \"Hi Susan\"  \n适用于mutate()，且合理处理缺失值 NA：\ndf &lt;- tibble(name = c(\"Flora\", \"David\", \"Terra\", NA))\ndf |&gt; mutate(greeting = str_c(\"Hi \", name, \"!\"))\n#&gt; name    greeting\n#&gt; Flora   Hi Flora!\n#&gt; David   Hi David!\n#&gt; Terra   Hi Terra!\n#&gt; NA      NA\ncoalesce() 函数可以用自定义值替换缺失值：\ndf |&gt; \n  mutate(\n    greeting1 = str_c(\"Hi \", coalesce(name, \"you\"), \"!\"),\n    greeting2 = coalesce(str_c(\"Hi \", name, \"!\"), \"Hi!\")\n  )\n\ngreeting1：缺失值用 \"you\" 代替，结果是 \"Hi you!\"\ngreeting2：拼接结果为 NA 时整体替换为 \"Hi!\"\n\n使用 str_c() 拼接多个变量和文字，会写很多 \" 和 ,，可读性差。这时可以使用 glue 包提供的 str_glue() 函数：\ndf |&gt; mutate(greeting = str_glue(\"Hi {name}!\"))\n#&gt; Flora   Hi Flora!\n#&gt; David   Hi David!\n#&gt; NA      Hi NA!\n\n{} 中嵌入变量名\n缺失值会被转为字符串 \"NA\"（注意与 str_c() 会生成 NA不同）\n\n如果要在字符串中保留大括号 {} 本身，需要使用双大括号转义：\nstr_glue(\"{{Hi {name}!}}\")\n#&gt; \"{Hi Flora!}\" ...\n在 summarize() 中将多个字符串合并，使用 str_flatten()。\nstr_flatten(c(\"x\", \"y\", \"z\"))                      # \"xyz\"\nstr_flatten(c(\"x\", \"y\", \"z\"), \", \")                # \"x, y, z\"\nstr_flatten(c(\"x\", \"y\", \"z\"), \", \", last = \", and \")\n#&gt; \"x, y, and z\"",
    "crumbs": [
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>字符串处理</span>"
    ]
  },
  {
    "objectID": "chapters/ch14_strings.html#从字符串中提取数据",
    "href": "chapters/ch14_strings.html#从字符串中提取数据",
    "title": "15  字符串处理",
    "section": "15.4 从字符串中提取数据",
    "text": "15.4 从字符串中提取数据\n工作中经常会遇到多个变量挤在一个字符串中的情况。tidyr 提供了四个主力函数来提取这些变量：\nseparate_longer_delim()      # 按分隔符拆分为多行\nseparate_longer_position()   # 按固定宽度拆分为多行\nseparate_wider_delim()       # 按分隔符拆分为多列\nseparate_wider_position()    # 按固定宽度拆分为多列\n\nlonger → 把一列拆成多行\nwider → 把一列拆成多列\ndelim → 用分隔符\nposition → 用固定宽度\n\n拆成多行适用于每行元素个数不固定的情况。\ndf1 &lt;- tibble(x = c(\"a,b,c\", \"d,e\", \"f\"))\ndf1 |&gt; \n  separate_longer_delim(x, delim = \",\")\n#&gt; # A tibble: 6 × 1\n#&gt;   x    \n#&gt;   &lt;chr&gt;\n#&gt; 1 a    \n#&gt; 2 b    \n#&gt; 3 c    \n#&gt; 4 d    \n#&gt; 5 e    \n#&gt; 6 f\n拆成多列适用于每个字符串的成分数固定，且需要展开为多个列的情况。\ndf3 &lt;- tibble(x = c(\"a10.1.2022\", \"b10.2.2011\", \"e15.1.2015\"))\ndf3 |&gt; \n  separate_wider_delim(\n    x,\n    delim = \".\",\n    names = c(\"code\", \"edition\", \"year\")\n  )\n#&gt; # A tibble: 3 × 3\n#&gt;   code  edition year \n#&gt;   &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;\n#&gt; 1 a10   1       2022 \n#&gt; 2 b10   2       2011 \n#&gt; 3 e15   1       2015\n如果某一部分不需要保留，用 NA 占位即可：\ndf3 |&gt; \n  separate_wider_delim(\n    x,\n    delim = \".\",\n    names = c(\"code\", NA, \"year\")\n  )\n#&gt; # A tibble: 3 × 2\n#&gt;   code  year \n#&gt;   &lt;chr&gt; &lt;chr&gt;\n#&gt; 1 a10   2022 \n#&gt; 2 b10   2011 \n#&gt; 3 e15   2015\n有时警告拆分失败，需要进行排查。\n\n组件数量不足（too few）\n\ndf &lt;- tibble(x = c(\"1-1-1\", \"1-1-2\", \"1-3\", \"1-3-2\", \"1\"))\n\ndf |&gt; separate_wider_delim(\n  x,\n  delim = \"-\",\n  names = c(\"x\", \"y\", \"z\")\n)\n出现报错：某些行只有1或2个字段，不足3个。\n使用 too_few = \"debug\" 进入调试模式：\ndebug &lt;- df |&gt; \n  separate_wider_delim(\n    x,\n    delim = \"-\",\n    names = c(\"x\", \"y\", \"z\"),\n    too_few = \"debug\"\n  )\n#&gt; Warning: Debug mode activated: adding variables `x_ok`, `x_pieces`, and\n#&gt; `x_remainder`.\ndebug\n# A tibble: 5 × 6\n  x     y     z     x_ok  x_pieces x_remainder\n  &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;lgl&gt;    &lt;int&gt; &lt;chr&gt;      \n1 1-1-1 1     1     TRUE         3 \"\"         \n2 1-1-2 1     2     TRUE         3 \"\"         \n3 1-3   3     NA    FALSE        2 \"\"         \n4 1-3-2 3     2     TRUE         3 \"\"         \n5 1     NA    NA    FALSE        1 \"\"         \n新增列说明：\n\nx_ok：是否符合预期\nx_pieces：实际字段数量\nx_remainder：剩余没分配的部分（对 too_many 更有用）\n\n可以用 filter(!x_ok) 快速筛出异常行。\n若只是想补齐 NA 继续处理，可使用：\ntoo_few = \"align_start\" # 从左对齐，补 NA 到右边\ntoo_few = \"align_end\"   # 从右对齐，补 NA 到左边\n\n组件过多（too many）\n\ndf &lt;- tibble(x = c(\"1-1-1\", \"1-1-2\", \"1-3-5-6\", \"1-3-2\", \"1-3-5-7-9\"))\n\ndf |&gt; separate_wider_delim(\n  x,\n  delim = \"-\",\n  names = c(\"x\", \"y\", \"z\")\n)\n同样报错：有行多于3个字段。\n使用 too_many = \"debug\"开启调试：\ndebug &lt;- df |&gt; separate_wider_delim(\n  x,\n  delim = \"-\",\n  names = c(\"x\", \"y\", \"z\"),\n  too_many = \"debug\"\n)\ndebug\n# A tibble: 5 × 6\n  x         y     z     x_ok  x_pieces x_remainder\n  &lt;chr&gt;     &lt;chr&gt; &lt;chr&gt; &lt;lgl&gt;    &lt;int&gt; &lt;chr&gt;      \n1 1-1-1     1     1     TRUE         3 \"\"         \n2 1-1-2     1     2     TRUE         3 \"\"         \n3 1-3-5-6   3     5     FALSE        4 \"-6\"       \n4 1-3-2     3     2     TRUE         3 \"\"         \n5 1-3-5-7-9 3     5     FALSE        5 \"-7-9\"   \n可观察 x_remainder 中存放了多余部分。\n处理方法：\n\ntoo_many = \"drop\"：多余字段丢弃\ntoo_many = \"merge\"：合并多余字段到最后一列",
    "crumbs": [
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>字符串处理</span>"
    ]
  },
  {
    "objectID": "chapters/ch14_strings.html#字母与子串处理",
    "href": "chapters/ch14_strings.html#字母与子串处理",
    "title": "15  字符串处理",
    "section": "15.5 字母与子串处理",
    "text": "15.5 字母与子串处理\n本节介绍处理字符串中字母的基本函数。\n\nstr_length()函数用于返回字符串的字符个数（包括空格和标点）：\n\nstr_length(c(\"a\", \"R for data science\", NA))\n#&gt; [1]  1 18 NA\n例如要统计小孩名字长度，并查看最长的名字：\nbabynames |&gt;\n  count(length = str_length(name), wt = n)\nbabynames |&gt; \n  filter(str_length(name) == 15) |&gt; \n  count(name, wt = n, sort = TRUE)\n\nstr_sub()函数用于提取子串，基本参数如下：\n\nstr_sub(string, start, end)\n\n起始位置 start 和结束位置 end 为闭区间\n支持负数索引：-1 表示最后一个字符，-2 为倒数第二个，以此类推\n\n示例：\nx &lt;- c(\"Apple\", \"Banana\", \"Pear\")\nstr_sub(x, 1, 3)\n#&gt; [1] \"App\" \"Ban\" \"Pea\"\nstr_sub(x, -3, -1)\n#&gt; [1] \"ple\" \"ana\" \"ear\"\n如果长度不足，函数会尽量返回可取部分，而不会报错：\nstr_sub(\"a\", 1, 5)\n#&gt; [1] \"a\"\n例如要提取名字首字母与尾字母\nbabynames |&gt; \n  mutate(\n    first = str_sub(name, 1, 1),\n    last = str_sub(name, -1, -1)\n  )",
    "crumbs": [
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>字符串处理</span>"
    ]
  },
  {
    "objectID": "chapters/ch14_strings.html#非英文文本处理",
    "href": "chapters/ch14_strings.html#非英文文本处理",
    "title": "15  字符串处理",
    "section": "15.6 非英文文本处理",
    "text": "15.6 非英文文本处理\n之前的内容主要处理英文文本。因为英文相对简单，原因有二：\n\n英文只有26个基础字母；\n计算机编码标准（如 ASCII）是由英语国家设计的，更偏向英文语境。\n\n处理非英语文本难免遇到意料之外的难题，包括字符编码问题、带变音符的字母、地区敏感的字符串排序与大小写转换。\n\n字符编码\n\n字符编码决定了字符如何在底层以数字（字节）表示。\ncharToRaw(\"Hadley\")\n#&gt; [1] 48 61 64 6c 65 79\n这是 ASCII 编码，每个字符一个字节（如 48 对应 H）。\n如今通用编码是 UTF-8，可表达几乎所有语言的字符与表情符号（emoji）\n读取非UTF-8编码数据：\nread_csv(x1, locale = locale(encoding = \"Latin1\"))\nread_csv(x2, locale = locale(encoding = \"Shift-JIS\"))\n如何判断编码？\n使用 guess_encoding() 可自动推测，建议在字符量较大的文本上使用。\n\n若文本打印乱码（比如所谓“锟斤拷”），通常就是编码不匹配。\n\n\n字母变体\n\n带变音符的字母（如 ü）可能存在两种编码方式：\n\n单字符（预组合）：\\u00fc\n双字符（分解组合）：\"u\" + \"\\u0308\"\n\nu &lt;- c(\"\\u00fc\", \"u\\u0308\")\nstr_length(u)\n#&gt; [1] 1 2\nstr_sub(u, 1, 1)\n#&gt; [1] \"ü\" \"u\"\n可见虽然视觉上一样，但实际上字符长度、内容不同。\n\n函数的地区敏感性\n\nlocale（语言-地区标识）会影响大小写转换与排序函数。此处不作赘述。",
    "crumbs": [
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>字符串处理</span>"
    ]
  },
  {
    "objectID": "chapters/ch15_regular_expressions.html",
    "href": "chapters/ch15_regular_expressions.html",
    "title": "16  正则表达式",
    "section": "",
    "text": "16.1 引言\n正则表达式是一种描述字符串模式的简洁且常用的语言。简称为 regex 或 regexp。\n本章要用到的包如下：\n要用到以下三个 R 自带的字符串：",
    "crumbs": [
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>正则表达式</span>"
    ]
  },
  {
    "objectID": "chapters/ch15_regular_expressions.html#引言",
    "href": "chapters/ch15_regular_expressions.html#引言",
    "title": "16  正则表达式",
    "section": "",
    "text": "library(tidyverse)\nlibrary(babynames) #包含婴儿名字数据\n\n\nfruit：80 种水果；\nwords：980 个英文常见词；\nsentences：720 个简短英文句子。",
    "crumbs": [
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>正则表达式</span>"
    ]
  },
  {
    "objectID": "chapters/ch15_regular_expressions.html#基础模式",
    "href": "chapters/ch15_regular_expressions.html#基础模式",
    "title": "16  正则表达式",
    "section": "16.2 基础模式",
    "text": "16.2 基础模式\nstr_view() 是学习 regex 的利器。它可以可视化匹配内容，将匹配的部分用 &lt; &gt; 包裹并高亮。以下对常见字符进行逐个说明。\n\n最简单的正则表达式是字母或数字，直接匹配对应字符，称为字面匹配（Literal Match）：\n\nstr_view(fruit, \"berry\")\n某些符号（如 .、+、*、[ ]、? 等）具有特殊含义，称为元字符（metacharacters）。\n\n. 匹配任意单字符：\n\nstr_view(fruit, \"a...e\")  # 匹配“a开头，后跟任意三个字符，e结尾”的词\n\n下面三个符号称为量词（Quantifiers），匹配指定字符若干次：\n\n\n\n\n符号\n含义\n\n\n\n\n?\n匹配 0 或 1 次（可选）\n\n\n+\n匹配 ≥1 次（至少一次）\n\n\n*\n匹配 ≥0 次（可选+可重复）\n\n\n\n# ab? 表示匹配一个a，后可加可不加一个b\nstr_view(c(\"a\", \"ab\", \"abb\"), \"ab?\")\n#&gt; [1] │ &lt;a&gt;\n#&gt; [2] │ &lt;ab&gt;\n#&gt; [3] │ &lt;ab&gt;b\n\n# ab+ 表示匹配一个a，后加至少一个b\nstr_view(c(\"a\", \"ab\", \"abb\"), \"ab+\")\n#&gt; [2] │ &lt;ab&gt;\n#&gt; [3] │ &lt;abb&gt;\n\n# ab* 表示匹配一个a，后加任意数目的b（可无b）\nstr_view(c(\"a\", \"ab\", \"abb\"), \"ab*\")\n#&gt; [1] │ &lt;a&gt;\n#&gt; [2] │ &lt;ab&gt;\n#&gt; [3] │ &lt;abb&gt;\n\n[] 称为字符类（Character Classes），指定匹配多个字符之一：\n\n[abcd]   # 匹配 a 或 b 或 c 或 d\n[^abcd]  # 匹配不含 a/b/c/d 字符\n示例：寻找中间是 x 且两边为元音的词：\nstr_view(words, \"[aeiou]x[aeiou]\")\n\n| 称为操作符（Alternation），表示多个可选模式：\n\nstr_view(fruit, \"apple|melon|nut\")\n示例：匹配含有指定关键词的水果：\npine&lt;apple&gt;, rock &lt;melon&gt;, coco&lt;nut&gt;",
    "crumbs": [
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>正则表达式</span>"
    ]
  },
  {
    "objectID": "chapters/ch15_regular_expressions.html#关键函数",
    "href": "chapters/ch15_regular_expressions.html#关键函数",
    "title": "16  正则表达式",
    "section": "16.3 关键函数",
    "text": "16.3 关键函数\n在掌握正则基础之后，可结合函数进行实用数据处理。\n\n检测匹配\n\nstr_detect() 函数返回逻辑向量，判断字符串中是否匹配某个正则模式。\nstr_detect(c(\"a\", \"b\", \"c\"), \"[aeiou]\")\n#&gt; [1] TRUE FALSE FALSE\n常与 filter() 结合使用，示例：查找包含小写 “x” 的人名并按使用次数降序排列：\nbabynames |&gt; \n  filter(str_detect(name, \"x\")) |&gt; \n  count(name, wt = n, sort = TRUE)\n#&gt; # A tibble: 974 × 2\n#&gt;   name           n\n#&gt;   &lt;chr&gt;      &lt;int&gt;\n#&gt; 1 Alexander 665492\n#&gt; 2 Alexis    399551\n#&gt; 3 Alex      278705\n#&gt; 4 Alexandra 232223\n#&gt; 5 Max       148787\n#&gt; 6 Alexa     123032\n#&gt; # ℹ 968 more rows\n可以将 str_detect() 与 summarize() 结合使用，通过 sum() 或 mean() 来统计匹配情况：\n\nsum(str_detect(x, pattern))：返回匹配该正则表达式的观测值总数（即有多少个元素匹配）；\nmean(str_detect(x, pattern))：返回匹配比例，即匹配元素占所有元素的百分比。\n\n例如，以下代码统计并可视化了每年中包含字母 “x” 的婴儿名字所占的比例：\nbabynames |&gt; \n  group_by(year) |&gt; \n  summarize(prop_x = mean(str_detect(name, \"x\"))) |&gt; \n  ggplot(aes(year, prop_x)) + \n  geom_line()\n\n\n计数匹配\n\nstr_count() 返回每个字符串中匹配模式出现的次数：\nx &lt;- c(\"apple\", \"banana\", \"pear\")\nstr_count(x, \"p\")\n#&gt; [1] 2 0 1\n需要注意，匹配的字段之间是不重叠计算的：\nstr_count(\"abababa\", \"aba\")\n#&gt; [1] 2\n示例：统计人名中的元音和辅音数量\nbabynames |&gt; \n  count(name) |&gt; \n  mutate(\n    vowels = str_count(name, \"[aeiou]\"),\n    consonants = str_count(name, \"[^aeiou]\")\n  )\n上例结果偏小，因为正则默认区分大小写，可通过以下方式修正：\n\n同时匹配大写字符：\"[aeiouAEIOU]\"\n忽略大小写：regex(\"[aeiou]\", ignore_case = TRUE)\n预处理为小写：str_to_lower(name)\n\n\n替换值\n\n使用 str_replace() 和 str_replace_all() 替换匹配的文本：\nx &lt;- c(\"apple\", \"pear\", \"banana\")\nstr_replace_all(x, \"[aeiou]\", \"-\")\n#&gt; [1] \"-ppl-\"  \"p--r\"   \"b-n-n-\"\n删除匹配的内容可用 str_remove() / str_remove_all()：\ntr_remove_all(x, \"[aeiou]\")\n#&gt; [1] \"ppl\" \"pr\"  \"bnn\"\n这些函数常用于 mutate() 中进行数据清洗，通常需要多次重复处理以处理格式不一致的情况。\n\n提取变量\n\n使用 separate_wider_regex() 可将结构化的字符串拆成多列。\n示例数据：\ndf &lt;- tribble(\n  ~str,\n  \"&lt;Sheryl&gt;-F_34\",\n  \"&lt;Kisha&gt;-F_45\", \n  \"&lt;Brandon&gt;-N_33\",\n  \"&lt;Sharon&gt;-F_38\", \n  \"&lt;Penny&gt;-F_58\",\n  \"&lt;Justin&gt;-M_41\", \n  \"&lt;Patricia&gt;-F_84\"\n)\n提取其中的人名、性别和年龄：\ndf |&gt; \n  separate_wider_regex(\n    str,\n    patterns = c(\n      \"&lt;\", \n      name = \"[A-Za-z]+\", \n      \"&gt;-\", \n      gender = \".\", \n      \"_\", \n      age = \"[0-9]+\"\n    )\n  )\n结果：\n# A tibble: 7 × 3\n  name      gender age  \n  &lt;chr&gt;     &lt;chr&gt;  &lt;chr&gt;\n1 Sheryl    F      34   \n2 Kisha     F      45   \n3 Brandon   N      33   \n4 Sharon    F      38   \n5 Penny     F      58   \n6 Justin    M      41   \n7 Patricia  F      84\n\n使用 too_few = \"debug\" 可以定位匹配失败的原因。",
    "crumbs": [
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>正则表达式</span>"
    ]
  },
  {
    "objectID": "chapters/ch15_regular_expressions.html#模式细节",
    "href": "chapters/ch15_regular_expressions.html#模式细节",
    "title": "16  正则表达式",
    "section": "16.4 模式细节",
    "text": "16.4 模式细节\n\n转义（Escaping）\n\n像字符串一样，正则表达式使用反斜杠 \\ 进行转义。所以，为了匹配字面上的 .，需要使用正则表达式 \\.。问题在于，我们是用字符串来表示正则表达式的，而字符串中 \\ 同样是转义符。因此，要表示正则表达式 \\.，需要写成字符串 \"\\\\.\"。我将此总结为“嵌套式双重转义”。如下为例：\ndot &lt;- \"\\\\.\"\nstr_view(dot) \n#&gt; [1] │ \\.\n\nstr_view(c(\"abc\", \"a.c\", \"bef\"), \"a\\\\.c\")  # 匹配字面值 a.c\n#&gt; [2] │ &lt;a.c&gt;\n若要匹配字面上的 \\ 本身，同样需要进行转义，即正则表达式为 \\\\。由于字符串中也需转义 \\，所以最终写法是 \"\\\\\\\\\"，即 4 个反斜杠代表一个字面上的 \\：\nx &lt;- \"a\\\\b\"\nstr_view(x)\n#&gt; [1] │ a\\b\n\nstr_view(x, \"\\\\\\\\\")\n#&gt; [1] │ a&lt;\\&gt;b\n为避免多重嵌套转义的混乱，也可以使用原始字符串语法：\nstr_view(x, r\"{\\\\}\")\n#&gt; [1] │ a&lt;\\&gt;b\n此外，对于诸如 .、$、|、*、+、 ?、 {、}、(、 ) 等特殊字符，也可使用字符类 [.]、[$] 等方式表示其字面值：\nstr_view(c(\"abc\", \"a.c\", \"a*c\", \"a c\"), \"a[.]c\")\n#&gt; [2] │ &lt;a.c&gt;\n\nstr_view(c(\"abc\", \"a.c\", \"a*c\", \"a c\"), \".[*]c\")\n#&gt; [3] │ &lt;a*c&gt;\n\n锚点（Anchors）\n\n默认情况下，正则表达式会匹配字符串中的任意部分。若希望仅匹配字符串开头或结尾，可使用锚点 ^（匹配开头）和 $（匹配结尾）：\nstr_view(fruit, \"^a\")   # 以a开头的字符串\n#&gt; [1] │ &lt;a&gt;pple\n#&gt; [2] │ &lt;a&gt;pricot\n#&gt; [3] │ &lt;a&gt;vocado\n\nstr_view(fruit, \"a$\")   # 以a结尾的字符串\n#&gt; [4] │ banan&lt;a&gt;\n#&gt; [15] │ cherimoy&lt;a&gt;\n#&gt; ...\n\n虽然 $ 常被用在金额表示中放在前面，但在正则中，它表示结尾。\n\n若希望整个字符串完全匹配某模式，同时使用 ^ 与 $即可：\nstr_view(fruit, \"apple\")\n#&gt; [1] │ &lt;apple&gt;\n#&gt; [62] │ pine&lt;apple&gt;\nstr_view(fruit, \"^apple$\")\n#&gt; [1] │ &lt;apple&gt;\n\\b 可用于匹配单词边界（即单词的开头或结尾），常用于避免误匹配。例如搜索 sum() 时避免匹配 summary、rowsum 等：\nx &lt;- c(\"summary(x)\", \"summarize(df)\", \"rowsum(x)\", \"sum(x)\")\nstr_view(x, \"\\\\bsum\\\\b\") # 注意转义\n#&gt; [4] │ &lt;sum&gt;(x)\n锚点本身是零宽度匹配：\nstr_view(\"abc\", c(\"$\", \"^\", \"\\\\b\"))\n#&gt; [1] │ abc&lt;&gt;\n#&gt; [2] │ &lt;&gt;abc\n#&gt; [3] │ &lt;&gt;abc&lt;&gt;\n\n字符类（Character Classes）\n\n字符类用于匹配集合中的任一字符。可用 [] 来构造，例如 [abc] 匹配 a、b 或 c，[^abc] 匹配除这三者外的任意字符。在 [] 内部，除 ^ 外，还有两个具有特殊含义的字符：\n\n- 表示范围，如 [a-z] 表示小写字母，[0-9] 表示数字；\n\\ 用于转义特殊字符，如 [\\^\\-\\]] 匹配 ^、-、]。\n\n常见的字符类还有简写形式：\n\n\\d：数字，\\D：非数字；\n\\s：空白字符，\\S：非空白；\n\\w：字母或数字，\\W：非字母或数字。\n\n\n量词（Quantifiers）\n\n量词控制某模式匹配的次数。 ?（0 或 1 次）、+（1 次或多次）、*（0 次或多次）。此外，{} 可指定更精确的匹配次数：\n\n{n}：恰好匹配 n 次；\n{n,}：至少 n 次；\n{n,m}：匹配 n 到 m 次之间。\n\n\n运算符优先级与括号\n\n表达式 ab+ 是匹配 “a” 后接多个 “b”，还是多次匹配 “ab”？表达式 ^a|b$ 是匹配 “完整的 a 或 b”，还是 “以 a 开头或以 b 结尾”？\n这取决于运算符优先级，就像算术中乘除优先加减一样。正则表达式中，量词优先级高，| 优先级低。因此：\n\nab+ 等价于 a(b+)；\n^a|b$ 等价于 (^a)|(b$)。\n\n为了避免歧义，建议使用括号明确结构。\n\n分组与捕获（Grouping and Capturing）\n\n括号不仅可以控制优先级，还能创建“捕获组”（capturing group），形如(...)，以便在后续使用匹配子模式的结果。\n\\1 表示与第一个括号的内容相同，\\2 表示第二个，以此类推：\nstr_view(fruit, \"(..)\\\\1\") # 找出两个连续字符重复的单词\n#&gt; banana, coconut, cucumber, etc.\n\nstr_view(words, \"^(..).*\\\\1$\") # 找出首尾两个字符一样的单词\n#&gt; church, decide, photograph, etc.\n可以在 str_replace() 中使用捕获组交换位置。例如将一句话第二个词和第三个词调个顺序：\nsentences |&gt;\n  str_replace(\"(\\\\w+) (\\\\w+) (\\\\w+)\", \"\\\\1 \\\\3 \\\\2\") |&gt;\n  str_view()\n\nw+表示字母或数字类\n\n若要提取每个组的匹配结果，使用 str_match()：\nstr_match(\"the (\\\\w+) (\\\\w+)\") \n除了捕获组，还可使用非捕获组，形如 (?:...)，只用于匹配，不保存匹配内容，不会出现在 \\\\1 里。\nstr_match(x, \"gr(?:e|a)y\")\n#&gt; \"gray\", \"grey\"",
    "crumbs": [
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>正则表达式</span>"
    ]
  },
  {
    "objectID": "chapters/ch15_regular_expressions.html#模式控制",
    "href": "chapters/ch15_regular_expressions.html#模式控制",
    "title": "16  正则表达式",
    "section": "16.5 模式控制",
    "text": "16.5 模式控制\n有一些设置可以用来调整正则表达式的细节，这在其他语言中通常被称为 flags（标志）。可以通过 regex() 函数将字符串包裹起来来使用这些设置。\n最常用的标志有：\n\nignore_case = TRUE：忽略大小写\n\nbananas &lt;- c(\"banana\", \"Banana\", \"BANANA\")\nstr_view(bananas, \"banana\")\n#&gt; 只匹配 \"banana\"\nstr_view(bananas, regex(\"banana\", ignore_case = TRUE))\n#&gt; 同时匹配 banana、Banana 和 BANANA\n\ndotall = TRUE：让 . 匹配换行符（\\n）\n\nx &lt;- \"Line 1\\nLine 2\\nLine 3\"\nstr_view(x, \".Line\") \nstr_view(x, regex(\".Line\", dotall = TRUE))\n\n下面一行的代码将正则表达式 .Line 改写为允许点号 . 匹配换行符，即让点号真正变成“匹配任意字符（包括换行）”。这样就能跨越行与行之间的 \\n，成功匹配 \\nL 这种中间有换行的情况。\n\n\nmultiline = TRUE：让 ^ 和 $ 匹配每一行的开头和结尾。\n\nx &lt;- \"Line 1\\nLine 2\\nLine 3\"\nstr_view(x, \"^Line\")  # 默认只匹配第一行\nstr_view(x, regex(\"^Line\", multiline = TRUE))\n#&gt; 匹配每一行的 Line\n\ncomments = TRUE：允许使用空格和注释来增强可读性\n\n可以在正则表达式中添加空格和 # 注释来解释每一部分。这些空格默认会被忽略，如要匹配空格或 #，则需使用反斜杠转义。\nphone &lt;- regex(\n  r\"(\n    \\(?     # 可选的左括号\n    (\\d{3}) # 三位区号\n    [)\\-]?  # 可选的右括号或短横线\n    \\ ?     # 可选空格\n    (\\d{3}) # 三位号码\n    [\\ -]?  # 可选空格或短横线\n    (\\d{4}) # 四位号码\n  )\",\n  comments = TRUE\n)\n\nstr_extract(c(\"514-791-8141\", \"(123) 456 7890\", \"123456\"), phone)\n#&gt; 提取出电话号码\n除了 regex() 函数包裹的标志设置，还可以通过 fixed() 函数来关闭正则表达式的规则，直接按字面意义匹配：\nstr_view(c(\"\", \"a\", \".\"), fixed(\".\"))\n#&gt; 只匹配真正的 “.” 字符\n也可以配合 ignore_case = TRUE 忽略大小写：\nstr_view(\"x X\", fixed(\"X\", ignore_case = TRUE))\n#&gt; 匹配 x 和 X\nstr_view(\"i İ ı I\", fixed(\"İ\", ignore_case = TRUE))\n#&gt; 在默认",
    "crumbs": [
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>正则表达式</span>"
    ]
  },
  {
    "objectID": "chapters/ch16_factors.html",
    "href": "chapters/ch16_factors.html",
    "title": "17  因子",
    "section": "",
    "text": "17.1 引言\n因子用于表示分类变量，即具有固定且已知取值范围的变量。\nforcats从属于tidyverse，是专为分类变量设计的R包，提供了多种因子操作辅助函数。",
    "crumbs": [
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>因子</span>"
    ]
  },
  {
    "objectID": "chapters/ch16_factors.html#引言",
    "href": "chapters/ch16_factors.html#引言",
    "title": "17  因子",
    "section": "",
    "text": "library(tidyverse)",
    "crumbs": [
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>因子</span>"
    ]
  },
  {
    "objectID": "chapters/ch16_factors.html#因子基础",
    "href": "chapters/ch16_factors.html#因子基础",
    "title": "17  因子",
    "section": "17.2 因子基础",
    "text": "17.2 因子基础\n假设存在一个记录月份的变量x1：\nx1 &lt;- c(\"Dec\", \"Apr\", \"Jan\", \"Mar\")\n用字符串记录这个变量存在两个问题：\n\n月份的取值本应限制在 12 个固定值内，但并不会提示可能存在的拼写错误。\n字符串排序方式不符合月份实际顺序。\n\n可以通过因子修正这两个问题。首先定义合法取值（即因子水平）：\nmonth_levels &lt;- c(\n  \"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\",\n  \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"\n)\n然后创建因子：\ny1 &lt;- factor(x1, levels = month_levels)\ny1\n#&gt; [1] Dec Apr Jan Mar\n#&gt; Levels: Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec\n\nsort(y1)\n#&gt; [1] Jan Mar Apr Dec\n#&gt; Levels: Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec\n所有不在指定水平中的值都会自动转换为 NA：\ny2 &lt;- factor(x2, levels = month_levels)\ny2\n#&gt; [1] Dec  Apr  &lt;NA&gt; Mar \n#&gt; Levels: Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec\n为避免静默失败，可使用 forcats::fct() 这一强校验函数，防止因粗心导致数据缺失而不自知：\ny2 &lt;- fct(x2, levels = month_levels)\n#&gt; Error in `fct()`:\n#&gt; ! All values of `x` must appear in `levels` or `na`\n#&gt; ℹ Missing level: \"Jam\"\n如果省略 levels 参数，因子水平将按照数据中的字母顺序确定：\nfactor(x1)\n#&gt; [1] Dec Apr Jan Mar\n#&gt; Levels: Apr Dec Jan Mar\n按字母顺序排序存在一定风险，不同计算机可能会以不同方式对字符串排序。因此，forcats::fct() 默认按首次出现顺序排序：\nfct(x1)\n#&gt; [1] Dec Apr Jan Mar\n#&gt; Levels: Dec Apr Jan Mar\n如果需要直接访问一个因子的水平集合，可以使用 levels()：\nlevels(y2)\n#&gt;  [1] \"Jan\" \"Feb\" \"Mar\" \"Apr\" \"May\" \"Jun\" \"Jul\" \"Aug\" \"Sep\" \"Oct\" \"Nov\" \"Dec\"\n在用 readr 读取数据时，可以直接用 col_factor() 创建因子列：\ncsv &lt;- \"\nmonth,value\nJan,12\nFeb,56\nMar,12\"\n\ndf &lt;- read_csv(csv, col_types = cols(month = col_factor(month_levels)))\ndf$month\n#&gt; [1] Jan Feb Mar\n#&gt; Levels: Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec",
    "crumbs": [
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>因子</span>"
    ]
  },
  {
    "objectID": "chapters/ch16_factors.html#综合社会调查数据处理",
    "href": "chapters/ch16_factors.html#综合社会调查数据处理",
    "title": "17  因子",
    "section": "17.3 综合社会调查数据处理",
    "text": "17.3 综合社会调查数据处理\n在本章余下的部分，我们将使用 forcats::gss_cat 数据集。它是美国综合社会调查（General Social Survey, GSS）的一部分样本数据，用于展示在处理因子时会遇到的一些常见问题。\ngss_cat\n#&gt; # A tibble: 21,483 × 9\n当因子存储在 tibble 中时，其水平不易直接查看。可以通过 count() 函数查看各水平的出现频数：\ngss_cat |&gt;\n  count(race)\n#&gt; # A tibble: 3 × 2\n#&gt;   race      n\n#&gt;   &lt;fct&gt; &lt;int&gt;\n#&gt; 1 Other  1959\n#&gt; 2 Black  3129\n#&gt; 3 White 16395\n在处理因子时，最常见的两类操作是：\n\n更改因子水平的顺序\n修改因子水平的值",
    "crumbs": [
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>因子</span>"
    ]
  },
  {
    "objectID": "chapters/ch16_factors.html#修改因子顺序",
    "href": "chapters/ch16_factors.html#修改因子顺序",
    "title": "17  因子",
    "section": "17.4 修改因子顺序",
    "text": "17.4 修改因子顺序\n因子水平的顺序通常对可视化效果有影响。例如，要研究不同宗教群体每天平均看电视的小时数：\nrelig_summary &lt;- gss_cat |&gt;\n  group_by(relig) |&gt;\n  summarize(\n    tvhours = mean(tvhours, na.rm = TRUE),\n    n = n()\n  )\n\nggplot(relig_summary, aes(x = tvhours, y = relig)) +\n  geom_point()\n\n上述散点图中，x 轴是电视观看时长，y 轴是宗教类别。然而，由于 y 轴的顺序是任意设置的，图表很难展示出清晰的整体趋势。\n可以用 fct_reorder() 来重新排序水平，使图表更易读。fct_reorder() 有三个参数：\n\n.f：要重新排序的因子；\n.x：用于排序的数值变量；\n.fun（可选）：如果每个 .f 有多个 .x 值，用哪个函数聚合（默认是 median）。\n\nggplot(relig_summary, aes(x = tvhours, y = fct_reorder(relig, tvhours))) +\n  geom_point()\n\n如此一来，宗教类别会按平均电视时长升序排列。可以更容易看出 “Don’t know” 这类人群电视观看时间最多，而 Hinduism 和 Other Eastern 最少。\n当变换变得更复杂时，建议将 fct_reorder() 从 aes() 移出，放进一个单独的 mutate() 中，例如：\nrelig_summary |&gt;\n  mutate(relig = fct_reorder(relig, tvhours)) |&gt;\n  ggplot(aes(x = tvhours, y = relig)) +\n  geom_point()\n下面用类似的方式研究不同收入水平的平均年龄：\nrincome_summary &lt;- gss_cat |&gt;\n  group_by(rincome) |&gt;\n  summarize(\n    age = mean(age, na.rm = TRUE),\n    n = n()\n  )\n\nggplot(rincome_summary, aes(x = age, y = fct_reorder(rincome, age))) +\n  geom_point()\n\n显然，在这个图中重新排序收入水平反而让图表变得更难理解。例如，y 轴上出现了 “$6000–6999” → “&lt;$1000” → “$8000–9999” 的混乱顺序。\n这是因为 rincome 已有明确的层级结构，不应该随意打乱。fct_reorder() 更适用于本身没有逻辑顺序的因子。\n如果只是想把 “Not applicable” 提到前面和其他特殊项放在一起，可以用 fct_relevel()就行了：\nggplot(rincome_summary, aes(x = age, y = fct_relevel(rincome, \"Not applicable\"))) +\n  geom_point()\n\n要对线图中的颜色图例排序，可使用fct_reorder2()函数。\nfct_reorder2(.f, .x, .y) 按照 .x 最大值对应的 .y 值针对 .f 进行排序，使得图例顺序和图中最右边线条的顺序一致，更易于阅读。\nby_age &lt;- gss_cat |&gt;\n  filter(!is.na(age)) |&gt;\n  count(age, marital) |&gt;\n  group_by(age) |&gt;\n  mutate(prop = n / sum(n))\n\n# 重排前图例\nggplot(by_age, aes(x = age, y = prop, color = marital)) +\n  geom_line(linewidth = 1) +\n  scale_color_brewer(palette = \"Set1\")\n\n# 改善图例顺序\nggplot(by_age, aes(x = age, y = prop, color = fct_reorder2(marital, age, prop))) +\n  geom_line(linewidth = 1) +\n  scale_color_brewer(palette = \"Set1\") +\n  labs(color = \"marital\")\n\n对于柱状图，可以使用 fct_infreq() 按出现频率对因子水平降序排序，这是一种无需额外变量的简单排序方式。如要升序排列，可结合 fct_rev() 使用：\ngss_cat |&gt;\n  mutate(marital = marital |&gt; fct_infreq() |&gt; fct_rev()) |&gt;\n  ggplot(aes(x = marital)) +\n  geom_bar()",
    "crumbs": [
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>因子</span>"
    ]
  },
  {
    "objectID": "chapters/ch16_factors.html#修改因子水平",
    "href": "chapters/ch16_factors.html#修改因子水平",
    "title": "17  因子",
    "section": "17.5 修改因子水平",
    "text": "17.5 修改因子水平\n除了修改顺序，还可修改水平名称。最通用的工具是 fct_recode()。\n例如，下面针对 gss_cat 数据集中的 partyid（政党倾向）变量进行研究：\ngss_cat |&gt; count(partyid)\n# A tibble: 10 × 2\npartyid                n\n&lt;fct&gt;              &lt;int&gt;\n1 No answer            154\n2 Don't know             1\n3 Other party          393\n4 Strong republican   2314\n5 Not str republican  3032\n6 Ind,near rep        1791\n# ℹ 4 more rows\n可以看到这些水平名称长短不一。我们可以通过 fct_recode() 把它们改成更长、有固定格式的形式。和 tidyverse 中大多数重命名函数一样，新值写在左边，旧值写在右边：\ngss_cat |&gt;\n  mutate(\n    partyid = fct_recode(partyid,\n      \"Republican, strong\"    = \"Strong republican\",\n      \"Republican, weak\"      = \"Not str republican\",\n      \"Independent, near rep\" = \"Ind,near rep\",\n      \"Independent, near dem\" = \"Ind,near dem\",\n      \"Democrat, weak\"        = \"Not str democrat\",\n      \"Democrat, strong\"      = \"Strong democrat\"\n    )\n  ) |&gt;\n  count(partyid)\n输出：\n# A tibble: 10 × 2\npartyid                   n\n&lt;fct&gt;                 &lt;int&gt;\n1 No answer               154\n2 Don't know                1\n3 Other party             393\n4 Republican, strong     2314\n5 Republican, weak       3032\n6 Independent, near rep  1791\n# ℹ 4 more rows\n\n未被修改的水平会保持原样。如果误写了一个不存在的旧值，fct_recode() 会发出警告。\n\n除了直接改名，也可以通过将多个旧值映射到同一个新值来合并类别。但是务必谨慎，如果合并了实际上差异较大的组别，很可能会造成误导：\ngss_cat |&gt;\n  mutate(\n    partyid = fct_recode(partyid,\n      \"Republican, strong\"    = \"Strong republican\",\n      \"Republican, weak\"      = \"Not str republican\",\n      \"Independent, near rep\" = \"Ind,near rep\",\n      \"Independent, near dem\" = \"Ind,near dem\",\n      \"Democrat, weak\"        = \"Not str democrat\",\n      \"Democrat, strong\"      = \"Strong democrat\",\n      \"Other\"                 = \"No answer\",\n      \"Other\"                 = \"Don't know\",\n      \"Other\"                 = \"Other party\"\n    )\n  )\n如果要合并若干组别到少数几个组别，fct_collapse() 比 fct_recode() 更清晰易读：\ngss_cat |&gt;\n  mutate(\n    partyid = fct_collapse(partyid,\n      \"other\" = c(\"No answer\", \"Don't know\", \"Other party\"),\n      \"rep\" = c(\"Strong republican\", \"Not str republican\"),\n      \"ind\" = c(\"Ind,near rep\", \"Independent\", \"Ind,near dem\"),\n      \"dem\" = c(\"Not str democrat\", \"Strong democrat\")\n    )\n  ) |&gt;\n  count(partyid)\n输出：\n# A tibble: 4 × 2\npartyid     n\n&lt;fct&gt;   &lt;int&gt;\n1 other     548\n2 rep      5346\n3 ind      8409\n4 dem      7180\n有时想把一些频数特别少的类别合并为“Other”，以简化图表或表格。fct_lump_*() 系列函数专为此设计。\n最简单粗暴的函数是fct_lump_lowfreq()，它会逐步合并频数最小的类别为 “Other”，并保证最终 “Other” 频数最小。\ngss_cat |&gt;\n  mutate(relig = fct_lump_lowfreq(relig)) |&gt;\n  count(relig)\n输出：\n# A tibble: 2 × 2\nrelig          n\n&lt;fct&gt;      &lt;int&gt;\n1 Protestant 10846\n2 Other      10637\n能看出多数美国人是新教徒，但还想看到更多宗教的细分。那么此时要用到fct_lump_n()函数来限定分组数量，可以指定保留前 n 个最常见类别，其余合并为 “Other”：\ngss_cat |&gt;\n  mutate(relig = fct_lump_n(relig, n = 10)) |&gt;\n  count(relig, sort = TRUE)\n输出示例：\n# A tibble: 10 × 2\nrelig          n\n&lt;fct&gt;      &lt;int&gt;\n1 Protestant 10846\n2 Catholic    5124\n3 None        3523\n4 Christian    689\n5 Other        458\n6 Jewish       388\n# ℹ 4 more rows",
    "crumbs": [
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>因子</span>"
    ]
  },
  {
    "objectID": "chapters/ch16_factors.html#有序因子",
    "href": "chapters/ch16_factors.html#有序因子",
    "title": "17  因子",
    "section": "17.6 有序因子",
    "text": "17.6 有序因子\n下面简单介绍一种特殊类型的因子：有序因子。它是使用 ordered() 函数创建的，表示因子水平之间存在严格的顺序关系，但并不根据具体数值进行界定。\n有序因子的顺序可以通过 &lt; 符号进行识别：\nordered(c(\"a\", \"b\", \"c\"))\n#&gt; [1] a b c\n#&gt; Levels: a &lt; b &lt; c",
    "crumbs": [
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>因子</span>"
    ]
  },
  {
    "objectID": "chapters/ch17_dates_and_times.html",
    "href": "chapters/ch17_dates_and_times.html",
    "title": "18  日期与时间",
    "section": "",
    "text": "18.1 引言\n本章介绍如何在 R 中处理日期与时间。\n日期和时间的处理会随着学习深入变得越发困难，因为它们需要协调众多地缘因素，包括月份划分、时区与夏令时等。本章将从如何从不同输入中创建日期时间对象开始，然后介绍如何从中提取年份、月份、日等组成部分。接着会进入更复杂的时间跨度处理，讨论根据具体分析目的不同而产生的多种时间跨度类型。最后简要介绍时区所带来的附加挑战。\n本章使用 lubridate 包，它简化了 R 中日期与时间的操作。练习数据则依然来自 nycflights13 数据集：",
    "crumbs": [
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>日期与时间</span>"
    ]
  },
  {
    "objectID": "chapters/ch17_dates_and_times.html#引言",
    "href": "chapters/ch17_dates_and_times.html#引言",
    "title": "18  日期与时间",
    "section": "",
    "text": "library(tidyverse)\nlibrary(nycflights13)",
    "crumbs": [
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>日期与时间</span>"
    ]
  },
  {
    "objectID": "chapters/ch17_dates_and_times.html#创建日期时间",
    "href": "chapters/ch17_dates_and_times.html#创建日期时间",
    "title": "18  日期与时间",
    "section": "18.2 创建日期/时间",
    "text": "18.2 创建日期/时间\n在 R 中，有三种用于表示“某一时刻”的日期/时间类型：\n\n日期（Date）：仅包含年/月/日。Tibble 中显示为 &lt;date&gt;。\n时间（Time）：仅包含小时/分钟/秒。Tibble 中显示为 &lt;time&gt;。\n日期时间（Date-time）：包含日期和时间，唯一标识某一具体时刻（通常精确到秒）。Tibble 中显示为 &lt;dttm&gt;。在 base R 中，它被称作 POSIXct。\n\n注意，理论上应该始终使用最简单的数据类型来满足需求。也就是说，如果只需要日期，就不使用日期时间，因为日期时间涉及时区处理，复杂度更高。\n获取当前日期或当前日期时间：\ntoday()\n#&gt; [1] \"2025-07-19\"\nnow()\n#&gt; [1] \"2025-07-19 23:09:25 UTC\"\n创建日期时间的四种主要方式如下：\n\n通过 readr 读取文件时自动解析。如果 CSV 中包含 ISO8601 格式的日期或日期时间，readr 会自动识别：\n\ncsv &lt;- \"\n  date,datetime\n  2022-01-02,2022-01-02 05:12\n\"\n\nread_csv(csv)\n输出如下：\n# A tibble: 1 × 2\n  date       datetime           \n  &lt;date&gt;     &lt;dttm&gt;             \n1 2022-01-02 2022-01-02 05:12:00\n\nISO8601 是一种国际标准，日期为年-月-日，时间为时:分:秒，日期和时间之间用空格或 T 分隔。\n\n对于非标准格式，则需要用 col_types 指定解析规则，例如：\nread_csv(csv, col_types = cols(date = col_date(\"%m/%d/%y\")))\nreadr 支持的格式代码如下：\n\n\n\n类型\n代码\n含义\n示例\n\n\n\n\n年\n%Y\n四位数年份\n2021\n\n\n\n%y\n两位数年份\n21\n\n\n月\n%m\n数字月份\n2\n\n\n\n%b\n缩写英文月份名\nFeb\n\n\n\n%B\n全称英文月份名\nFebruary\n\n\n日\n%d\n日（01–31）\n02\n\n\n\n%e\n不补零的日\n2\n\n\n时间\n%H\n小时（24小时制）\n13\n\n\n\n%I\n小时（12小时制）\n1\n\n\n\n%p\nAM 或 PM\npm\n\n\n\n%M\n分钟\n35\n\n\n\n%S\n秒\n45\n\n\n时区\n%Z\n时区名\nAmerica/New_York\n\n\n\n%z\nUTC 偏移\n+0800\n\n\n\n\n从字符串中解析。lubridate 包提供了简洁的函数，根据年/月/日的顺序命名：\n\nymd(\"2017-01-31\")          # 年月日\nmdy(\"January 31st, 2017\")  # 月日年\ndmy(\"31-Jan-2017\")         # 日月年\n要创建日期时间，用下划线分割，加上 _h, _hm, _hms 等后缀：\nymd_hms(\"2017-01-31 20:11:59\")\nmdy_hm(\"01/31/2017 08:01\")\n指定时区则要用到tz参数：\nymd(\"2017-01-31\", tz = \"UTC\")\n\n从单独的日期/时间组件拼接。有时日期和时间分散在多个列中，比如 flights 数据集：\n\nflights |&gt; \n  select(year, month, day, hour, minute)\n使用 make_date()（生成日期）或 make_datetime()（生成日期时间）：\nflights |&gt; \n  mutate(departure = make_datetime(year, month, day, hour, minute))\n对于 flights 数据中格式为 hhmm 的时间，需要使用取整与模运算提取小时和分钟：\nmake_datetime_100 &lt;- function(year, month, day, time) {\n  make_datetime(year, month, day, time %/% 100, time %% 100)\n}\n\n从已有日期/时间对象转换。比如在 date-time 与 date 之间转换：\n\nas_datetime(today())  # 将 date 转为 date-time\nas_date(now())        # 将 date-time 转为 date",
    "crumbs": [
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>日期与时间</span>"
    ]
  },
  {
    "objectID": "chapters/ch17_dates_and_times.html#日期时间组件",
    "href": "chapters/ch17_dates_and_times.html#日期时间组件",
    "title": "18  日期与时间",
    "section": "18.3 日期时间组件",
    "text": "18.3 日期时间组件\n本节主要介绍一组用于获取和设置日期时间各个组成部分的访问函数（accessor functions）。\n可以使用以下访问函数来提取日期的单独组成部分：\n\nyear(): 提取年份\nmonth(): 提取月份\nmday(): 提取月份中的第几天\nyday(): 提取一年中的第几天\nwday(): 提取一周中的第几天\nhour(), minute(), second(): 提取时间中的小时、分钟、秒\n\n这些函数本质上可以看作是 make_datetime() 函数的“逆操作”。\ndatetime &lt;- ymd_hms(\"2026-07-08 12:34:56\")\n\nyear(datetime)     # 2026\nmonth(datetime)    # 7\nmday(datetime)     # 8\nyday(datetime)     # 189 （2026年的第189天）\nwday(datetime)     # 4   （默认星期天是1，这天是星期三）\n对于 month() 和 wday()，可以设置 label = TRUE 来显示月份或星期的英文缩写标签。要想显示完整名称，可以再加上 abbr = FALSE：\nmonth(datetime, label = TRUE)\n#&gt; [1] Jul\n#&gt; 12 Levels: Jan &lt; Feb &lt; Mar &lt; Apr &lt; May &lt; Jun &lt; Jul &lt; ... &lt; Dec\n\nwday(datetime, label = TRUE, abbr = FALSE)\n#&gt; [1] Wednesday\n#&gt; 7 Levels: Sunday &lt; Monday &lt; Tuesday &lt; Wednesday &lt; Thursday &lt; Friday &lt; Saturday\n比如我们可以使用 wday() 来分析航班在一周内的分布情况：\nflights_dt |&gt; \n  mutate(wday = wday(dep_time, label = TRUE)) |&gt; \n  ggplot(aes(x = wday)) +\n  geom_bar()\n\n\n另一种分析时间的方式是将日期“对齐”到指定的时间单位，注意单位（second、minute、hour、day、week等）要打引号。可以使用以下函数：\n\nfloor_date()：向下取整\nceiling_date()：向上取整\nround_date()：标准四舍五入\n\n假设某个 time 是 2025-07-10 14:32:00，那么 ：\nfloor_date(time, \"week\")\n[1] \"2025-07-07 00:00:00\"\nceiling_date(time,\"month\")\n[1] \"2025-08-01 UTC\"\nround_date(time,\"year\")\n[1] \"2026-01-01 UTC\"\n\n除了提取日期时间的组成部分，也可以对其进行修改，通常用于数据清洗。\ndatetime &lt;- ymd_hms(\"2026-07-08 12:34:56\")\n#&gt; [1] \"2026-07-08 12:34:56 UTC\"\n\nyear(datetime) &lt;- 2030\n#&gt; [1] \"2030-07-08 12:34:56 UTC\"\n\nmonth(datetime) &lt;- 1\n#&gt; [1] \"2030-01-08 12:34:56 UTC\"\n\nhour(datetime) &lt;- hour(datetime) + 1\n#&gt; [1] \"2030-01-08 13:34:56 UTC\"\n也可以用 update() 一次修改多个组成部分：\nupdate(datetime, year = 2030, month = 2, mday = 2, hour = 2)\n#&gt; [1] \"2030-02-02 02:34:56 UTC\"\n注意，数值超过极限值会自动进位：\nupdate(ymd(\"2023-02-01\"), mday = 30)\n#&gt; [1] \"2023-03-02\"",
    "crumbs": [
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>日期与时间</span>"
    ]
  },
  {
    "objectID": "chapters/ch17_dates_and_times.html#时间跨度",
    "href": "chapters/ch17_dates_and_times.html#时间跨度",
    "title": "18  日期与时间",
    "section": "18.4 时间跨度",
    "text": "18.4 时间跨度\n本节学习日期之间的算术运算，包括减法、加法和除法。过程中会涉及三种重要的时间跨度类型：\n\nDuration（持续时间）：表示精确的秒数。\nPeriod（周期）：表示更贴近日常的单位，例如“几个月”或“几周”。\nInterval（区间）：表示一个明确的起点和终点。\n\n\n\n只关心实际经过了多少时间用 duration。\n想表达“加一个月”、“加三年”用 period。\n想知道“某个事件持续了多少天”用 interval。\n\n\n\n在 R 中对两个日期做减法，得到的是一个 difftime 对象：\nh_age &lt;- today() - ymd(\"1979-10-14\")\nh_age\n#&gt; Time difference of 16719 days\ndifftime 类可以用秒、分钟、小时、天等为单位，但由于单位不固定，操作起来可能不太方便。\nlubridate 包提供了更稳定的 duration 类型，始终以秒为单位：\nas.duration(h_age)\n#&gt; [1] \"1444521600s (~45.77 years)\"\n常用的duration类构造函数如下：\ndseconds(15)      # [1] \"15s\"\ndminutes(10)      # [1] \"600s (~10 minutes)\"\ndhours(24)        # [1] \"86400s (~1 days)\"\nddays(5)          # [1] \"432000s (~5 days)\"\ndweeks(3)         # [1] \"1814400s (~3 weeks)\"\ndyears(1)         # [1] \"31557600s (~1 years)\"\n注意，duration 使用平均年长度（365.25 天）来计算年数。月份无法精确表示为 duration，因为月份天数不固定。\n运算示例：\n2 * dyears(1)   # 两年\ndyears(1) + dweeks(12) + dhours(15)\n也可以和日期相加减：\ntomorrow &lt;- today() + ddays(1)\nlast_year &lt;- today() - dyears(1)\n\n为了解决闰年等问题，lubridate 提供了 periods 类型。它不使用精确秒数，而是保留日常语义（如“加一天”、“加一个月”）。构造函数与duration类似但结果不只以秒表示：\nhours(24)     # [1] \"24H 0M 0S\"\ndays(7)       # [1] \"7d 0H 0M 0S\"\nmonths(1)     # [1] \"1m 0d 0H 0M 0S\"\n运算示例：\n10 * (months(6) + days(1))       # 60个月 + 10天\n\n若想知道某区间内共有多少天，用时间区间 interval 更合适。\n创建 interval采用start %--% end，start是起始时间，end是终末时间。\ny2023 &lt;- ymd(\"2023-01-01\") %--% ymd(\"2024-01-01\")\ny2023 / days(1)  # 365 天\n\ny2024 &lt;- ymd(\"2024-01-01\") %--% ymd(\"2025-01-01\")\ny2024 / days(1)  # 366 天（闰年）",
    "crumbs": [
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>日期与时间</span>"
    ]
  },
  {
    "objectID": "chapters/ch17_dates_and_times.html#时区",
    "href": "chapters/ch17_dates_and_times.html#时区",
    "title": "18  日期与时间",
    "section": "18.5 时区",
    "text": "18.5 时区\n对于时区，R 使用国际标准 —— IANA 时区数据库。此标准采用统一的命名规则：{地区}/{地点}，通常是 {洲名}/{城市名} 或 {大洋}/{城市名} 的格式。比如：\n\n\"America/New_York\"（美洲/纽约）\n\"Europe/Paris\"（欧洲/巴黎）\n\"Pacific/Auckland\"（太平洋/奥克兰）\n\n可以通过 Sys.timezone() 查看 R 所识别的当前时区：\nSys.timezone()\n#&gt; [1] \"Asia/Shanghai\"\n在 R 中，时区是日期时间对象的一个属性，它只影响时间的显示方式，并不改变代表的真实时间点。",
    "crumbs": [
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>日期与时间</span>"
    ]
  },
  {
    "objectID": "chapters/ch18_missing_values.html",
    "href": "chapters/ch18_missing_values.html",
    "title": "19  缺失值",
    "section": "",
    "text": "19.1 引言\n本书早些章节就已经出现过缺失值的基本概念。\n显式缺失值即标记为 NA 的值，本章会从处理显式缺失值的一些通用工具讲起，随后介绍隐式缺失值，以及空因子组。\n处理缺失值的函数主要来自于 dplyr 和 tidyr，都属于 tidyverse 包。",
    "crumbs": [
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>缺失值</span>"
    ]
  },
  {
    "objectID": "chapters/ch18_missing_values.html#引言",
    "href": "chapters/ch18_missing_values.html#引言",
    "title": "19  缺失值",
    "section": "",
    "text": "library(tidyverse)",
    "crumbs": [
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>缺失值</span>"
    ]
  },
  {
    "objectID": "chapters/ch18_missing_values.html#显式缺失值",
    "href": "chapters/ch18_missing_values.html#显式缺失值",
    "title": "19  缺失值",
    "section": "19.2 显式缺失值",
    "text": "19.2 显式缺失值\n本节介绍几个处理显式缺失值的工具，用于创建或消除NA。\n在手动输入数据时，NA 往往用作一种简化手段，表示该单元格的值与上一行相同，即“向前填充”，称为 “last observation carried forward”，简称 locf。例如：\ntreatment &lt;- tribble(\n  ~person,           ~treatment, ~response,\n  \"Derrick Whitmore\", 1,         7,\n  NA,                 2,         10,\n  NA,                 3,         NA,\n  \"Katherine Burke\",  1,         4\n)\n可以使用 tidyr::fill() 函数填补这些缺失值。该函数的参数类似 select()，用于指定要填充的列：\ntreatment |&gt;\n  fill(everything())\n输出如下：\n# A tibble: 4 × 3\n  person           treatment response\n  &lt;chr&gt;                &lt;dbl&gt;    &lt;dbl&gt;\n1 Derrick Whitmore         1        7\n2 Derrick Whitmore         2       10\n3 Derrick Whitmore         3       10\n4 Katherine Burke          1        4\n若遇到更复杂的缺失模式，还可以通过 .direction 参数控制填充方向。\n\n当缺失值代表一个固定且已知的值，比如 0时，可以使用 dplyr::coalesce() 来替换：\nx &lt;- c(1, 4, 5, 7, NA)\ncoalesce(x, 0)\n#&gt; [1] 1 4 5 7 0\n也可能遇到相反的情况：某个固定数值实际上代表缺失值。例如，某些旧软件无法用 NA 表示缺失，因此用特殊值如 99 或 -999 来代替。此时可使用 readr::read_csv() 的 na 参数在读取时即进行替换：\nread_csv(path, na = \"99\")\n如果是在数据读取后才发现问题，或读取函数不支持该参数，可以使用 dplyr::na_if()在读取后进行替换：\nx &lt;- c(1, 4, 5, 7, -99)\nna_if(x, -99)\n#&gt; [1]  1  4  5  7 NA\n\n在使用数学函数时，有时会遇到 NaN（Not a Number）。虽然它与 NA 类似，但语义上更偏向“数学上的无效结果”。\n示例：\nx &lt;- c(NA, NaN)\nx * 10\n#&gt; [1]  NA NaN\n\nx == 1\n#&gt; [1] NA NA\n\nis.na(x)\n#&gt; [1] TRUE TRUE\n通常在如下数学运算中也会出现 NaN：\n0 / 0       # 除以0未定义\n#&gt; [1] NaN\n\n0 * Inf     # 0 乘以无穷\n#&gt; [1] NaN\n\nInf - Inf   # 无穷减无穷\n#&gt; [1] NaN\n\nsqrt(-1)    # 负数开平方\n#&gt; Warning in sqrt(-1): NaNs produced\n#&gt; [1] NaN\n虽然大多数情况下，NaN 与 NA 的行为类似，但在某些数值计算中区分它们可能是必要的。可使用 is.nan(x)进行区分：\nx &lt;- c(NA, NaN)\nis.nan(x)\n#&gt; [1] FALSE TRUE",
    "crumbs": [
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>缺失值</span>"
    ]
  },
  {
    "objectID": "chapters/ch18_missing_values.html#隐式缺失值",
    "href": "chapters/ch18_missing_values.html#隐式缺失值",
    "title": "19  缺失值",
    "section": "19.3 隐式缺失值",
    "text": "19.3 隐式缺失值\n有些时候，缺失的数据并不以 NA 的形式存在，而是整行数据根本就没出现在数据集中，称为隐式缺失值。\n比如有一个数据集记录了某只股票每一季度的价格：\nstocks &lt;- tibble(\n  year  = c(2020, 2020, 2020, 2020, 2021, 2021, 2021),\n  qtr   = c(   1,    2,    3,    4,    2,    3,    4),\n  price = c(1.88, 0.59, 0.35,   NA, 0.92, 0.17, 2.66)\n)\n这个数据集中存在两个缺失情况：\n\n2020 年第 4 季度的价格是缺失的，显示为 NA，为显式缺失。\n2021 年第 1 季度的价格完全不在表里，这一行根本不存在，这就是隐式缺失。\n\n作者用了一种“禅意”的表达方式来区分两者：\n\nAn explicit missing value is the presence of an absence.\nAn implicit missing value is the absence of a presence.\n\n有时我们想把隐式缺失值变成显式的 NA，从而更方便地进行处理数据；而有时候，某些显式缺失值是由于数据结构不整洁造成的，我们又希望让它们隐式化，去掉无意义的 NA。下面介绍几个常用方法来实现这两种转换。\n\n数据透视（pivoting）\n\n之前已经学过，宽格式的数据（pivot_wider）会将隐式缺失变成显式 NA，因为每个组合都必须有对应值。比如我们把 qtr 这一列转成列名：\nstocks |&gt;\n  pivot_wider(\n    names_from = qtr,\n    values_from = price\n  )\n输出结果是：\n# A tibble: 2 × 5\n   year   `1`   `2`   `3`   `4`\n  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n1  2020  1.88  0.59  0.35 NA   \n2  2021   NA   0.92  0.17 2.66\n可以看到原来缺失的一行（2021 年第 1 季度）现在以 NA 形式出现了。\n反过来，从宽格式转回长格式（pivot_longer）时，会默认保留这些 NA。当然也可以选择用 values_drop_na = TRUE 参数把它们变成隐式。\n\n使用 complete() 明确地补全所有组合\n\ntidyr::complete() 是一个强大函数，可以补全所有“本该存在”的组合，并用 NA 表示它们的缺失。\n比如按理来说 year 和 qtr 所有组合都应该存在：\nstocks |&gt;\n  complete(year, qtr)\n输出：\n# A tibble: 8 × 3\n   year   qtr price\n  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n1  2020     1  1.88\n2  2020     2  0.59\n3  2020     3  0.35\n4  2020     4  NA\n5  2021     1  NA\n6  2021     2  0.92\n7  2021     3  0.17\n8  2021     4  2.66\n甚至可以指定不在数据中的年份，比如要让数据从 2019 到 2021 则可以自动添加 2019 年所有季度的缺失行。\nstocks |&gt;\n  complete(year = 2019:2021, qtr)\n\n有时没法直接通过变量组合来生成完整数据。如果想手动控制哪些行应存在，则可以先创建完整的组合表，再用 full_join() 合并。这样能获得跟 complete() 类似的效果，但更灵活：\n\nfull_frame &lt;- expand_grid(\n  year = 2019:2021,\n  qtr = 1:4\n)\n\nstocks |&gt; \n  full_join(full_frame)\n\n使用 anti_join() 查找缺失记录\n\n在某些情况下，只有通过对比两个数据集，才能发现哪些信息缺失了。这时可以用 anti_join()。\n举个例子，要找出 flights 表中出现的机场代码 dest，但在 airports 数据表中没有信息的数据，就可以：\nflights |&gt; \n  distinct(faa = dest) |&gt; \n  anti_join(airports)\n输出表明缺了 4 个机场信息。",
    "crumbs": [
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>缺失值</span>"
    ]
  },
  {
    "objectID": "chapters/ch18_missing_values.html#因子和空组",
    "href": "chapters/ch18_missing_values.html#因子和空组",
    "title": "19  缺失值",
    "section": "19.4 因子和空组",
    "text": "19.4 因子和空组\n缺失值还有一种不易察觉的形式：空组（empty group），指某个分组在数据中没有观测值，这种情况经常发生在使用因子时。\n例如有一组健康调查数据：\nhealth &lt;- tibble(\n  name   = c(\"Ikaia\", \"Oletta\", \"Leriah\", \"Dashay\", \"Tresaun\"),\n  smoker = factor(c(\"no\", \"no\", \"no\", \"no\", \"no\"), levels = c(\"yes\", \"no\")),\n  age    = c(34, 88, 75, 47, 56)\n)\n这里的 smoker 是一个因子变量，其两个取值为 \"yes\" 和 \"no\"。现在要统计抽烟的人数：\nhealth |&gt; count(smoker)\n输出：\n# A tibble: 1 × 2\n  smoker     n\n  &lt;fct&gt;  &lt;int&gt;\n1 no         5\n默认情况下，只统计数据中实际出现的组，因此没有显示 \"yes\"。可以通过 .drop = FALSE 显式保留所有因子水平：\nhealth |&gt; count(smoker, .drop = FALSE)\n# A tibble: 2 × 2\n  smoker     n\n  &lt;fct&gt;  &lt;int&gt;\n1 yes        0\n2 no         5\n用ggplot绘图时也会有此类问题。以柱状图为例：\nggplot(health, aes(x = smoker)) +\n  geom_bar()\n这时，图中只会有一个 \"no\" 的柱子，\"yes\" 组直接被省略了。\n想要保留 \"yes\" 的空位置，只需：\nggplot(health, aes(x = smoker)) +\n  geom_bar() +\n  scale_x_discrete(drop = FALSE)\n这样，即使 \"yes\" 没有数据，也会显示在 x 轴上，柱子高度为 0。\n\n不仅仅是绘图或计数，使用 group_by() 进行分组汇总时也默认丢弃空组，所以也需要.drop = FALSE参数进行补全：\nhealth |&gt; \n  group_by(smoker, .drop = FALSE) |&gt; \n  summarize(\n    n = n(),\n    mean_age = mean(age),\n    min_age = min(age),\n    max_age = max(age),\n    sd_age = sd(age)\n  )\n# A tibble: 2 × 6\n  smoker     n mean_age min_age max_age sd_age\n  &lt;fct&gt;  &lt;int&gt;    &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;  &lt;dbl&gt;\n1 yes        0      NaN     Inf    -Inf     NA\n2 no         5       60      34      88   21.6\n因为yes组的相关数据处理是在空向量上进行计算，所以输出值各异。一一解释如下：\n\nyes 组是空的 → n = 0。\n计算平均值时是 0 / 0，结果是 NaN。\nmin() 返回 Inf，max() 返回 -Inf。\n\n另一种补全方式是先按实际数据汇总，再用 complete() 把空组加回来，这样得到的空组相关值是 NA ：\nhealth |&gt; \n  group_by(smoker) |&gt; \n  summarize(\n    n = n(),\n    mean_age = mean(age),\n    min_age = min(age),\n    max_age = max(age),\n    sd_age = sd(age)\n  ) |&gt; \n  complete(smoker)\n# A tibble: 2 × 6\n  smoker     n mean_age min_age max_age sd_age\n  &lt;fct&gt;  &lt;int&gt;    &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;  &lt;dbl&gt;\n1 yes       NA       NA      NA      NA     NA\n2 no         5       60      34      88   21.6",
    "crumbs": [
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>缺失值</span>"
    ]
  },
  {
    "objectID": "chapters/ch19_joins.html",
    "href": "chapters/ch19_joins.html",
    "title": "20  连接",
    "section": "",
    "text": "20.1 引言\n在数据分析中，通常会有多个数据框，并将它们合并关联起来以解决问题。本章介绍两种重要的连接操作：\n本章使用 nycflights13 包中的五个相关数据集，并通过 dplyr 包中的连接函数进行分析。",
    "crumbs": [
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>连接</span>"
    ]
  },
  {
    "objectID": "chapters/ch19_joins.html#引言",
    "href": "chapters/ch19_joins.html#引言",
    "title": "20  连接",
    "section": "",
    "text": "变形连接（mutating joins）：从另一个数据框中提取匹配行的变量，添加到当前数据框中。\n筛选连接（filtering joins）：根据是否在另一个数据框中存在匹配项，筛选当前数据框的行。\n\n\nlibrary(tidyverse)\nlibrary(nycflights13)",
    "crumbs": [
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>连接</span>"
    ]
  },
  {
    "objectID": "chapters/ch19_joins.html#键",
    "href": "chapters/ch19_joins.html#键",
    "title": "20  连接",
    "section": "20.2 键",
    "text": "20.2 键\n要理解连接操作，首先得了解两个表格是如何通过各自的一对键（Keys）关联起来的。\n每次连接操作都涉及一对键：主键（primary key） 和 外键（foreign key）。\n\n主键是唯一标识表中每一行的变量（或变量组合）。如果需要多个变量来唯一标识一行数据，则称为复合主键。\n外键是另一个表中的变量，值对应于该表的主键，用于建立连接关系。\n\n例如，在 nycflights13 中：\n\nairlines 表中，每家航空公司由其两位字母的代码 carrier 唯一标识，因此 carrier 是主键。\nweather 表中，每条记录由 origin（机场）和 time_hour（时间）联合标识，是复合主键。\n\n而在 flights 表中，很多列是外键，仅举三例：\n\ntailnum 对应 planes 的主键。\norigin 和 dest 都对应 airports 的主键。\norigin 和 time_hour 联合对应 weather 表中的复合主键。\n\n识别出主键之后，最好检查它们是否真的可以唯一标识每一行。方法之一是使用 count() 看看有没有重复。\n比如 planes 和 weather 表的主键就没有重复：\n&gt; planes |&gt; \n  count(tailnum) |&gt; \n  filter(n &gt; 1)\n&gt; weather |&gt; \n  count(time_hour, origin) |&gt; \n  filter(n &gt; 1)\n输出结果都是空的，说明每个主键组合只出现了一次。\n还需要如下检查主键是否包含缺失值，有NA就无法进行唯一标识：\nplanes |&gt; filter(is.na(tailnum))\nweather |&gt; filter(is.na(time_hour) | is.na(origin))\n\n到目前为止我们还没有确定 flights 表的主键。经过探索发现，用 time_hour（小时级别的出发时间）、carrier（航空公司代码）和 flight（航班号）这三列可以唯一标识每一条航班记录：\nflights |&gt; \n  count(time_hour, carrier, flight) |&gt; \n  filter(n &gt; 1)\n结果是 0，说明组合后唯一。\n不过，唯一性并不意味着就是实用的主键。比如 airports 表中的 alt（海拔）和 lat（纬度）的组合也可能唯一，但显然不是标识机场的好方式。因此，仅凭数据很难判断一个键是否合理。不过话又说回来，在 flights 中，使用上面的组合在逻辑上倒也说得通。\n尽管如此，从严谨性出发，最好选择创建一个简单的替代键（Surrogate Keys），比如用行号来唯一标识每条记录：\nflights2 &lt;- flights |&gt; \n  mutate(id = row_number(), .before = 1)\n这样就多了一个 id 字段，用于唯一识别每一行，可作为主键。这对于人与人沟通时尤其方便——就好比说“去看看第 2001 号航班”比“去查 UA430 在 2013-01-03 早上 9 点的航班”更简单。",
    "crumbs": [
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>连接</span>"
    ]
  },
  {
    "objectID": "chapters/ch19_joins.html#基本连接",
    "href": "chapters/ch19_joins.html#基本连接",
    "title": "20  连接",
    "section": "20.3 基本连接",
    "text": "20.3 基本连接\ndplyr 提供了六种连接函数：left_join()、inner_join()、right_join()、full_join()、semi_join() 和 anti_join()。它们的接口相同，都接受一对数据框（x 和 y），返回一个数据框。输出中的行和列顺序主要由 x 决定。\n\n\n变形连接（mutating join）\n\n变形连接可以将两个数据框中的变量合并。首先通过键匹配观测值，然后将一个数据框中的变量复制到另一个数据框中。\n为了更容易观察连接的效果，下面构建一个包含六个变量的简化版 flights 数据集：\nflights2 &lt;- flights |&gt;\n  select(year, time_hour, origin, dest, tailnum, carrier)\nflights2\n#&gt; # A tibble: 336,776 × 6\n#&gt;    year time_hour           origin dest  tailnum carrier\n#&gt;   &lt;int&gt; &lt;dttm&gt;              &lt;chr&gt;  &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;  \n#&gt; 1  2013 2013-01-01 05:00:00 EWR    IAH   N14228  UA     \n#&gt; 2  2013 2013-01-01 05:00:00 LGA    IAH   N24211  UA     \n#&gt; 3  2013 2013-01-01 05:00:00 JFK    MIA   N619AA  AA     \n#&gt; 4  2013 2013-01-01 05:00:00 JFK    BQN   N804JB  B6     \n#&gt; 5  2013 2013-01-01 06:00:00 LGA    ATL   N668DN  DL     \n#&gt; 6  2013 2013-01-01 05:00:00 EWR    ORD   N39463  UA     \n#&gt; # ℹ 336,770 more rows\n变形连接最常用 left_join()函数，特点是其输出会保留被连接数据框（x）中的所有行。此函数的主要用途是添加元数据。例如，将航空公司全称name加入 flights2：\nflights2 |&gt;\n  left_join(airlines)\n#&gt; Joining with `by = join_by(carrier)`\n#&gt; # A tibble: 336,776 × 7\n#&gt;    year time_hour           origin dest  tailnum carrier name                \n#&gt;   &lt;int&gt; &lt;dttm&gt;              &lt;chr&gt;  &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;               \n#&gt; 1  2013 2013-01-01 05:00:00 EWR    IAH   N14228  UA      United Air Lines In…\n#&gt; 2  2013 2013-01-01 05:00:00 LGA    IAH   N24211  UA      United Air Lines In…\n#&gt; 3  2013 2013-01-01 05:00:00 JFK    MIA   N619AA  AA      American Airlines I…\n#&gt; 4  2013 2013-01-01 05:00:00 JFK    BQN   N804JB  B6      JetBlue Airways     \n#&gt; 5  2013 2013-01-01 06:00:00 LGA    ATL   N668DN  DL      Delta Air Lines Inc.\n#&gt; 6  2013 2013-01-01 05:00:00 EWR    ORD   N39463  UA      United Air Lines In…\n#&gt; # ℹ 336,770 more rows\n当 left_join() 无法为被连接数据框 x 中的某行找到匹配值时，会在新变量中填充NA。例如，tailnum 为 N3ALAA 的飞机在 planes 中没有相关信息：\nflights2 |&gt; \n  filter(tailnum == \"N3ALAA\") |&gt; \n  left_join(planes |&gt; select(tailnum, type, engines, seats))\nflights2 |&gt; \n  filter(tailnum == \"N3ALAA\") |&gt; \n  left_join(planes |&gt; select(tailnum, type, engines, seats))\n#&gt; Joining with `by = join_by(tailnum)`\n#&gt; # A tibble: 63 × 9\n#&gt;    year time_hour           origin dest  tailnum carrier type  engines seats\n#&gt;   &lt;int&gt; &lt;dttm&gt;              &lt;chr&gt;  &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;   &lt;int&gt; &lt;int&gt;\n#&gt; 1  2013 2013-01-01 06:00:00 LGA    ORD   N3ALAA  AA      &lt;NA&gt;       NA    NA\n#&gt; 2  2013 2013-01-02 18:00:00 LGA    ORD   N3ALAA  AA      &lt;NA&gt;       NA    NA\n#&gt; 3  2013 2013-01-03 06:00:00 LGA    ORD   N3ALAA  AA      &lt;NA&gt;       NA    NA\n#&gt; 4  2013 2013-01-07 19:00:00 LGA    ORD   N3ALAA  AA      &lt;NA&gt;       NA    NA\n#&gt; 5  2013 2013-01-08 17:00:00 JFK    ORD   N3ALAA  AA      &lt;NA&gt;       NA    NA\n#&gt; 6  2013 2013-01-16 06:00:00 LGA    ORD   N3ALAA  AA      &lt;NA&gt;       NA    NA\n#&gt; # ℹ 57 more rows\ninner_join()、right_join() 和 full_join() 接口与 left_join() 相同，但保留的行不同：\n\nleft_join() 保留 x 中所有行\nright_join() 保留 y 中所有行\nfull_join() 保留 x 和 y 中所有行\ninner_join() 仅保留在 x 和 y 中都存在的行\n\n\n\n指定连接键（Specifying join keys）\n\n默认情况下，left_join() 会使用两个数据框中都存在的变量作为连接键，但是如果变量名称相同而实际含义有区别，再使用这种方式显然不合理。例如，尝试将 flights2 与完整的 planes 数据集连接：\nflights2 |&gt; \n  left_join(planes)\n#&gt; Joining with `by = join_by(year, tailnum)`\n#&gt; # A tibble: 336,776 × 13\n#&gt;    year time_hour           origin dest  tailnum carrier type  manufacturer\n#&gt;   &lt;int&gt; &lt;dttm&gt;              &lt;chr&gt;  &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt; &lt;chr&gt;       \n#&gt; 1  2013 2013-01-01 05:00:00 EWR    IAH   N14228  UA      &lt;NA&gt;  &lt;NA&gt;        \n#&gt; 2  2013 2013-01-01 05:00:00 LGA    IAH   N24211  UA      &lt;NA&gt;  &lt;NA&gt;        \n#&gt; 3  2013 2013-01-01 05:00:00 JFK    MIA   N619AA  AA      &lt;NA&gt;  &lt;NA&gt;        \n#&gt; 4  2013 2013-01-01 05:00:00 JFK    BQN   N804JB  B6      &lt;NA&gt;  &lt;NA&gt;        \n#&gt; 5  2013 2013-01-01 06:00:00 LGA    ATL   N668DN  DL      &lt;NA&gt;  &lt;NA&gt;        \n#&gt; 6  2013 2013-01-01 05:00:00 EWR    ORD   N39463  UA      &lt;NA&gt;  &lt;NA&gt;        \n#&gt; # ℹ 336,770 more rows\n#&gt; # ℹ 5 more variables: model &lt;chr&gt;, engines &lt;int&gt;, seats &lt;int&gt;, …\n此处产生大量缺失是因为连接键 year 的含义在两个数据框中不同。 flights$year 表示飞行年份，而 planes$year 表示飞机制造年份。因此我们希望排除year这个变量，仅以 tailnum 为键，可显式指定join_by(tailnum)来达到此效果：\nflights2 |&gt; \n  left_join(planes, join_by(tailnum))\n#&gt; # A tibble: 336,776 × 14\n#&gt;   year.x time_hour           origin dest  tailnum carrier year.y\n#&gt;    &lt;int&gt; &lt;dttm&gt;              &lt;chr&gt;  &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;    &lt;int&gt;\n#&gt; 1   2013 2013-01-01 05:00:00 EWR    IAH   N14228  UA        1999\n#&gt; 2   2013 2013-01-01 05:00:00 LGA    IAH   N24211  UA        1998\n#&gt; 3   2013 2013-01-01 05:00:00 JFK    MIA   N619AA  AA        1990\n#&gt; 4   2013 2013-01-01 05:00:00 JFK    BQN   N804JB  B6        2012\n#&gt; 5   2013 2013-01-01 06:00:00 LGA    ATL   N668DN  DL        1991\n#&gt; 6   2013 2013-01-01 05:00:00 EWR    ORD   N39463  UA        2012\n#&gt; # ℹ 336,770 more rows\n#&gt; # ℹ 7 more variables: type &lt;chr&gt;, manufacturer &lt;chr&gt;, model &lt;chr&gt;, …\n注意到，重复的变量名（如 year）会自动添加后缀以区分， 此处为year.x 和 year.y。可通过 suffix 参数自定义后缀。\njoin_by(tailnum) 的完整写法是 join_by(tailnum == tailnum)。了解完整写法很重要，原因有二：\n\n它明确描述两个表之间的关系——键必须相等，因此称为等值连接（equi join）。\n可以指定两个表中不同的连接变量。例如，flights2 与 airports 可以通过 dest 或 origin 连接：\n\nflights2 |&gt; \n  left_join(airports, join_by(dest == faa))\n\nflights2 |&gt; \n  left_join(airports, join_by(origin == faa))\n\n\n过滤连接（Filtering joins）\n\n顾名思义，过滤连接的主要作用是筛选行。包括两种类型：\n\nsemi_join()：保留 x 中与 y 匹配的行\nanti_join()：保留 x 中没有在 y 中匹配的行\n\n例如，使用 semi_join() 筛选出 flights2 中作为起点的机场：\nairports |&gt; \n  semi_join(flights2, join_by(faa == origin))\n相反，anti_join() 可以找出未匹配上的项，常用于寻找隐式缺失值。例如，查找 flights2 中没有对应目的地机场的航班：\nflights2 |&gt; \n  anti_join(airports, join_by(dest == faa)) |&gt; \n  distinct(dest)",
    "crumbs": [
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>连接</span>"
    ]
  },
  {
    "objectID": "chapters/ch19_joins.html#连接的运作原理",
    "href": "chapters/ch19_joins.html#连接的运作原理",
    "title": "20  连接",
    "section": "20.4 连接的运作原理",
    "text": "20.4 连接的运作原理\n现在让我们深入了解连接是如何运作的，重点在于 x 中的每一行是如何与 y 中的行进行匹配。在下面例子中，只使用一个名为 key 的主键，以及单一值列（分别为val_x 和 val_y），此原理可以推广到多键和多值。\nx &lt;- tribble(\n  ~key, ~val_x,\n     1, \"x1\",\n     2, \"x2\",\n     3, \"x3\"\n)\ny &lt;- tribble(\n  ~key, ~val_y,\n     1, \"y1\",\n     2, \"y2\",\n     4, \"y3\"\n)\n\n上图展示了 x 和 y 所有潜在匹配的交叉点。这些交叉点由从 x 的每一行水平延伸的线和从 y 的每一行垂直延伸的线组成。输出行主要由 x 决定，因此 x 放在水平位置并对齐。\n为了描述某种特定的连接类型，在此用点表示匹配。每一个匹配点都表示一个新的数据框，它包含键、x 的值和 y 的值。 由于上图是内连接（inner join），故只保留交集。键 1 和 2 在 x 和 y 中都存在，因此匹配成功，对应输出中的两行。\n我们可以用同样的原理解释外连接（outer join）。这些连接通过在每个数据框中添加一个虚拟行来实现，虚拟行包含一个能与任何不匹配行相匹配的键，其余字段为 NA。外连接有三种类型：\n\n左连接（left_join）\n\n左连接保留 x 中的所有行。每一行都在输出中保留下来，可以退回而匹配 y 中的虚拟行。键为 3 的行在 y 中无对应项，因此对应的 val_y 为 NA。\n\n\n右连接（right_join）\n\n与左连接对应，右连接保留 y 中的所有行。键为 4 的行只在 y 中存在，因此输出中 val_x 为 NA。\n\n\n全连接（full_join）\n\n全连接保留 x 和 y 中所有的行。无匹配的部分会填充 NA。\n\n下面的 Venn 图展示了不同连接类型的差异。\n\n这些连接类型统称为 等值连接（equi joins），即键相等时匹配，是最常见的连接类型。\n以上讨论了 x 中的一行最多匹配 y 中一行的情况，现在举例说明匹配多行的情形。\ndf1 &lt;- tibble(key = c(1, 2, 2), val_x = c(\"x1\", \"x2\", \"x3\"))\ndf2 &lt;- tibble(key = c(1, 2, 2), val_y = c(\"y1\", \"y2\", \"y3\"))\n此例中x1 与 y1 匹配；x2 和 x3 均匹配 y2 和 y3，形成多对多的局面，故运行代码会触发警告，不过仍会有输出，即全部可能的结果。\ndf1 |&gt; \n  inner_join(df2, join_by(key))\n# A tibble: 5 × 3\n    key val_x val_y\n  &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;\n1     1 x1    y1   \n2     2 x2    y2   \n3     2 x2    y3   \n4     2 x3    y2   \n5     2 x3    y3   \nwarning:\nIn inner_join(df1, df2, join_by(key)) :\n  Detected an unexpected many-to-many relationship\nbetween `x` and `y`.\n还有基于等值连接的过滤连接（Filtering joins）：\n\n半连接（semi_join()）：保留在 y 中有匹配的 x 中的行。\n\n\n\n反连接（anti_join()）：保留在 y 中没有匹配的 x 中的行。",
    "crumbs": [
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>连接</span>"
    ]
  },
  {
    "objectID": "chapters/ch19_joins.html#非等值连接",
    "href": "chapters/ch19_joins.html#非等值连接",
    "title": "20  连接",
    "section": "20.5 非等值连接",
    "text": "20.5 非等值连接\n到此为止，本章均在谈论等值连接。本节则介绍匹配两行的其他方式。\n在等值连接中，x 和 y 的键总是相等的，所以输出中只需要显示一个键列。如果要保留两个键列，可以设置 keep = TRUE。\n而使用非等值连接时（例如 x$key &gt;= y$key），x 和 y 的键值不一定相等，所以将两个键列均保留。\n以下是四类常用的非等值连接类型：\n\n交叉连接（Cross joins）：匹配所有行的组合；\n不等连接（Inequality joins）：使用 &lt;, &lt;=, &gt;, &gt;=；\n滚动连接（Rolling joins）：输出“在不等中最接近”的那一行；\n重叠连接（Overlap joins）：匹配区间之间的包含或重叠关系。\n\n\n交叉连接：匹配每一行与另一张表中的所有行，输出笛卡尔积，即 nrow(x) × nrow(y)，用于生成所有排列组合。如下，输出结果是所有可能的名字对，包括自配（自己和自己）：\n\ndf &lt;- tibble(name = c(\"John\", \"Simon\", \"Tracy\", \"Max\"))\ndf |&gt; cross_join(df)\n#&gt; # A tibble: 16 × 2\n#&gt;   name.x name.y\n#&gt;   &lt;chr&gt;  &lt;chr&gt; \n#&gt; 1 John   John  \n#&gt; 2 John   Simon \n#&gt; ...\n\n\n\n不等连接：使用 &lt;, &lt;=, &gt;=, &gt; 来限制匹配的行，比如 x$key &lt; y$key。\n\n不等连接可以用于限制交叉连接的范围，比如只保留 id 小的组合，即生成组合而非排列：\ndf &lt;- tibble(id = 1:4, name = c(\"John\", \"Simon\", \"Tracy\", \"Max\"))\ndf |&gt; inner_join(df, join_by(id &lt; id))\n#&gt; # A tibble: 6 × 4\n#&gt;    id.x name.x  id.y name.y\n#&gt;   &lt;int&gt; &lt;chr&gt;  &lt;int&gt; &lt;chr&gt; \n#&gt; 1     1 John       2 Simon \n#&gt; 2     1 John       3 Tracy \n#&gt; ...\n\n\n\n滚动连接：一种特殊的不等连接，不会返回所有匹配的行，而是只返回最“接近”的一行。\n\n可以使用 closest() 实现滚动匹配：\n\njoin_by(closest(x &lt;= y))：找到最小的 y，使得 y ≥ x\njoin_by(closest(x &gt; y))：找到最大的 y，使得 y &lt; x\n\n\n\n\n重叠连接：可以更明确地处理区间范围匹配，有三个辅助函数：\n\n\nbetween(x, y_lower, y_upper) 等价于 x &gt;= y_lower, x &lt;= y_upper.\nwithin(x_lower, x_upper, y_lower, y_upper) 等价于 x_lower &gt;= y_lower, x_upper &lt;= y_upper.\noverlaps(x_lower, x_upper, y_lower, y_upper)等价于 x_lower &lt;= y_upper, x_upper &gt;= y_lower.",
    "crumbs": [
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>连接</span>"
    ]
  },
  {
    "objectID": "chapters/ch20_spreadsheets.html",
    "href": "chapters/ch20_spreadsheets.html",
    "title": "21  电子表格",
    "section": "",
    "text": "21.1 引言\n本书第7章已经讲解了如何从纯文本文件（如 .csv 和 .tsv）导入数据。现在是时候学习如何从电子表格中提取数据了，例如 Excel 文件和 Google 表格。本章内容在第7章基础上进行拓展。\n如果习惯使用电子表格来整理数据，本书强烈推荐阅读 Karl Broman 和 Kara Woo 撰写的论文《Data Organization in Spreadsheets》https://doi.org/10.1080/00031305.2017.1375989。",
    "crumbs": [
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>电子表格</span>"
    ]
  },
  {
    "objectID": "chapters/ch20_spreadsheets.html#excel",
    "href": "chapters/ch20_spreadsheets.html#excel",
    "title": "21  电子表格",
    "section": "21.2 Excel",
    "text": "21.2 Excel\nMicrosoft Excel 是一种广泛使用的电子表格软件，数据以工作表的形式组织在电子表格文件中。\n\n21.2.1 前置包\n本节介绍如何使用 readxl 包在 R 中加载 Excel 电子表格数据。该包不属于 tidyverse 核心包，因此需要显式加载，但在安装 tidyverse 时会自动安装。此外还会用到 writexl 包，该包可以用于创建 Excel 电子表格。\nlibrary(readxl)\nlibrary(tidyverse)\nlibrary(writexl)\n\n\n21.2.2 入门\nreadxl 提供的多数函数可将 Excel 表格加载到 R 中：\n\nread_xls() 读取 .xls 格式的 Excel 文件；\nread_xlsx() 读取 .xlsx 格式的 Excel 文件；\nread_excel() 可读取 .xls 和 .xlsx 两种格式的文件，它会根据输入自动识别文件类型。\n\n这些函数语法类似于其他读取函数，如 read_csv()、read_table() 等。\n\n\n21.2.3 读取 Excel 表格\n下图是一个Excel示例表格，包含6个学生的学号、姓名、食物喜好、就餐计划和年龄等信息。。该文件可通过以下链接下载：https://docs.google.com/spreadsheets/d/1V1nPp1tzOuutXFLb3G9Eyxi3qxeEhnOXUzL5_BcCQ0w/。\n\n如下将表格导入R，输出结果为一个 tibble，每位学生有 5 个变量：\nstudents &lt;- read_excel(\"data/students.xlsx\")\nstudents\n#&gt; # A tibble: 6 × 5\n#&gt;   `Student ID` `Full Name`      favourite.food     mealPlan            AGE  \n#&gt;          &lt;dbl&gt; &lt;chr&gt;            &lt;chr&gt;              &lt;chr&gt;               &lt;chr&gt;\n#&gt; 1            1 Sunil Huffmann   Strawberry yoghurt Lunch only          4    \n#&gt; 2            2 Barclay Lynn     French fries       Lunch only          5    \n#&gt; 3            3 Jayendra Lyne    N/A                Breakfast and lunch 7    \n#&gt; 4            4 Leon Rossini     Anchovies          Lunch only          &lt;NA&gt; \n#&gt; 5            5 Chidiegwu Dunkel Pizza              Breakfast and lunch five \n#&gt; 6            6 Güvenç Attila    Ice cream          Lunch only          6\n导入后观察，发现有格式问题：\n\n列名格式不一致。可通过 col_names 参数自定义列名（书中推荐使用snake_case命名法）：\n\nread_excel(\n  \"data/students.xlsx\",\n  col_names = c(\"student_id\", \"full_name\", \"favourite_food\", \"meal_plan\", \"age\")\n)\n然而改完后，表头行（即列名行）成了数据的第 1 行。可使用 skip 参数跳过该行：\nread_excel(\n  \"data/students.xlsx\",\n  col_names = c(\"student_id\", \"full_name\", \"favourite_food\", \"meal_plan\", \"age\"),\n  skip = 1\n)\n\nfavourite_food 中有值为 “N/A”，且未被识别为缺失值 NA（如果被识别则显示&lt;NA&gt;）。可通过 na 参数指定缺失值字符：\n\nread_excel(\n  \"data/students.xlsx\",\n  col_names = c(\"student_id\", \"full_name\", \"favourite_food\", \"meal_plan\", \"age\"),\n  skip = 1,\n  na = c(\"\", \"N/A\")\n)\n\nage 被读取为字符型，但应为数值型。可通过 col_types 参数自定义列类型：\n\nread_excel(\"data/students.xlsx\",\n           col_names = c(...),\n           skip = 1,\n           na = c(\"\", \"N/A\"),\n           col_types = c(\"numeric\", \"text\", \"text\", \"text\", \"numeric\"))\n\n可用选项包括：“skip”、“guess”、“logical”、“numeric”、“date”、“text”、“list”。\n\n\n\n21.2.4 读取工作表\n与纯文本文件相比，电子表格支持多个工作表（worksheets）。下图展示了包含多个工作表的 Excel 文件。数据来自 palmerpenguins 包，可通过此链接下载示例表格：https://docs.google.com/spreadsheets/d/1aFu8lnD_g0yjF5O-K6SFgSEWiHPpgvFCF0NY9D6LXnY/。\n\n使用read_excel()函数的sheet参数可以选择读取哪个工作表，默认读取第一个。\nread_excel(\"data/penguins.xlsx\", sheet = \"Torgersen Island\")\n使用 excel_sheets() 可查看所有工作表名称：\nexcel_sheets(\"data/penguins.xlsx\")\n#&gt; [1] \"Torgersen Island\" \"Biscoe Island\" \"Dream Island\"\n随后分别读取：\npenguins_biscoe &lt;- read_excel(\"data/penguins.xlsx\", sheet = \"Biscoe Island\", na = \"NA\")\npenguins_dream &lt;- read_excel(\"data/penguins.xlsx\", sheet = \"Dream Island\", na = \"NA\")\n使用 bind_rows() 合并三张表：\npenguins &lt;- bind_rows(penguins_torgersen, penguins_biscoe, penguins_dream)\n\n\n21.2.5 读取工作表的特定部分\n很多 Excel 表格不仅包含数据，还包含注释等非数据内容。比如下图，数据前后有冗余文本行。\n\n此表格可通过 readxl_example() 函数定位：\ndeaths_path &lt;- readxl_example(\"deaths.xlsx\")\ndeaths &lt;- read_excel(deaths_path)\n使用 range 参数可仅读取所需区域。例如数据从 A5 到 F15：\nread_excel(deaths_path, range = \"A5:F15\")\n\n\n21.2.6 数据类型\nCSV 中所有值为字符串，而 Excel 则较为复杂：\n\n布尔值（TRUE、FALSE、NA）\n数字（如 10 或 10.5）\n日期时间（如 2021/11/1 15:00）\n文本（如 “ten”）\n\nExcel 内部不区分整数，所有数字均为浮点数。\nreadxl 会自动猜测列类型。推荐如下工作流程：\n\n初步读取并让 readxl 猜测；\n检查类型；\n若有瑕疵，重新指定 col_types。\n\n如某列类型混合（数值、文本、日期），可设为 \"list\"，每个单元格为一个单值向量。\n\n\n21.2.7 写入 Excel\n创建一个小数据框：\nbake_sale &lt;- tibble(\n  item     = factor(c(\"brownie\", \"cupcake\", \"cookie\")),\n  quantity = c(10, 5, 8)\n)\n使用 writexl::write_xlsx() 写入 Excel：\nwrite_xlsx(bake_sale, path = \"data/bake-sale.xlsx\")\n读取回来：\nread_excel(\"data/bake-sale.xlsx\")\n注意重新读取时，数据类型信息会丢失，因此 Excel 文件并不适合用于缓存中间结果。\n\n\n21.2.8 格式化输出\nwritexl 是轻量级写入工具，若需更多功能（如写入多个工作表、样式设置），推荐使用 openxlsx 包。使用方法详见其官方文档：openxlsx formatting。\n该包不属于 tidyverse，其函数风格与 tidyverse 不同。",
    "crumbs": [
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>电子表格</span>"
    ]
  },
  {
    "objectID": "chapters/ch20_spreadsheets.html#google-表格",
    "href": "chapters/ch20_spreadsheets.html#google-表格",
    "title": "21  电子表格",
    "section": "21.3 Google 表格",
    "text": "21.3 Google 表格\nGoogle 表格（Google Sheets）是另一种广泛使用的电子表格程序。它是免费、基于网页的。和 Excel 一样，Google 表格中的数据以工作表（也称为 sheets）的形式组织在电子表格文件中。\n\n21.3.1 前置包\n使用 googlesheets4 包从 Google 表格中加载数据。该包同样不是 tidyverse 的核心包，因此也需要显式加载。\nlibrary(googlesheets4)\nlibrary(tidyverse)\n关于包名的一点说明：googlesheets4 使用的是 Google Sheets API 的第 4 版（v4）来为 Google 表格提供 R 接口，因此包名中有 “4”。\n\n\n21.3.2 入门\ngooglesheets4 包的主要函数是 read_sheet()，它用于从 URL 或文件 ID 中读取 Google 表格。该函数也可以写成 range_read()。\n也可以使用 gs4_create() 创建一个全新的表格，或者使用 sheet_write()将数据写入已有表格。\n\n\n21.3.3 读取 Google 表格\n下图是Google 表格呈现的20.2.3节数据集。\n\nURL 是 read_sheet() 的第一个参数，可返回一个 tibble：\nhttps://docs.google.com/spreadsheets/d/1V1nPp1tzOuutXFLb3G9Eyxi3qxeEhnOXUzL5_BcCQ0w\nURL 不太方便操作，因此通常通过 ID 来识别一个表格。所谓 ID 就是 URL 的后半段。\ngs4_deauth()\n\nstudents_sheet_id &lt;- \"1V1nPp1tzOuutXFLb3G9Eyxi3qxeEhnOXUzL5_BcCQ0w\"\nstudents &lt;- read_sheet(students_sheet_id)\n#&gt; ✔ Reading from students.\n#&gt; ✔ Range Sheet1.\nstudents\n#&gt; # A tibble: 6 × 5\n#&gt;   `Student ID` `Full Name`      favourite.food     mealPlan            AGE   \n#&gt;          &lt;dbl&gt; &lt;chr&gt;            &lt;chr&gt;              &lt;chr&gt;               &lt;list&gt;\n#&gt; 1            1 Sunil Huffmann   Strawberry yoghurt Lunch only          &lt;dbl&gt; \n#&gt; 2            2 Barclay Lynn     French fries       Lunch only          &lt;dbl&gt; \n#&gt; 3            3 Jayendra Lyne    N/A                Breakfast and lunch &lt;dbl&gt; \n#&gt; 4            4 Leon Rossini     Anchovies          Lunch only          &lt;NULL&gt;\n#&gt; 5            5 Chidiegwu Dunkel Pizza              Breakfast and lunch &lt;chr&gt; \n#&gt; 6            6 Güvenç Attila    Ice cream          Lunch only          &lt;dbl&gt; \n与 read_excel()类似 ， read_sheet() 同样有关于列名、NA 字符串和列类型的一系列操作：\nstudents &lt;- read_sheet(\n  students_sheet_id,\n  col_names = c(\"student_id\", \"full_name\", \"favourite_food\", \"meal_plan\", \"age\"),\n  skip = 1,\n  na = c(\"\", \"N/A\"),\n  col_types = \"dcccc\"\n)\n#&gt; ✔ Reading from students.\n#&gt; ✔ Range 2:10000000.\nstudents\n#&gt; # A tibble: 6 × 5\n#&gt;   student_id full_name        favourite_food     meal_plan           age  \n#&gt;        &lt;dbl&gt; &lt;chr&gt;            &lt;chr&gt;              &lt;chr&gt;               &lt;chr&gt;\n#&gt; 1          1 Sunil Huffmann   Strawberry yoghurt Lunch only          4    \n#&gt; 2          2 Barclay Lynn     French fries       Lunch only          5    \n#&gt; 3          3 Jayendra Lyne    &lt;NA&gt;               Breakfast and lunch 7    \n#&gt; 4          4 Leon Rossini     Anchovies          Lunch only          &lt;NA&gt; \n#&gt; 5          5 Chidiegwu Dunkel Pizza              Breakfast and lunch five \n#&gt; 6          6 Güvenç Attila    Ice cream          Lunch only          6\n注意这里使用简写方式定义了列类型，col_types = \"dcccc\"表示 “浮点数、字符、字符、字符、字符”。\n同样也可以读取 Google 表格中的某个单独工作表。比如 penguins 表格中的 \"Torgersen Island\" 工作表：\npenguins_sheet_id &lt;- \"1aFu8lnD_g0yjF5O-K6SFgSEWiHPpgvFCF0NY9D6LXnY\"\nread_sheet(penguins_sheet_id, sheet = \"Torgersen Island\")\n用 sheet_names() 查看该 Google 表格中的所有工作表名称：\nsheet_names(penguins_sheet_id)\n#&gt; [1] \"Torgersen Island\" \"Biscoe Island\"    \"Dream Island\"\nread_sheet() 函数的range参数可用于定位表格范围，读取特定部分数据：\ndeaths_url &lt;- gs4_example(\"deaths\")\ndeaths &lt;- read_sheet(deaths_url, range = \"A5:F15\")\n\n\n21.3.4 写入 Google 表格\n使用 write_sheet() 将 R 中的数据写入 Google 表格。第一个参数是要写入的数据框，第二个参数是目标 Google 表格的名称：\nwrite_sheet(bake_sale, ss = \"bake-sale\")\n如果要将数据写入某个特定的工作表（sheet），可以使用 sheet 参数指定：\nwrite_sheet(bake_sale, ss = \"bake-sale\", sheet = \"Sales\")\n\n\n21.3.5 身份验证\n要读取私密表格或写入任何Google表格，需要进行身份验证，以便 googlesheets4 能访问并管理表格。\n在尝试读取一个需要验证的表格时，googlesheets4 会提示跳转一个网页，登录 Google 账户进行授权。\n如果希望指定具体的 Google 账户、身份验证作用域等，可以使用 gs4_auth()，例如：\ngs4_auth(email = \"jiading@gmail.com\")",
    "crumbs": [
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>电子表格</span>"
    ]
  },
  {
    "objectID": "chapters/ch21_databases.html",
    "href": "chapters/ch21_databases.html",
    "title": "22  数据库",
    "section": "",
    "text": "22.1 引言\n数据主要存储在数据库中，因此掌握直接查询的方法很关键。偶尔请人导出一份数据快照或许可行，但很快就会变得麻烦，因为每个微小的调整都需要重新沟通和协调。\n本章将介绍 DBI 与 dbplyr。DBI 是一个低层接口，用于连接数据库并执行 SQL 语句；dbplyr 则是一个高层接口，可将 dplyr 代码翻译成 SQL 查询，并借助 DBI 执行这些查询。",
    "crumbs": [
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>数据库</span>"
    ]
  },
  {
    "objectID": "chapters/ch21_databases.html#引言",
    "href": "chapters/ch21_databases.html#引言",
    "title": "22  数据库",
    "section": "",
    "text": "library(DBI)\nlibrary(dbplyr)\nlibrary(tidyverse)",
    "crumbs": [
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>数据库</span>"
    ]
  },
  {
    "objectID": "chapters/ch21_databases.html#数据库基础",
    "href": "chapters/ch21_databases.html#数据库基础",
    "title": "22  数据库",
    "section": "22.2 数据库基础",
    "text": "22.2 数据库基础\n从最简单的层面来看，可以将数据库视为一组数据框的集合，在数据库术语中称为“表格（tables）”。与数据框类似，数据库表也是一组具名列的集合，其每一列中所有值的类型相同。\n数据库表与数据框之间存在三个关键区别：\n\n数据库表存储在磁盘上，可以无限大；而数据框存储在内存中，其大小受内存限制。\n数据库表几乎都有索引，能快速定位某行，而无需遍历整个表；数据框和 tibble 没有索引机制。\n传统数据库通常针对数据写入的速度进行优化，从而按行存储数据，被称为“面向行（row-oriented）”；而 R 数据框是按列存储的。\n\n数据库由“数据库管理系统”（Database Management Systems，简称 DBMS）管理。DBMS 大致可以分为三类：\n\n客户端-服务器型（Client-server DBMS）：运行在功能强大的中央服务器上，用户通过本地计算机（客户端）进行连接。适合在组织中多人共享数据。常见的有 PostgreSQL、MariaDB、SQL Server 和 Oracle。\n云数据库（Cloud DBMS）：例如 Snowflake、Amazon RedShift 和 Google BigQuery，与客户端-服务器型类似，但运行在云端。这类系统可轻松处理超大规模数据集，并能根据需要自动扩展计算资源。\n本地进程内数据库（In-process DBMS）：如 SQLite 和 duckdb，完全在本地计算机上运行。适合个人用户处理大型数据集。",
    "crumbs": [
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>数据库</span>"
    ]
  },
  {
    "objectID": "chapters/ch21_databases.html#连接到数据库",
    "href": "chapters/ch21_databases.html#连接到数据库",
    "title": "22  数据库",
    "section": "22.3 连接到数据库",
    "text": "22.3 连接到数据库\n要在 R 中连接数据库，需要使用一对有配套效果的包，分别的作用如下：\n\nDBI包（database interface，数据库接口），可提供一组通用函数，用于连接数据库、上传数据、执行 SQL 查询等。\n专门针对目标 DBMS ，将 DBI 的通用命令翻译为特定数据库系统所需的具体操作。通常每种数据库系统都有一个对应的包，例如 RPostgres 用于 PostgreSQL，RMariaDB 用于 MySQL。\n\n具体而言，首先用 DBI::dbConnect() 创建一个数据库连接。第一个参数用于指定 DBMS，后续参数则提供数据库的连接信息（比如服务器地址和访问凭证）。以下是几个典型例子：\ncon &lt;- DBI::dbConnect(\n  RMariaDB::MariaDB(), \n  username = \"foo\"\n)\n\ncon &lt;- DBI::dbConnect(\n  RPostgres::Postgres(), \n  hostname = \"databases.mycompany.com\", \n  port = 1234\n)\n不同数据库系统的连接细节差异很大，初次设置时可能需要反复尝试，但通常只需配置一次即可。\n本书使用一种完全基于 R 包的进程内数据库duckdb。\n连接 duckdb 特别简单，默认创建一个临时数据库，R 会话结束时自动删除。所以每次重新启动 R，都是一个干净的环境：\ncon &lt;- DBI::dbConnect(duckdb::duckdb())\nduckdb 是一个高性能数据库，专门为数据科学家的需求而设计，也非常容易上手。如果要将它用于实际项目，还需要指定 dbdir 参数，用于创建持久化数据库并告知保存位置。如果创建的是 RStudio 项目，就可以把它保存在项目目录下的 duckdb 文件夹中：\ncon &lt;- DBI::dbConnect(duckdb::duckdb(), dbdir = \"duckdb\")\n由于连接的是一个全新的数据库，所以接下来要加载一些数据。\n下面举例，用 DBI::dbWriteTable() 将 ggplot2 包中的 mpg 和 diamonds 数据集载入数据库。dbWriteTable() 的最简用法需要三个参数：数据库连接、要创建的表名、一个数据框：\ndbWriteTable(con, \"mpg\", ggplot2::mpg)\ndbWriteTable(con, \"diamonds\", ggplot2::diamonds)\n\n如果在实际项目中使用 duckdb，强烈建议学习 duckdb_read_csv() 和 duckdb_register_arrow()。这些函数提供了更强大、高效的方式，可以直接从磁盘加载数据进入数据库，无需先导入 R 内存中。\n\n载入后，可以使用一些 DBI 提供的函数，检查数据是否加载成功：\n\ndbListTables()：列出数据库中的所有表。\ndbReadTable()：读取数据库中某张表的全部内容。\n\n示例：\ndbListTables(con)\n#&gt; [1] \"diamonds\" \"mpg\"\n\ncon |&gt; \n  dbReadTable(\"diamonds\") |&gt; \n  as_tibble()\n# A tibble: 53,940 × 10\n   carat cut       color clarity depth table price     x     y     z\n   &lt;dbl&gt; &lt;fct&gt;     &lt;fct&gt; &lt;fct&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n 1  0.23 Ideal     E     SI2      61.5    55   326  3.95  3.98  2.43\n 2  0.21 Premium   E     SI1      59.8    61   326  3.89  3.84  2.31\n ...\ndbReadTable() 返回的是 data.frame，我们使用 as_tibble() 转换为 tibble，让输出效果更优雅。",
    "crumbs": [
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>数据库</span>"
    ]
  },
  {
    "objectID": "chapters/ch21_databases.html#dbplyr-基础",
    "href": "chapters/ch21_databases.html#dbplyr-基础",
    "title": "22  数据库",
    "section": "22.4 dbplyr 基础",
    "text": "22.4 dbplyr 基础\ndbplyr 是 dplyr 的后端实现，会将操作翻译为 SQL，这意味着虽然我们编写的是 dplyr 代码，但其执行方式有些不同。除了 dbplyr 外还有其他后端，包括将代码翻译为 data.table 的 dtplyr，以及在多个核心上并行执行代码的 multidplyr。\n要使用 dbplyr，首先需要用 tbl() 函数创建一个代表数据库中某张表的对象：\ndiamonds_db &lt;- tbl(con, \"diamonds\")\n这个对象是惰性的，当对其使用 dplyr 动词（如 filter()、select() 等）时，dplyr 实际上并不会立即执行任何操作，只是记录下我们想执行的一系列操作，直到真正需要结果时才会执行。比如，下面这个数据处理流程：\nbig_diamonds_db &lt;- diamonds_db |&gt; \n  filter(price &gt; 15000) |&gt; \n  select(carat:clarity, price)\n然后查看这个对象：\nbig_diamonds_db #此时才执行\n#&gt; # Source:   SQL [?? x 5]\n#&gt; # Database: DuckDB v1.3.2 [unknown@Linux 6.11.0-1018-azure:R 4.5.1/:memory:]\n#&gt;   carat cut       color clarity price\n#&gt;   &lt;dbl&gt; &lt;fct&gt;     &lt;fct&gt; &lt;fct&gt;   &lt;int&gt;\n#&gt; 1  1.54 Premium   E     VS2     15002\n#&gt; 2  1.19 Ideal     F     VVS1    15005\n#&gt; 3  2.1  Premium   I     SI1     15007\n#&gt; 4  1.69 Ideal     D     SI1     15011\n#&gt; 5  1.5  Very Good G     VVS2    15013\n#&gt; 6  1.73 Very Good G     VS1     15014\n#&gt; # ℹ more rows\n可以通过上面输出顶部的信息看出该对象表示的是一个数据库查询，比如它显示了使用的数据库系统名称，并显示了列数，但行数通常不确定，因为获取行数需要完整执行整个查询。\n对这个惰性对象使用 show_query() 可以查看由 dplyr 操作生成的 SQL 语句。可以写一些 dplyr 代码，让 dbplyr 把它翻译成 SQL，从而很便于理解两种语言是如何一一对应的。比如：\nbig_diamonds_db |&gt; \n  show_query()\n#&gt; &lt;SQL&gt;\n#&gt; SELECT carat, cut, color, clarity, price\n#&gt; FROM diamonds\n#&gt; WHERE (price &gt; 15000.0)\n要将查询结果真正取回到 R 中使用，可以调用 collect()函数，幕后同样会生成 SQL 查询。\nbig_diamonds &lt;- big_diamonds_db |&gt; \n  collect()\n\nbig_diamonds\n#&gt; # A tibble: 1,655 × 5\n#&gt;   carat cut       color clarity price\n#&gt;   &lt;dbl&gt; &lt;fct&gt;     &lt;fct&gt; &lt;fct&gt;   &lt;int&gt;\n#&gt; 1  1.54 Premium   E     VS2     15002\n#&gt; 2  1.19 Ideal     F     VVS1    15005\n#&gt; 3  2.1  Premium   I     SI1     15007\n#&gt; 4  1.69 Ideal     D     SI1     15011\n#&gt; 5  1.5  Very Good G     VVS2    15013\n#&gt; 6  1.73 Very Good G     VS1     15014\n#&gt; # ℹ 1,649 more rows\n总结以上流程：\n\n使用 dbplyr 从数据库中筛选需要的数据，使用 dplyr 提供的动词进行基本的筛选和聚合。\n调用 collect() 将数据收集到 R 内存中（比如一个 tibble），然后便可用 R 分析数据。",
    "crumbs": [
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>数据库</span>"
    ]
  },
  {
    "objectID": "chapters/ch21_databases.html#sql",
    "href": "chapters/ch21_databases.html#sql",
    "title": "22  数据库",
    "section": "22.5 SQL",
    "text": "22.5 SQL\n本节通过 dbplyr 的视角讲述 SQL相关知识。\n下面的例子依旧使用 nycflights13 包中的两个老朋友 —— flights 和 planes ，探讨 dplyr 和 SQL 之间的关系。\ndbplyr::copy_nycflights13(con) # 这是一个专门函数，将 nycflights13 中的表复制到数据库\n#&gt; Creating table: airlines\n#&gt; Creating table: airports\n#&gt; Creating table: flights\n#&gt; Creating table: planes\n#&gt; Creating table: weather\nflights &lt;- tbl(con, \"flights\")\nplanes &lt;- tbl(con, \"planes\")\n\n\n22.5.1 基础\nSQL 的顶层组成部分称为 语句（statements）。常见的语句包括 CREATE（定义新表）、INSERT（添加数据）和 SELECT（检索数据）。作为数据科学学习者，我们将专注于 SELECT 语句，亦称作查询（queries），今后几乎只会使用这一个语句。\n一个查询由多个 子句（clauses） 构成。最重要的五个子句是：SELECT、FROM、WHERE、ORDER BY 和 GROUP BY。每个查询必须包含 SELECT 和 FROM 子句，故最简单的查询语句是：\nSELECT * FROM table #从指定表中选择所有列\n这也是dbplyr给未加工表生成的 SQL语句：\nflights |&gt; show_query()\n#&gt; &lt;SQL&gt;\n#&gt; SELECT *\n#&gt; FROM flights\n\nplanes |&gt; show_query()\n#&gt; &lt;SQL&gt;\n#&gt; SELECT *\n#&gt; FROM planes\nWHERE 和 ORDER BY 分别用于指定包含哪些行，以及行的排序方式：\nflights |&gt; \n  filter(dest == \"IAH\") |&gt; \n  arrange(dep_delay) |&gt;\n  show_query()\n#&gt; &lt;SQL&gt;\n#&gt; SELECT flights.*\n#&gt; FROM flights\n#&gt; WHERE (dest = 'IAH')\n#&gt; ORDER BY dep_delay\nGROUP BY 将查询转换为汇总，触发聚合操作：\nflights |&gt; \n  group_by(dest) |&gt; \n  summarize(dep_delay = mean(dep_delay, na.rm = TRUE)) |&gt; \n  show_query()\n#&gt; &lt;SQL&gt;\n#&gt; SELECT dest, AVG(dep_delay) AS dep_delay\n#&gt; FROM flights\n#&gt; GROUP BY dest\ndplyr 动词与 SELECT 子句之间有两个重要区别：\n\n在 SQL 中，大小写不敏感：你可以写 select、SELECT，甚至是 SeLeCt。本书则遵循通用约定，将 SQL 关键字用大写表示，以便于区分表名或变量名。\n在 SQL 中，顺序很重要：子句的顺序必须是 SELECT、FROM、WHERE、GROUP BY、ORDER BY。不过实际的执行顺序是 FROM → WHERE → GROUP BY → SELECT → ORDER BY。\n\n接下来的小节将更详细地探讨每个子句。\n\n\n\n22.5.2 SELECT\nSELECT 子句是查询的核心，对应的 dplyr 函数有：select()、mutate()、rename()、relocate()、 summarize()。\nselect()、rename() 和 relocate() 翻译成 SELECT 的方式非常直接，仅影响列的名称、位置：\nplanes |&gt; \n  select(tailnum, type, manufacturer, model, year) |&gt; \n  show_query()\n#&gt; &lt;SQL&gt;\n#&gt; SELECT tailnum, \"type\", manufacturer, model, \"year\"\n#&gt; FROM planes\n\nplanes |&gt; \n  select(tailnum, type, manufacturer, model, year) |&gt; \n  rename(year_built = year) |&gt; \n  show_query()\n#&gt; &lt;SQL&gt;\n#&gt; SELECT tailnum, \"type\", manufacturer, model, \"year\" AS year_built\n#&gt; FROM planes\n\nplanes |&gt; \n  select(tailnum, type, manufacturer, model, year) |&gt; \n  relocate(manufacturer, model, .before = type) |&gt; \n  show_query()\n#&gt; &lt;SQL&gt;\n#&gt; SELECT tailnum, manufacturer, model, \"type\", \"year\"\n#&gt; FROM planes\n这个示例也展示了 SQL 如何进行重命名。SQL 中这种重命名被称为 别名（aliasing），使用 AS 实现。注意与 mutate() 相反，旧名称在左，新名称在右。\n上面的示例中，\"year\" 和 \"type\" 被双引号包裹，是因为这些是 duckdb 中的保留字，所以 dbplyr 使用引号避免与 SQL 操作符混淆。\n\n保留字（Reserved words），也叫关键词（keywords），是指在编程语言或数据库语言（如SQL）中已经被赋予特定意义、不能用作变量名、表名、字段名等标识符的词语。\n\n对 mutate() 的翻译同样很直接，每个变量变成 SELECT 中的一个新表达式：\nflights |&gt; \n  mutate(\n    speed = distance / (air_time / 60)\n  ) |&gt; \n  show_query()\n#&gt; &lt;SQL&gt;\n#&gt; SELECT flights.*, distance / (air_time / 60.0) AS speed\n#&gt; FROM flights\n\n\n\n22.5.3 FROM 子句\nFROM 子句定义了数据来源。\n当前阶段这部分内容无需深入，因为目前只使用单个表。但在后续学习连接函数时，会遇到更复杂的例子。\n\n\n22.5.3.0.1 21.5.4 GROUP BY 子句\ngroup_by() 被翻译为 GROUP BY 子句，而 summarize() 则被翻译为 SELECT 子句：\ndiamonds_db |&gt; \n  group_by(cut) |&gt; \n  summarize(\n    n = n(),\n    avg_price = mean(price, na.rm = TRUE)\n  ) |&gt; \n  show_query()\n输出 SQL：\nSELECT cut, COUNT(*) AS n, AVG(price) AS avg_price\nFROM diamonds\nGROUP BY cut\n\n\n\n\n22.5.4 WHERE 子句\nfilter() 被翻译为 WHERE 子句。比如：\nflights |&gt; \n  filter(dest == \"IAH\" | dest == \"HOU\") |&gt; \n  show_query()\n#&gt; &lt;SQL&gt;\n#&gt; SELECT flights.*\n#&gt; FROM flights\n#&gt; WHERE (dest = 'IAH' OR dest = 'HOU')\n\nflights |&gt; \n  filter(arr_delay &gt; 0 & arr_delay &lt; 20) |&gt; \n  show_query()\n#&gt; &lt;SQL&gt;\n#&gt; SELECT flights.*\n#&gt; FROM flights\n#&gt; WHERE (arr_delay &gt; 0.0 AND arr_delay &lt; 20.0)\n重要细节：\n\n| 被转换为 SQL 的 OR，& 转换为 AND。\nSQL 使用 = 比较值，而不是 ==。\nSQL 使用单引号 'text' 表示字符串，而不是双引号。双引号用于标注保留字。\n\n另外，SQL 中使用 IN 操作符来表示 %in%：\nflights |&gt; \n  filter(dest %in% c(\"IAH\", \"HOU\")) |&gt; \n  show_query()\n#&gt; &lt;SQL&gt;\n#&gt; SELECT flights.*\n#&gt; FROM flights\n#&gt; WHERE (dest IN ('IAH', 'HOU'))\nSQL 使用 NULL 表示缺失值，与 R 中的 NA 类似。但是，在聚合时 SQL 默认忽略 NULL 值，而 R 中必须显式设置 na.rm = TRUE。比如以下操作：\nflights |&gt; \n  group_by(dest) |&gt; \n  summarize(delay = mean(arr_delay))\n这将给出一个警告，提醒 NULL 会自动被 SQL 聚合函数忽略。\n若想移除缺失值，可以使用：\nflights |&gt; \n  filter(!is.na(dep_delay)) |&gt; \n  show_query()\n#&gt; &lt;SQL&gt;\n#&gt; SELECT flights.*\n#&gt; FROM flights\n#&gt; WHERE (NOT((dep_delay IS NULL)))\n虽然这行 WHERE 子句是正确的，但并不简洁，我们自己可以写成：\nWHERE dep_delay IS NOT NULL\n注意， 如果在 summarize() 后再对某变量进行 filter()，dbplyr 会生成 HAVING 子句而不是 WHERE。正如前文所示，这是 SQL 的执行流程，WHERE 会在 SELECT 和 GROUP BY 之前执行，而 HAVING 在之后。\ndiamonds_db |&gt; \n  group_by(cut) |&gt; \n  summarize(n = n()) |&gt; \n  filter(n &gt; 100) |&gt; \n  show_query()\n#&gt; &lt;SQL&gt;\n#&gt; SELECT cut, COUNT(*) AS n\n#&gt; FROM diamonds\n#&gt; GROUP BY cut\n#&gt; HAVING (COUNT(*) &gt; 100.0)\n\n\n\n22.5.5 ORDER BY 子句\n排序操作使用的 arrange()函数会被翻译为 ORDER BY：\nflights |&gt; \n  arrange(year, month, day, desc(dep_delay)) |&gt; \n  show_query()\n#&gt; &lt;SQL&gt;\n#&gt; SELECT flights.*\n#&gt; FROM flights\n#&gt; ORDER BY \"year\", \"month\", \"day\", dep_delay DESC\n\ndesc() 被翻译成 SQL 的 DESC。\n\n\n\n\n22.5.6 子查询\n有时无法将dplyr管道转换为单个SELECT语句，此时需要使用子查询。子查询是指作为FROM子句数据源（而非常规表）的查询语句。\ndbplyr通常通过子查询来解决SQL的语法限制。例如：\n\nSELECT子句限制：SELECT中的表达式不能引用刚创建的列。因此以下dplyr管道需分两步执行：内层查询计算year1，外层查询才能计算year2。\n\nflights |&gt; \n  mutate(\n    year1 = year + 1,\n    year2 = year1 + 1\n  ) |&gt; \n  show_query()\n#&gt; &lt;SQL&gt;\n#&gt; SELECT q01.*, year1 + 1.0 AS year2\n#&gt; FROM (\n#&gt;   SELECT flights.*, \"year\" + 1.0 AS year1\n#&gt;   FROM flights\n#&gt; ) q01\n\n如果在SQL中直接尝试：\nSELECT \nyear + 1 AS year1,\nyear1 + 1 AS year2  # 会报错：Unknown column 'year1'\nFROM flights\n错误原因：SQL引擎按子句顺序执行（FROM → WHERE → GROUP BY → HAVING → SELECT），SELECT中的列尚未生成时就被引用。\n\n\nWHERE子句限制：过滤新创建的变量时同样需要子查询。\n\nflights |&gt; \n  mutate(year1 = year + 1) |&gt; \n  filter(year1 == 2014) |&gt; \n  show_query()\n#&gt; &lt;SQL&gt;\n#&gt; SELECT q01.*\n#&gt; FROM (\n#&gt;   SELECT flights.*, \"year\" + 1.0 AS year1\n#&gt;   FROM flights\n#&gt; ) q01\n#&gt; WHERE (year1 = 2014.0)\n\n\n\n22.5.7 连接\nSQL的连接与dplyr非常相似。以下是一个简单示例：\nflights |&gt; \n  left_join(planes |&gt; rename(year_built = year), join_by(tailnum)) |&gt; \n  show_query()\n#&gt; &lt;SQL&gt;\n#&gt; SELECT\n#&gt;   flights.*,\n#&gt;   planes.\"year\" AS year_built,\n#&gt;   \"type\",\n#&gt;   manufacturer,\n#&gt;   model,\n#&gt;   engines,\n#&gt;   seats,\n#&gt;   speed,\n#&gt;   engine\n#&gt; FROM flights\n#&gt; LEFT JOIN planes\n#&gt;   ON (flights.tailnum = planes.tailnum)\n此处需注意语法特性，SQL连接通过FROM子句的子句引入附加表，并使用ON定义表间关系。\nSQL的其他连接操作与dplyr的连接函数也基本相同：\n\n内连接：\nSELECT flights.*, \"type\", manufacturer, model, engines, seats, speed\nFROM flights\nINNER JOIN planes ON (flights.tailnum = planes.tailnum)\n右连接：\nSELECT flights.*, \"type\", manufacturer, model, engines, seats, speed\nFROM flights\nRIGHT JOIN planes ON (flights.tailnum = planes.tailnum)\n全连接：\nSELECT flights.*, \"type\", manufacturer, model, engines, seats, speed\nFROM flights\nFULL JOIN planes ON (flights.tailnum = planes.tailnum)\n\n\n\n\n22.5.8 其他动词\ndbplyr还能转换更多操作。\n访问dbplyr官网可查看完整的支持函数列表：https://dbplyr.tidyverse.org/reference/",
    "crumbs": [
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>数据库</span>"
    ]
  },
  {
    "objectID": "chapters/ch21_databases.html#函数转换机制",
    "href": "chapters/ch21_databases.html#函数转换机制",
    "title": "22  数据库",
    "section": "22.6 函数转换机制",
    "text": "22.6 函数转换机制\n至此我们已探讨了dplyr动词转换为查询子句的整体框架。现在让我们聚焦于单个列操作的R函数转换细节，例如在summarize()中使用mean(x)时，幕后到底发生了什么。\n为便于观察，创建两个辅助函数来展示生成的SQL：\nsummarize_query &lt;- function(df, ...) {\n  df |&gt; \n    summarize(...) |&gt; \n    show_query()\n}\n\nmutate_query &lt;- function(df, ...) {\n  df |&gt; \n    mutate(..., .keep = \"none\") |&gt; \n    show_query()\n}\n\n基础聚合函数转换\n\n观察以下代码时会发现，像mean()这样的汇总函数转换相对简单，而median()等函数的转换则复杂得多。之所以存在这种复杂度差异，主要因为统计分析中常见的操作在数据库中并不常见。\nflights |&gt; \n  group_by(year, month, day) |&gt;  \n  summarize_query(\n    mean = mean(arr_delay, na.rm = TRUE),\n    median = median(arr_delay, na.rm = TRUE)\n  )\n#&gt; `summarise()` has grouped output by \"year\" and \"month\". You can override\n#&gt; using the `.groups` argument.\n#&gt; &lt;SQL&gt;\n#&gt; SELECT\n#&gt;   \"year\",\n#&gt;   \"month\",\n#&gt;   \"day\",\n#&gt;   AVG(arr_delay) AS mean,\n#&gt;   MEDIAN(arr_delay) AS median\n#&gt; FROM flights\n#&gt; GROUP BY \"year\", \"month\", \"day\"\n\n窗口函数转换\n\n当在mutate()中使用聚合函数时，它们会转换为窗口函数，通过在普通聚合函数后添加OVER子句实现：\nflights |&gt; \n  group_by(year, month, day) |&gt;  \n  mutate_query(\n    mean = mean(arr_delay, na.rm = TRUE),\n  )\n#&gt; &lt;SQL&gt;\n#&gt; SELECT\n#&gt;   \"year\",\n#&gt;   \"month\",\n#&gt;   \"day\",\n#&gt;   AVG(arr_delay) OVER (PARTITION BY \"year\", \"month\", \"day\") AS mean\n#&gt; FROM flights\n\n窗口函数（Window Functions）是SQL中一种强大的分析工具，它能在不减少行数的情况下执行计算，同时保留原始数据的完整性。\n\n\n前后值函数实现\n\n转换成窗口函数的对象还包括lead()和lag()等前瞻/回溯函数：\nflights |&gt; \n  group_by(dest) |&gt;  \n  arrange(time_hour) |&gt; \n  mutate_query(\n    lead = lead(arr_delay),\n    lag = lag(arr_delay)\n  )\n#&gt; &lt;SQL&gt;\n#&gt; SELECT\n#&gt;   dest,\n#&gt;   LEAD(arr_delay, 1, NULL) OVER (PARTITION BY dest ORDER BY time_hour) AS lead,\n#&gt;   LAG(arr_delay, 1, NULL) OVER (PARTITION BY dest ORDER BY time_hour) AS lag\n#&gt; FROM flights\n#&gt; ORDER BY time_hour\n\n注意：\n\n必须使用arrange()排序，因为SQL表本身没有固有顺序。\n窗口函数的排序条件需要单独声明。\n\n\n\n条件表达式转换\n\nCASE WHEN是转换if_else()和case_when()的核心结构：\n# if_else转换\nflights |&gt; \n  mutate_query(\n    description = if_else(arr_delay &gt; 0, \"delayed\", \"on-time\")\n  )\n#&gt; &lt;SQL&gt;\n#&gt; SELECT CASE WHEN (arr_delay &gt; 0.0) THEN 'delayed' WHEN NOT (arr_delay &gt; 0.0) THEN 'on-time' END AS description\n#&gt; FROM flights\n\n# case_when转换\nflights |&gt; \n  mutate_query(\n    description = \n      case_when(\n        arr_delay &lt; -5 ~ \"early\", \n        arr_delay &lt; 5 ~ \"on-time\",\n        arr_delay &gt;= 5 ~ \"late\"\n      )\n  )\n#&gt; &lt;SQL&gt;\n#&gt; SELECT CASE\n#&gt; WHEN (arr_delay &lt; -5.0) THEN 'early'\n#&gt; WHEN (arr_delay &lt; 5.0) THEN 'on-time'\n#&gt; WHEN (arr_delay &gt;= 5.0) THEN 'late'\n#&gt; END AS description\n#&gt; FROM flights\n\n特殊函数转换\n\n对于没有直接SQL对应的R函数（如cut()），同样使用CASE WHEN实现：\nflights |&gt; \n  mutate_query(\n    description =  cut(\n      arr_delay, \n      breaks = c(-Inf, -5, 5, Inf), \n      labels = c(\"early\", \"on-time\", \"late\")\n    )\n  )\n#&gt; &lt;SQL&gt;\n#&gt; SELECT CASE\n#&gt; WHEN (arr_delay &lt;= -5.0) THEN 'early'\n#&gt; WHEN (arr_delay &lt;= 5.0) THEN 'on-time'\n#&gt; WHEN (arr_delay &gt; 5.0) THEN 'late'\n#&gt; END AS description\n#&gt; FROM flights\ndbplyr还支持转换：\n\n字符串处理函数\n日期时间函数\n\n虽然dbplyr的转换机制尚不完美，部分R函数仍未支持，但对最常用的函数已实现高质量的转换覆盖。",
    "crumbs": [
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>数据库</span>"
    ]
  },
  {
    "objectID": "chapters/ch22_arrow.html",
    "href": "chapters/ch22_arrow.html",
    "title": "23  arrow 包",
    "section": "",
    "text": "23.1 引言\nCSV文件的设计初衷是便于人类阅读，它结构简单且几乎能被所有工具解析。然而CSV的效率较低——将数据读入R需要大量处理工作。本章介绍一种更高效的替代方案：Parquet格式，这是一种基于开放标准、被大数据系统广泛使用的列式存储格式。\nArrow是一个跨语言工具包，专为高效分析和传输大规模数据集而设计，同时也可以用于处理Parquet文件。\n本章须加载以下包：",
    "crumbs": [
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>arrow 包</span>"
    ]
  },
  {
    "objectID": "chapters/ch22_arrow.html#引言",
    "href": "chapters/ch22_arrow.html#引言",
    "title": "23  arrow 包",
    "section": "",
    "text": "library(tidyverse)\nlibrary(arrow)\nlibrary(dbplyr, warn.conflicts = FALSE)\nlibrary(duckdb)",
    "crumbs": [
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>arrow 包</span>"
    ]
  },
  {
    "objectID": "chapters/ch22_arrow.html#获取数据",
    "href": "chapters/ch22_arrow.html#获取数据",
    "title": "23  arrow 包",
    "section": "23.2 获取数据",
    "text": "23.2 获取数据\n本章教学数据集为：西雅图公共图书馆借阅记录。该数据集包含41,389,465行记录，记录了2005年4月至2022年10月期间每月每本图书的借阅情况。\n以下代码将下载该数据的缓存副本（9GB CSV文件）。由于文件较大，建议使用curl::multi_download()，它能显示进度条并支持断点续传：\n# 创建数据目录\ndir.create(\"data\", showWarnings = FALSE)\n\n# 使用多线程下载（支持断点续传）\ncurl::multi_download(\n  \"https://r4ds.s3.us-west-2.amazonaws.com/seattle-library-checkouts.csv\",\n  \"data/seattle-library-checkouts.csv\", \n  resume = TRUE\n)\n输出示例：\n# A tibble: 1 × 10\n  success status_code resumefrom url                    destfile        error\n  &lt;lgl&gt;         &lt;int&gt;      &lt;dbl&gt; &lt;chr&gt;                  &lt;chr&gt;           &lt;chr&gt;\n1 TRUE            200          0 https://r4ds.s3.us-we… data/seattle-l… &lt;NA&gt;\n# ℹ 4 more variables: type &lt;chr&gt;, modified &lt;dttm&gt;, time &lt;dbl&gt;, headers &lt;list&gt;",
    "crumbs": [
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>arrow 包</span>"
    ]
  },
  {
    "objectID": "chapters/ch22_arrow.html#打开数据集",
    "href": "chapters/ch22_arrow.html#打开数据集",
    "title": "23  arrow 包",
    "section": "23.3 打开数据集",
    "text": "23.3 打开数据集\n此文件大小为 9GB，不算小了，故不建议一次性将其完全加载到内存中。即应该避免使用 read_csv()，而用 arrow::open_dataset()：\nseattle_csv &lt;- open_dataset(\n  sources = \"data/seattle-library-checkouts.csv\", \n  col_types = schema(ISBN = string()),\n  format = \"csv\"\n)\nopen_dataset() 会扫描几千行数据来推断数据集的结构。但由于前 80,000 行中的 ISBN 列都是空白的，所以此处手动指定该列的类型，以帮助 arrow 理解数据结构。\n一旦 open_dataset() 扫描完数据，它就会记录下结构信息并停止读取数据内容，后续只有在明确请求时才会继续读取。\n打印 seattle_csv 时，输出的是它的元数据（metadata）：\nseattle_csv\n#&gt; FileSystemDataset with 1 csv file\n#&gt; UsageClass: string\n#&gt; CheckoutType: string\n#&gt; MaterialType: string\n#&gt; CheckoutYear: int64\n#&gt; CheckoutMonth: int64\n#&gt; Checkouts: int64\n#&gt; Title: string\n#&gt; ISBN: string\n#&gt; Creator: string\n#&gt; Subjects: string\n#&gt; Publisher: string\n#&gt; PublicationYear: string\n第一行告诉我们：seattle_csv 是一个由本地的 CSV 文件组成的数据集，只有在需要时才会加载到内存中。其余各行显示的是 arrow 推断出的各列数据类型。\n想要查看数据的实际内容，使用 glimpse() 函数，会显示行数、列数和部分值：\nseattle_csv |&gt; glimpse()\n#&gt; FileSystemDataset with 1 csv file\n#&gt; 41,389,465 rows x 12 columns\n#&gt; $ UsageClass      &lt;string&gt; \"Physical\", \"Physical\", \"Digital\", \"Physical\", \"Ph…\n#&gt; $ CheckoutType    &lt;string&gt; \"Horizon\", \"Horizon\", \"OverDrive\", \"Horizon\", \"Hor…\n#&gt; $ MaterialType    &lt;string&gt; \"BOOK\", \"BOOK\", \"EBOOK\", \"BOOK\", \"SOUNDDISC\", \"BOO…\n#&gt; $ CheckoutYear     &lt;int64&gt; 2016, 2016, 2016, 2016, 2016, 2016, 2016, 2016, 20…\n#&gt; $ CheckoutMonth    &lt;int64&gt; 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,…\n#&gt; $ Checkouts        &lt;int64&gt; 1, 1, 1, 1, 1, 1, 1, 1, 4, 1, 1, 2, 3, 2, 1, 3, 2,…\n#&gt; $ Title           &lt;string&gt; \"Super rich : a guide to having it all / Russell S…\n#&gt; $ ISBN            &lt;string&gt; \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"…\n#&gt; $ Creator         &lt;string&gt; \"Simmons, Russell\", \"Barclay, James, 1965-\", \"Tim …\n#&gt; $ Subjects        &lt;string&gt; \"Self realization, Conduct of life, Attitude Psych…\n#&gt; $ Publisher       &lt;string&gt; \"Gotham Books,\", \"Pyr,\", \"Random House, Inc.\", \"Di…\n#&gt; $ PublicationYear &lt;string&gt; \"c2011.\", \"2010.\", \"2015\", \"2005.\", \"c2004.\", \"c20…\n可以使用 dplyr 的语法对数据进行操作，然后用 collect() 函数触发计算并返回结果。例如，下面这段代码统计了每年的总借阅次数：\nseattle_csv |&gt; \n  group_by(CheckoutYear) |&gt; \n  summarise(Checkouts = sum(Checkouts)) |&gt; \n  arrange(CheckoutYear) |&gt; \n  collect()\n#&gt; # A tibble: 18 × 2\n#&gt;   CheckoutYear Checkouts\n#&gt;          &lt;int&gt;     &lt;int&gt;\n#&gt; 1         2005   3798685\n#&gt; 2         2006   6599318\n#&gt; 3         2007   7126627\n#&gt; 4         2008   8438486\n#&gt; 5         2009   9135167\n#&gt; 6         2010   8608966\n#&gt; # ℹ 12 more rows\n多亏了 arrow，无论数据多大上述代码都能运行。但目前它执行起来仍然较慢（本书作者 Hadley 的电脑上大概花了 10 秒）。考虑到数据量已经很大，这个速度并不算差——不过我们仍然可以通过切换到更高效的数据格式来进一步加速。",
    "crumbs": [
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>arrow 包</span>"
    ]
  },
  {
    "objectID": "chapters/ch22_arrow.html#parquet-格式",
    "href": "chapters/ch22_arrow.html#parquet-格式",
    "title": "23  arrow 包",
    "section": "23.4 Parquet 格式",
    "text": "23.4 Parquet 格式\n为了让上述数据更易于处理，我们需要将其转换为 Parquet 文件格式并进行分块存储。\n\n首先详细介绍一下 Parquet。与 CSV 类似，Parquet 也适用于矩形数据，但它不可以用文本编辑器查看，是专为大数据需求设计的二进制格式。这意味着：\n\n文件更小：Parquet 采用高效编码和压缩技术，减少了磁盘到内存的数据传输量，从而提升速度。\n类型系统完善：CSV 需要猜测列类型（如”08-10-2022”应解析为字符串还是日期），而Parquet直接存储数据类型信息。\n列式存储：数据按列组织（类似 R 数据框），相比按行存储的 CSV 能显著提升分析性能。\n分块存储：支持并行处理不同数据块，某些情况下可以跳过无关数据块。\n\n唯一缺点是不可人工阅读，用 readr::read_file() 查看 Parquet 文件只会显示乱码。\n\n接下来看看分区的概念。随着数据集增大，单文件存储会变得难以维护。对数据进行分区可以让我们分析时只访问部分文件，从而大幅提升性能。\n\n基础理论阐述完毕，下面让我们来重构图书馆数据。我们将按借阅年份（CheckoutYear）分区，这样既能支持按年份筛选，又能生成大小适中的 18 个数据块。\n通过 group_by() 函数定义分区，再用 write_dataset() 保存为 Parquet 格式：\npq_path &lt;- \"data/seattle-library-checkouts\"\nseattle_csv |&gt; \n  group_by(CheckoutYear) |&gt; \n  write_dataset(path = pq_path, format = \"parquet\")\n转换耗时约 1 分钟，但后续操作将因此获得极大加速。\n查看生成的文件结构：\ntibble(\n  files = list.files(pq_path, recursive = TRUE),\n  size_MB = file.size(file.path(pq_path, files)) / 1024^2\n)\n#&gt; # A tibble: 18 × 2\n#&gt;   files                            size_MB\n#&gt;   &lt;chr&gt;                              &lt;dbl&gt;\n#&gt; 1 CheckoutYear=2005/part-0.parquet    109.\n#&gt; 2 CheckoutYear=2006/part-0.parquet    164.\n#&gt; 3 CheckoutYear=2007/part-0.parquet    178.\n#&gt; 4 CheckoutYear=2008/part-0.parquet    195.\n#&gt; 5 CheckoutYear=2009/part-0.parquet    214.\n#&gt; 6 CheckoutYear=2010/part-0.parquet    222.\n#&gt; # ℹ 12 more rows\n原始 9GB CSV 文件被转换为 18 个 Parquet 文件，且命名格式统一。每个文件 100-300MB，总大小约 4GB（仅为原 CSV 的一半多），体现了 Parquet 的高效存储特性。",
    "crumbs": [
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>arrow 包</span>"
    ]
  },
  {
    "objectID": "chapters/ch22_arrow.html#使用-dplyr-操作-arrow-数据",
    "href": "chapters/ch22_arrow.html#使用-dplyr-操作-arrow-数据",
    "title": "23  arrow 包",
    "section": "23.5 使用 dplyr 操作 Arrow 数据",
    "text": "23.5 使用 dplyr 操作 Arrow 数据\n我们已经创建了 Parquet 文件，现在需要重新读取它们。再次使用 open_dataset()，传入目录路径：\nseattle_pq &lt;- open_dataset(pq_path)\n接下来我们就可以构建 dplyr 分析流程。例如，统计近五年每月图书借阅量：\nquery &lt;- seattle_pq |&gt; \n  filter(CheckoutYear &gt;= 2018, MaterialType == \"BOOK\") |&gt;\n  group_by(CheckoutYear, CheckoutMonth) |&gt;\n  summarize(TotalCheckouts = sum(Checkouts)) |&gt;\n  arrange(CheckoutYear, CheckoutMonth)\n这与上一章 dbplyr 的工作方式类似：编写的 dplyr 代码会被自动转换为 Apache Arrow C++ 库能理解的查询，调用 collect() 时才会执行。打印查询对象可预览执行计划：\nquery\n#&gt; FileSystemDataset (query)\n#&gt; CheckoutYear: int32\n#&gt; CheckoutMonth: int64\n#&gt; TotalCheckouts: int64\n#&gt; \n#&gt; * Grouped by CheckoutYear\n#&gt; * Sorted by CheckoutYear [asc], CheckoutMonth [asc]\n#&gt; See $.data for the source Arrow object\n随后调用 collect() 即可获取结果：\nquery |&gt; collect()\n#&gt; # A tibble: 58 × 3\n#&gt; # Groups:   CheckoutYear [5]\n#&gt;   CheckoutYear CheckoutMonth TotalCheckouts\n#&gt;          &lt;int&gt;         &lt;int&gt;          &lt;int&gt;\n#&gt; 1         2018             1         355101\n#&gt; 2         2018             2         309813\n#&gt; 3         2018             3         344487\n#&gt; 4         2018             4         330988\n#&gt; 5         2018             5         318049\n#&gt; 6         2018             6         341825\n#&gt; # ℹ 52 more rows\n\n另外，通过 arrow::to_duckdb() 函数可转为 DuckDB 数据库：\nseattle_pq |&gt; \n  to_duckdb() |&gt;\n  filter(CheckoutYear &gt;= 2018, MaterialType == \"BOOK\") |&gt;\n  group_by(CheckoutYear) |&gt;\n  summarize(TotalCheckouts = sum(Checkouts)) |&gt;\n  arrange(desc(CheckoutYear)) |&gt;\n  collect()\n此过程无需复制内存，实现了计算环境间的无缝切换。",
    "crumbs": [
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>arrow 包</span>"
    ]
  },
  {
    "objectID": "chapters/ch23_hierarchical_data.html",
    "href": "chapters/ch23_hierarchical_data.html",
    "title": "24  层次化数据",
    "section": "",
    "text": "24.1 引言\n本章将学习数据矩形化（data rectangling）技术：将具有层次结构或树状结构的数据转换为由行和列组成的矩形数据框。这项技术在当下数据科学的大环境显得尤为重要，因为层次化数据在实际应用中极为常见，特别是用于处理网络数据。\n本章将使用以下工具：\n加载所需包：",
    "crumbs": [
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>层次化数据</span>"
    ]
  },
  {
    "objectID": "chapters/ch23_hierarchical_data.html#引言",
    "href": "chapters/ch23_hierarchical_data.html#引言",
    "title": "24  层次化数据",
    "section": "",
    "text": "tidyr（tidyverse核心成员）\nrepurrrsive（提供矩形化练习数据集）\njsonlite（将JSON文件读取为R列表）\n\n\nlibrary(tidyverse)\nlibrary(repurrrsive)\nlibrary(jsonlite)",
    "crumbs": [
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>层次化数据</span>"
    ]
  },
  {
    "objectID": "chapters/ch23_hierarchical_data.html#列表",
    "href": "chapters/ch23_hierarchical_data.html#列表",
    "title": "24  层次化数据",
    "section": "24.2 列表",
    "text": "24.2 列表\n到目前为止，我们已经使用过包含简单向量的数据框，例如整数、数值、字符、日期时间和因子。这些向量之所以简单，是因为它们是同质的，即每个元素的数据类型相同。如果想在同一个向量中存储不同类型的元素，就需要使用列表（list），可以通过list()创建：\nx1 &lt;- list(1:4, \"a\", TRUE)\nx1\n#&gt; [[1]]\n#&gt; [1] 1 2 3 4\n#&gt; \n#&gt; [[2]]\n#&gt; [1] \"a\"\n#&gt; \n#&gt; [[3]]\n#&gt; [1] TRUE\n列表的组件命名很方便，方法与命名 tibble 的列类似：\nx2 &lt;- list(a = 1:2, b = 1:3, c = 1:4)\nx2\n#&gt; $a\n#&gt; [1] 1 2\n#&gt; \n#&gt; $b\n#&gt; [1] 1 2 3\n#&gt; \n#&gt; $c\n#&gt; [1] 1 2 3 4\n即使是这些非常简单的列表，直接打印也会占用大量空间。str()是一种高效的显示方式，它会生成一个紧凑的结构，弱化具体内容，省时省空间：\nstr(x1)\n#&gt; List of 3\n#&gt;  $ : int [1:4] 1 2 3 4\n#&gt;  $ : chr \"a\"\n#&gt;  $ : logi TRUE\nstr(x2)\n#&gt; List of 3\n#&gt;  $ a: int [1:2] 1 2\n#&gt;  $ b: int [1:3] 1 2 3\n#&gt;  $ c: int [1:4] 1 2 3 4\n可以看到，str()将列表的每个子元素单独显示在一行中。如果存在名称，它会先显示名称，然后是类型的缩写，接着是前几个值。\n列表可以包含任何类型的对象，包括其他列表。这一特性使其利于表示层级（树状）结构：\nx4 &lt;- list(1, list(2, list(3, list(4, list(5)))))\nstr(x4)\n#&gt; List of 2\n#&gt;  $ : num 1\n#&gt;  $ :List of 2\n#&gt;   ..$ : num 2\n#&gt;   ..$ :List of 2\n#&gt;   .. ..$ : num 3\n#&gt;   .. ..$ :List of 2\n#&gt;   .. .. ..$ : num 4\n#&gt;   .. .. ..$ :List of 1\n#&gt;   .. .. .. ..$ : num 5\n\n注意到随着列表变得复杂，str()的优势更加明显，层级结构一目了然。\n\n这与创建向量的函数c()有显著差异，c()只会生成一个扁平向量：\nc(c(1, 2), c(3, 4))\n#&gt; [1] 1 2 3 4\n\nx4 &lt;- c(list(1, 2), list(3, 4))\nstr(x5)\n#&gt; List of 4\n#&gt;  $ : num 1\n#&gt;  $ : num 2\n#&gt;  $ : num 3\n#&gt;  $ : num 4\n当列表变得更大更复杂时，str()最终会失效，此时需要用到View()，会显示出可交互的查看页面。下图是调用View(x4)的结果。\n\n\n列表也可以存在于 tibble 中，称为列表列（list-columns）。\n以下是一个简单的列表列示例：\ndf &lt;- tibble(\n  x = 1:2, \n  y = c(\"a\", \"b\"),\n  z = list(list(1, 2), list(3, 4, 5))\n)\ndf\n#&gt; # A tibble: 2 × 3\n#&gt;       x y     z         \n#&gt;   &lt;int&gt; &lt;chr&gt; &lt;list&gt;    \n#&gt; 1     1 a     &lt;list [2]&gt;\n#&gt; 2     2 b     &lt;list [3]&gt;\ntibble 中的列表没有什么特别之处，其操作与任何其他类型一样：\ndf |&gt; \n  filter(x == 1)\n#&gt; # A tibble: 1 × 3\n#&gt;       x y     z         \n#&gt;   &lt;int&gt; &lt;chr&gt; &lt;list&gt;    \n#&gt; 1     1 a     &lt;list [2]&gt;\n如果想查看，需要单独提取该列表列并应用上述方法之一，例如下面两种方式：\ndf |&gt; pull(z) |&gt; str()\ndf |&gt; pull(z) |&gt; View()\n在 base R 中，也可以将列表放入数据框的列中，但操作更繁琐，因为如果直接使用data.frame()，则会按列直接分别列出整个列表，而非将每个列表作为一个整体元素：\ndata.frame(x = list(1:3, 3:5))\n#&gt;   x.1.3 x.3.5\n#&gt; 1     1     3\n#&gt; 2     2     4\n#&gt; 3     3     5\n可以通过将列表包装在I()中，强制data.frame()将其视为行的列表，但打印效果不佳：\ndata.frame(\n  x = I(list(1:2, 3:5)), \n  y = c(\"1, 2\", \"3, 4, 5\")\n)\n#&gt;         x       y\n#&gt; 1    1, 2    1, 2\n#&gt; 2 3, 4, 5 3, 4, 5",
    "crumbs": [
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>层次化数据</span>"
    ]
  },
  {
    "objectID": "chapters/ch23_hierarchical_data.html#解除嵌套",
    "href": "chapters/ch23_hierarchical_data.html#解除嵌套",
    "title": "24  层次化数据",
    "section": "24.3 解除嵌套",
    "text": "24.3 解除嵌套\n如何将列表和列表列转换回常规的行和列？\n列表列通常有两种基本形式：命名的和未命名的。\n\n被命名的子元素通常在各行中具有相同的名称。例如在df1中，列表列y的每个元素都有两个名为a和b的子元素。\n\ndf1 &lt;- tribble(\n  ~x, ~y,\n  1, list(a = 11, b = 12),\n  2, list(a = 21, b = 22),\n  3, list(a = 31, b = 32),\n)\n命名的列表列解除嵌套后，每个命名元素都会成为一个新的命名列。\n针对此情况，使用unnest_wider()函数将各元素按名称拆开分列，如下所示：\ndf1 |&gt; \n  unnest_wider(y)\n#&gt; # A tibble: 3 × 3\n#&gt;       x     a     b\n#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1     1    11    12\n#&gt; 2     2    21    22\n#&gt; 3     3    31    32\n默认情况下，列表元素的名称即为新列的名称。可以使用names_sep参数将列名和元素名进行组合，得到更具特征性的列名。\ndf1 |&gt; \n  unnest_wider(y, names_sep = \"_\")\n#&gt; # A tibble: 3 × 3\n#&gt;       x   y_a   y_b\n#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1     1    11    12\n#&gt; 2     2    21    22\n#&gt; 3     3    31    32\n\n若子元素未被命名，元素数量通常在不同行间会有所变化。例如在df2中，列表列y的元素未被命名且长度从一到三不等。\n\ndf2 &lt;- tribble(\n  ~x, ~y,\n  1, list(11, 12, 13),\n  2, list(21),\n  3, list(31, 32),\n)\n未命名的列表列解除嵌套后，每个子元素都会单独生成一行。\n针对此情况，使用unnest_longer()进行拆分：\ndf2 |&gt; \n  unnest_longer(y)\n#&gt; # A tibble: 6 × 2\n#&gt;       x     y\n#&gt;   &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1     1    11\n#&gt; 2     1    12\n#&gt; 3     1    13\n#&gt; 4     2    21\n#&gt; 5     3    31\n#&gt; 6     3    32\n如果列表列的其中一个列没有元素，则该行不显式输出。\ndf6 &lt;- tribble(\n  ~x, ~y,\n  \"a\", list(1, 2),\n  \"b\", list(3),\n  \"c\", list()\n)\ndf6 |&gt; unnest_longer(y)\n#&gt; # A tibble: 3 × 2\n#&gt;   x         y\n#&gt;   &lt;chr&gt; &lt;dbl&gt;\n#&gt; 1 a         1\n#&gt; 2 a         2\n#&gt; 3 b         3\n\n如果想保留该行，也就是在y中保留NA，则需设置参数keep_empty = TRUE。\n\n我们知道，数据框各列所含元素必然类型相同。以上讨论的列表列中的列表，所含元素类型均相同，所以很容易实现元素类型相同的准则。那么如果原列表列类型不统一，拆分后又会如何显示呢？\n以下面的数据框df4为例，列表列y共包含两个数字、一个字符和一个逻辑值：\ndf4 &lt;- tribble(\n  ~x, ~y,\n  \"a\", list(1),\n  \"b\", list(\"a\", TRUE, 5)\n)\n前面谈过的unnest_longer()函数可以保持列数不变，而行数会变化。针对df4使用该函数效果如下：\ndf4 |&gt; \n  unnest_longer(y)\n#&gt; # A tibble: 4 × 2\n#&gt;   x     y        \n#&gt;   &lt;chr&gt; &lt;list&gt;   \n#&gt; 1 a     &lt;dbl [1]&gt;\n#&gt; 2 b     &lt;chr [1]&gt;\n#&gt; 3 b     &lt;lgl [1]&gt;\n#&gt; 4 b     &lt;dbl [1]&gt;\n可见输出包含一个列表列，且每个列表包含单个元素。由于unnest_longer()找不到向量的共同类型，故而仅将元素的原始类型保留在列中。",
    "crumbs": [
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>层次化数据</span>"
    ]
  },
  {
    "objectID": "chapters/ch24_web_scraping.html",
    "href": "chapters/ch24_web_scraping.html",
    "title": "25  网页抓取",
    "section": "",
    "text": "25.1 引言\n网页抓取是从互联网页面中提取结构化数据的方法。部分网站会提供API接口（一组返回JSON格式数据的标准化HTTP请求），将其抓取后，便可以运用上一章介绍的技巧处理数据。\n本章主要使用rvest工具包。rvest属于tidyverse生态，但需要单独加载。",
    "crumbs": [
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>网页抓取</span>"
    ]
  },
  {
    "objectID": "chapters/ch24_web_scraping.html#引言",
    "href": "chapters/ch24_web_scraping.html#引言",
    "title": "25  网页抓取",
    "section": "",
    "text": "library(tidyverse)\nlibrary(rvest)",
    "crumbs": [
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>网页抓取</span>"
    ]
  },
  {
    "objectID": "chapters/ch24_web_scraping.html#网络抓取的伦理与法律问题",
    "href": "chapters/ch24_web_scraping.html#网络抓取的伦理与法律问题",
    "title": "25  网页抓取",
    "section": "25.2 网络抓取的伦理与法律问题",
    "text": "25.2 网络抓取的伦理与法律问题\n要探讨具体的抓取技术，就必须先明确网络抓取行为的合法性与伦理边界。\n首先，法律约束因地区而异。但有个基本原则：如果数据属于公开、非个人且事实性的内容，则通常风险较低。\n若涉及非公开数据、个人隐私信息，或以商业盈利为目的的抓取行为，建议咨询专业律师。无论何种情况，都应当合理控制抓取频率，避免对目标服务器造成过大负担。\n即使面对公开数据，涉及以下信息时仍需特别谨慎：\n\n姓名/邮箱/电话等直接标识符\n出生日期等间接标识符\n地理位置等敏感信息\n\n原则上不禁止抓取受版权保护内容，但需满足：\n\n用于研究/非商业目的\n仅抓取所需内容\n控制抓取规模",
    "crumbs": [
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>网页抓取</span>"
    ]
  },
  {
    "objectID": "chapters/ch24_web_scraping.html#html基础",
    "href": "chapters/ch24_web_scraping.html#html基础",
    "title": "25  网页抓取",
    "section": "25.3 HTML基础",
    "text": "25.3 HTML基础\n首先了解HTML（超文本标记语言）的基本结构。典型的HTML文档示例如下：\n&lt;html&gt;\n&lt;head&gt;\n  &lt;title&gt;Page title&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;h1 id='first'&gt;A heading&lt;/h1&gt;\n  &lt;p&gt;Some text &amp; &lt;b&gt;some bold text.&lt;/b&gt;&lt;/p&gt;\n  &lt;img src='myimg.png' width='100' height='100'&gt;\n&lt;/body&gt;\nHTML采用层级化的元素结构，每个元素包含：\n\n开始标签（如&lt;tag&gt;）\n可选属性（如id='first'）\n结束标签（如&lt;/tag&gt;）\n内容（开始与结束标签之间的部分）\n\n特殊字符需转义表示：\n\n&lt; 写成 &lt\n&gt; 写成 &gt\n& 写成 &amp\n\n\n核心元素类型如下：\n\n文档结构元素\n\n&lt;html&gt;：根元素\n&lt;head&gt;：元数据（如页面标题）\n&lt;body&gt;：可见内容\n\n区块元素（定义页面结构）\n\n&lt;h1&gt;：一级标题\n&lt;p&gt;：段落\n&lt;section&gt;：内容区块\n&lt;ol&gt;：有序列表\n\n行内元素（文本格式化）\n\n&lt;b&gt;：加粗\n&lt;i&gt;：斜体\n&lt;a&gt;：超链接\n\n\n比如下面这个例子：\n&lt;p&gt;\n  Hi! My &lt;b&gt;name&lt;/b&gt; is Jia.\n&lt;/p&gt;\n\n&lt;p&gt;元素包含一个子元素&lt;b&gt;\n&lt;b&gt;元素包含文本内容“name”\n\n\n标签可包含命名属性，格式为属性名=\"值\"：\n关键属性如下：\n\nid：唯一标识符\nclass：样式类名\nhref（&lt;a&gt;标签）：链接地址\nsrc（&lt;img&gt;标签）：图片资源路径\n\n这些属性常与CSS配合控制页面的显示样式，也是数据抓取时的重要定位依据。遇到不熟悉的标签时，可查阅MDN Web Docs等权威文档。",
    "crumbs": [
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>网页抓取</span>"
    ]
  },
  {
    "objectID": "chapters/ch24_web_scraping.html#数据提取",
    "href": "chapters/ch24_web_scraping.html#数据提取",
    "title": "25  网页抓取",
    "section": "25.4 数据提取",
    "text": "25.4 数据提取\n要开始抓取数据，首先需要获取目标页面的URL（通常可以从浏览器中复制）。接着，使用read_html()函数将页面的HTML内容读入R。该函数返回的是xml_document对象：\nhtml &lt;- read_html(\"http://rvest.tidyverse.org/\")\nhtml\n#&gt; {html_document}\n#&gt; &lt;html lang=\"en\"&gt;\n#&gt; [1] &lt;head&gt;\\n&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UT ...\n#&gt; [2] &lt;body&gt;\\n    &lt;a href=\"#container\" class=\"visually-hidden-focusable\"&gt;Ski ...\n函数minimal_html()支持内联编写HTML，向xml_document对象中添加新成分：\nhtml &lt;- minimal_html(\"\n  &lt;p&gt;This is a paragraph&lt;/p&gt;\n  &lt;ul&gt;\n    &lt;li&gt;This is a bulleted list&lt;/li&gt;\n  &lt;/ul&gt;\n\")\n\nhtml\n#&gt; {html_document}\n#&gt; &lt;html&gt;\n#&gt; [1] &lt;head&gt;\\n&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UT ...\n#&gt; [2] &lt;body&gt;\\n&lt;p&gt;This is a paragraph&lt;/p&gt;\\n  &lt;ul&gt;\\n&lt;li&gt;This is a bulleted lis ...\n\n[1]是&lt;head&gt;部分，是元数据。\n[2]是&lt;body&gt;部分，是自定义的部分。\n\\n表示换行符，显示原始HTML结构\n\n这样一来便将HTML加载到了R，下一步是提取目标数据。\n\nCSS（层叠样式表）是一种定义HTML文档视觉样式的工具，其选择器语法可用来定位页面元素。简单来说，就是用关键词在网页上找东西。\n掌握以下三种选择器即可应对多数场景：\n\np 定位所有的段落（&lt;p&gt;标签）。\n.title 定位所有 class=“title” 的元素（比如高亮标题）。\n#title 定位 id=“title” 的元素（即整个网页唯一的大标题）。\n\n为了说明选择器的操作，在此创建一个html对象为例。\nhtml &lt;- minimal_html(\"\n  &lt;h1&gt;This is a heading&lt;/h1&gt;\n  &lt;p id='first'&gt;This is a paragraph&lt;/p&gt;\n  &lt;p class='important'&gt;This is an important paragraph&lt;/p&gt;\n\")\n使用html_elements()查找匹配选择器的所有元素：\nhtml |&gt; html_elements(\"p\")\n#&gt; {xml_nodeset (2)}\n#&gt; [1] &lt;p id=\"first\"&gt;This is a paragraph&lt;/p&gt;\n#&gt; [2] &lt;p class=\"important\"&gt;This is an important paragraph&lt;/p&gt;\nhtml |&gt; html_elements(\".important\")\n#&gt; {xml_nodeset (1)}\n#&gt; [1] &lt;p class=\"important\"&gt;This is an important paragraph&lt;/p&gt;\nhtml |&gt; html_elements(\"#first\")\n#&gt; {xml_nodeset (1)}\n#&gt; [1] &lt;p id=\"first\"&gt;This is a paragraph&lt;/p&gt;\n与之相对，html_element()函数（注意相对上面那个少了字母s）只输出第一个匹配项：\nhtml |&gt; html_element(\"p\")\n#&gt; {html_node}\n#&gt; &lt;p id=\"first\"&gt;\n当选择器未能成功匹配段落中的元素时，html_elements()返回长度为0的向量，而html_element()返回缺失值：\nhtml |&gt; html_elements(\"b\")\n#&gt; {xml_nodeset (0)}\nhtml |&gt; html_element(\"b\")\n#&gt; {xml_missing}\n#&gt; &lt;NA&gt;\n通常需组合使用html_elements()和html_element()，先用前者大致定位观测单位，再用后者提取指定的元素。比如以下示例包含《星球大战》中四个角色信息：\nhtml &lt;- minimal_html(\"\n  &lt;ul&gt;\n    &lt;li&gt;&lt;b&gt;C-3PO&lt;/b&gt; is a &lt;i&gt;droid&lt;/i&gt; that weighs &lt;span class='weight'&gt;167 kg&lt;/span&gt;&lt;/li&gt;\n    &lt;li&gt;&lt;b&gt;R4-P17&lt;/b&gt; is a &lt;i&gt;droid&lt;/i&gt;&lt;/li&gt;\n    &lt;li&gt;&lt;b&gt;R2-D2&lt;/b&gt; is a &lt;i&gt;droid&lt;/i&gt; that weighs &lt;span class='weight'&gt;96 kg&lt;/span&gt;&lt;/li&gt;\n    &lt;li&gt;&lt;b&gt;Yoda&lt;/b&gt; weighs &lt;span class='weight'&gt;66 kg&lt;/span&gt;&lt;/li&gt;\n  &lt;/ul&gt;\n\")\n用html_elements()生成每个角色对应的向量：\ncharacters &lt;- html |&gt; html_elements(\"li\")\ncharacters\n#&gt; {xml_nodeset (4)}\n#&gt; [1] &lt;li&gt;\\n&lt;b&gt;C-3PO&lt;/b&gt; is a &lt;i&gt;droid&lt;/i&gt; that weighs &lt;span class=\"weight\"&gt; ...\n#&gt; [2] &lt;li&gt;\\n&lt;b&gt;R4-P17&lt;/b&gt; is a &lt;i&gt;droid&lt;/i&gt;\\n&lt;/li&gt;\n#&gt; [3] &lt;li&gt;\\n&lt;b&gt;R2-D2&lt;/b&gt; is a &lt;i&gt;droid&lt;/i&gt; that weighs &lt;span class=\"weight\"&gt; ...\n#&gt; [4] &lt;li&gt;\\n&lt;b&gt;Yoda&lt;/b&gt; weighs &lt;span class=\"weight\"&gt;66 kg&lt;/span&gt;\\n&lt;/li&gt;\n提取角色名称时便可使用html_element()：\ncharacters |&gt; html_element(\"b\")\n#&gt; {xml_nodeset (4)}\n#&gt; [1] &lt;b&gt;C-3PO&lt;/b&gt;\n#&gt; [2] &lt;b&gt;R4-P17&lt;/b&gt;\n#&gt; [3] &lt;b&gt;R2-D2&lt;/b&gt;\n#&gt; [4] &lt;b&gt;Yoda&lt;/b&gt;\nhtml_element()与html_elements()处理空值时的差异在提取体重时尤为关键。即使某些角色无体重信息，html_element()仍会为每个角色返回一个缺失值填充：\ncharacters |&gt; html_element(\".weight\")\n#&gt; {xml_nodeset (4)}\n#&gt; [1] &lt;span class=\"weight\"&gt;167 kg&lt;/span&gt;\n#&gt; [2] NA\n#&gt; [3] &lt;span class=\"weight\"&gt;96 kg&lt;/span&gt;\n#&gt; [4] &lt;span class=\"weight\"&gt;66 kg&lt;/span&gt;\n而html_elements()会返回实际的体重&lt;span&gt;标签，导致角色与体重对应关系丢失：\ncharacters |&gt; html_elements(\".weight\")\n#&gt; {xml_nodeset (3)}\n#&gt; [1] &lt;span class=\"weight\"&gt;167 kg&lt;/span&gt;\n#&gt; [2] &lt;span class=\"weight\"&gt;96 kg&lt;/span&gt;\n#&gt; [3] &lt;span class=\"weight\"&gt;66 kg&lt;/span&gt;\n\nhtml_text2()可提取元素的纯文本内容：\ncharacters |&gt; \n  html_element(\"b\") |&gt; \n  html_text2()\n#&gt; [1] \"C-3PO\"  \"R4-P17\" \"R2-D2\"  \"Yoda\"\n\ncharacters |&gt; \n  html_element(\".weight\") |&gt; \n  html_text2()\n#&gt; [1] \"167 kg\" NA       \"96 kg\"  \"66 kg\"\n\n注意转义字符会被自动处理掉。\n\nhtml_attr()用于提取属性值：\nhtml &lt;- minimal_html(\"\n  &lt;p&gt;&lt;a href='https://en.wikipedia.org/wiki/Cat'&gt;cats&lt;/a&gt;&lt;/p&gt;\n  &lt;p&gt;&lt;a href='https://en.wikipedia.org/wiki/Dog'&gt;dogs&lt;/a&gt;&lt;/p&gt;\n\")\n\nhtml |&gt; \n  html_elements(\"p\") |&gt; \n  html_element(\"a\") |&gt; \n  html_attr(\"href\")\n#&gt; [1] \"https://en.wikipedia.org/wiki/Cat\" \"https://en.wikipedia.org/wiki/Dog\"\n\nhtml_attr()返回的是字符串，若提取数值或日期则需后续处理。\n\n\n若数据已存储在HTML表格中，则可直接读取。表格通常具有行列结构，可直接复制到Excel等工具中。\nHTML表格由四个主要元素构成：&lt;table&gt;、&lt;tr&gt;（行）、&lt;th&gt;（表头）、&lt;td&gt;（单元格）。比如下面是一个两列三行的表格：\nhtml &lt;- minimal_html(\"\n  &lt;table class='mytable'&gt;\n    &lt;tr&gt;&lt;th&gt;x&lt;/th&gt;   &lt;th&gt;y&lt;/th&gt;&lt;/tr&gt;\n    &lt;tr&gt;&lt;td&gt;1.5&lt;/td&gt; &lt;td&gt;2.7&lt;/td&gt;&lt;/tr&gt;\n    &lt;tr&gt;&lt;td&gt;4.9&lt;/td&gt; &lt;td&gt;1.3&lt;/td&gt;&lt;/tr&gt;\n    &lt;tr&gt;&lt;td&gt;7.2&lt;/td&gt; &lt;td&gt;8.1&lt;/td&gt;&lt;/tr&gt;\n  &lt;/table&gt;\n\")\nhtml_table()函数可输出表格对应的R数据框形式。通过html_element()指定目标表格：\nhtml |&gt; \n  html_element(\".mytable\") |&gt; \n  html_table()\n#&gt; # A tibble: 3 × 2\n#&gt;       x     y\n#&gt;   &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1   1.5   2.7\n#&gt; 2   4.9   1.3\n#&gt; 3   7.2   8.1\n注意x和y的元素已自动转换为数值类型。若自动转换有误，可设置convert = FALSE关闭该功能并手动处理。",
    "crumbs": [
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>网页抓取</span>"
    ]
  },
  {
    "objectID": "chapters/ch24_web_scraping.html#寻找合适的选择器",
    "href": "chapters/ch24_web_scraping.html#寻找合适的选择器",
    "title": "25  网页抓取",
    "section": "25.5 寻找合适的选择器",
    "text": "25.5 寻找合适的选择器\nCSS 选择器用于精准定位 HTML 中的目标数据，但由于网页结构复杂，找到合适的选择器往往需要反复调试。\n选择器的两大核心要素：\n\n特异性：只选中目标元素，避免无关内容。\n敏感性：确保选中所有需要的数据。\n\n推荐以下两个工具进行辅助：\n\nSelectorGadget，通过点击示例自动生成 CSS 选择器（支持正反例标记）。\n浏览器开发者工具，可在网页使用右键 → 检查（Inspect）查看 HTML 结构，分析元素属性（重点关注 class 和 id）。",
    "crumbs": [
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>网页抓取</span>"
    ]
  },
  {
    "objectID": "chapters/ch24_web_scraping.html#应用案例",
    "href": "chapters/ch24_web_scraping.html#应用案例",
    "title": "25  网页抓取",
    "section": "25.6 应用案例",
    "text": "25.6 应用案例\n下面通过两个实际案例来总结网页抓取技术。不过网站结构可能随时变化，以下代码难以实际复现。\n\n25.6.1 星球大战数据\nrvest包内置了一个简单的示例vignette(\"starwars\")：\n其页面结构如下所示：\n&lt;section&gt;\n  &lt;h2 data-id=\"1\"&gt;The Phantom Menace&lt;/h2&gt;\n  &lt;p&gt;Released: 1999-05-19&lt;/p&gt;\n  &lt;p&gt;Director: &lt;span class=\"director\"&gt;George Lucas&lt;/span&gt;&lt;/p&gt;\n  \n  &lt;div class=\"crawl\"&gt;\n    &lt;p&gt;...&lt;/p&gt;\n    &lt;p&gt;...&lt;/p&gt;\n    &lt;p&gt;...&lt;/p&gt;\n  &lt;/div&gt;\n&lt;/section&gt;\n我们的目标是将这些数据转换为7行的数据框，变量包括title、year、director、intro。首先读取HTML并提取所有section元素：\nurl &lt;- \"https://rvest.tidyverse.org/articles/starwars.html\"\nhtml &lt;- read_html(url)\n\nsection &lt;- html |&gt; html_elements(\"section\")\nsection\n#&gt; {xml_nodeset (7)}\n#&gt; [1] &lt;section&gt;&lt;h2 data-id=\"1\"&gt;\\nThe Phantom Menace\\n&lt;/h2&gt;\\n&lt;p&gt;\\nReleased: 1 ...\n#&gt; [2] &lt;section&gt;&lt;h2 data-id=\"2\"&gt;\\nAttack of the Clones\\n&lt;/h2&gt;\\n&lt;p&gt;\\nReleased: ...\n#&gt; [3] &lt;section&gt;&lt;h2 data-id=\"3\"&gt;\\nRevenge of the Sith\\n&lt;/h2&gt;\\n&lt;p&gt;\\nReleased:  ...\n#&gt; [4] &lt;section&gt;&lt;h2 data-id=\"4\"&gt;\\nA New Hope\\n&lt;/h2&gt;\\n&lt;p&gt;\\nReleased: 1977-05-2 ...\n#&gt; [5] &lt;section&gt;&lt;h2 data-id=\"5\"&gt;\\nThe Empire Strikes Back\\n&lt;/h2&gt;\\n&lt;p&gt;\\nReleas ...\n#&gt; [6] &lt;section&gt;&lt;h2 data-id=\"6\"&gt;\\nReturn of the Jedi\\n&lt;/h2&gt;\\n&lt;p&gt;\\nReleased: 1 ...\n#&gt; [7] &lt;section&gt;&lt;h2 data-id=\"7\"&gt;\\nThe Force Awakens\\n&lt;/h2&gt;\\n&lt;p&gt;\\nReleased: 20 ...\n接下来即可提取单个元素，关键是要找到正确的选择器：\nsection |&gt; html_element(\"h2\") |&gt; html_text2()\n#&gt; [1] \"The Phantom Menace\"      \"Attack of the Clones\"   \n#&gt; [3] \"Revenge of the Sith\"     \"A New Hope\"             \n#&gt; [5] \"The Empire Strikes Back\" \"Return of the Jedi\"     \n#&gt; [7] \"The Force Awakens\"\n\nsection |&gt; html_element(\".director\") |&gt; html_text2()\n#&gt; [1] \"George Lucas\"     \"George Lucas\"     \"George Lucas\"    \n#&gt; [4] \"George Lucas\"     \"Irvin Kershner\"   \"Richard Marquand\"\n#&gt; [7] \"J. J. Abrams\"\n最后将所有结果整合成一个数据框：\ntibble(\n  title = section |&gt; \n    html_element(\"h2\") |&gt; \n    html_text2(),\n  released = section |&gt; \n    html_element(\"p\") |&gt; \n    html_text2() |&gt; \n    str_remove(\"Released: \") |&gt; \n    parse_date(),\n  director = section |&gt; \n    html_element(\".director\") |&gt; \n    html_text2(),\n  intro = section |&gt; \n    html_element(\".crawl\") |&gt; \n    html_text2()\n)\n#&gt; # A tibble: 7 × 4\n#&gt;   title                   released   director         intro                  \n#&gt;   &lt;chr&gt;                   &lt;date&gt;     &lt;chr&gt;            &lt;chr&gt;                  \n#&gt; 1 The Phantom Menace      1999-05-19 George Lucas     \"Turmoil has engulfed …\n#&gt; 2 Attack of the Clones    2002-05-16 George Lucas     \"There is unrest in th…\n#&gt; 3 Revenge of the Sith     2005-05-19 George Lucas     \"War! The Republic is …\n#&gt; 4 A New Hope              1977-05-25 George Lucas     \"It is a period of civ…\n#&gt; 5 The Empire Strikes Back 1980-05-17 Irvin Kershner   \"It is a dark time for…\n#&gt; 6 Return of the Jedi      1983-05-25 Richard Marquand \"Luke Skywalker has re…\n#&gt; # ℹ 1 more row\n\n\n使用str_remove()清理多余文本\n使用parse_date()转换日期格式",
    "crumbs": [
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>网页抓取</span>"
    ]
  },
  {
    "objectID": "chapters/ch24_web_scraping.html#imdb-电影榜单",
    "href": "chapters/ch24_web_scraping.html#imdb-电影榜单",
    "title": "25  网页抓取",
    "section": "25.7 IMDb 电影榜单",
    "text": "25.7 IMDb 电影榜单\n第二个案例抓取IMDb的电影top榜单，展示如何处理复杂数据。\n数据有明显的表格结构，因此可以先尝试html_table()：\nurl &lt;- \"https://web.archive.org/web/20220201012049/https://www.imdb.com/chart/top/\"\nhtml &lt;- read_html(url)\n\ntable &lt;- html |&gt; \n  html_element(\"table\") |&gt; \n  html_table()\n\ntable\n#&gt; # A tibble: 250 × 5\n#&gt;   ``    `Rank & Title`                    `IMDb Rating` `Your Rating`   ``   \n#&gt;   &lt;lgl&gt; &lt;chr&gt;                                     &lt;dbl&gt; &lt;chr&gt;           &lt;lgl&gt;\n#&gt; 1 NA    \"1.\\n      The Shawshank Redempt…           9.2 \"12345678910\\n… NA   \n#&gt; 2 NA    \"2.\\n      The Godfather\\n      …           9.1 \"12345678910\\n… NA   \n#&gt; 3 NA    \"3.\\n      The Godfather: Part I…           9   \"12345678910\\n… NA   \n#&gt; 4 NA    \"4.\\n      The Dark Knight\\n    …           9   \"12345678910\\n… NA   \n#&gt; 5 NA    \"5.\\n      12 Angry Men\\n       …           8.9 \"12345678910\\n… NA   \n#&gt; 6 NA    \"6.\\n      Schindler's List\\n   …           8.9 \"12345678910\\n… NA   \n#&gt; # ℹ 244 more rows\n虽然包含一些空列，但总体上成功捕获了表格信息。接下来初步处理数据：\nratings &lt;- table |&gt;\n  select(\n    rank_title_year = `Rank & Title`,\n    rating = `IMDb Rating`\n  ) |&gt; \n  mutate(\n    rank_title_year = str_replace_all(rank_title_year, \"\\n +\", \" \")\n  ) |&gt; \n  separate_wider_regex(\n    rank_title_year,\n    patterns = c(\n      rank = \"\\\\d+\", \"\\\\. \",\n      title = \".+\", \" +\\\\(\",\n      year = \"\\\\d+\", \"\\\\)\"\n    )\n  )\n\nratings\n#&gt; # A tibble: 250 × 4\n#&gt;   rank  title                    year  rating\n#&gt;   &lt;chr&gt; &lt;chr&gt;                    &lt;chr&gt;  &lt;dbl&gt;\n#&gt; 1 1     The Shawshank Redemption 1994     9.2\n#&gt; 2 2     The Godfather            1972     9.1\n#&gt; 3 3     The Godfather: Part II   1974     9  \n#&gt; 4 4     The Dark Knight          2008     9  \n#&gt; 5 5     12 Angry Men             1957     8.9\n#&gt; 6 6     Schindler's List         1993     8.9\n#&gt; # ℹ 244 more rows\n\nseparate_wider_regex()（第15章介绍过）将标题、年份和排名拆分到独立变量中。\n\n查看原始HTML还能发现更多数据：\nhtml |&gt; \n  html_elements(\"td strong\") |&gt; \n  head() |&gt; \n  html_attr(\"title\")\n#&gt; [1] \"9.2 based on 2,536,415 user ratings\"\n#&gt; [2] \"9.1 based on 1,745,675 user ratings\"\n#&gt; [3] \"9.0 based on 1,211,032 user ratings\"\n#&gt; [4] \"9.0 based on 2,486,931 user ratings\"\n#&gt; [5] \"8.9 based on 749,563 user ratings\"  \n#&gt; [6] \"8.9 based on 1,295,705 user ratings\"\n不妨将这些数据与表格数据结合：\nratings |&gt;\n  mutate(\n    rating_n = html |&gt; html_elements(\"td strong\") |&gt; html_attr(\"title\")\n  ) |&gt; \n  separate_wider_regex(\n    rating_n,\n    patterns = c(\n      \"[0-9.]+ based on \",\n      number = \"[0-9,]+\",\n      \" user ratings\"\n    )\n  ) |&gt; \n  mutate(\n    number = parse_number(number)\n  )\n#&gt; # A tibble: 250 × 5\n#&gt;   rank  title                    year  rating  number\n#&gt;   &lt;chr&gt; &lt;chr&gt;                    &lt;chr&gt;  &lt;dbl&gt;   &lt;dbl&gt;\n#&gt; 1 1     The Shawshank Redemption 1994     9.2 2536415\n#&gt; 2 2     The Godfather            1972     9.1 1745675\n#&gt; 3 3     The Godfather: Part II   1974     9   1211032\n#&gt; 4 4     The Dark Knight          2008     9   2486931\n#&gt; 5 5     12 Angry Men             1957     8.9  749563\n#&gt; 6 6     Schindler's List         1993     8.9 1295705\n#&gt; # ℹ 244 more rows",
    "crumbs": [
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>网页抓取</span>"
    ]
  },
  {
    "objectID": "chapters/ch24_web_scraping.html#动态网页",
    "href": "chapters/ch24_web_scraping.html#动态网页",
    "title": "25  网页抓取",
    "section": "25.8 动态网页",
    "text": "25.8 动态网页\n到目前为止，本章讨论了html_elements()能返回浏览器所见内容的网页，介绍了解析并处理信息的过程。\n然而，有时我们会发现html_elements()相关函数返回的内容与浏览器中看到的完全不同。这是因为尝试抓取的网站是通过JavaScript动态来生成页面内容的。目前这种形式无法通过rvest包进行解析，因为rvest包只下载原始HTML而不会执行任何JavaScript代码。\n本书作者目前正在加紧开发rvest以实现抓取动态网页，欲知详情可访问rvest官网。",
    "crumbs": [
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>网页抓取</span>"
    ]
  },
  {
    "objectID": "chapters/ch25_functions.html",
    "href": "chapters/ch25_functions.html",
    "title": "26  函数",
    "section": "",
    "text": "26.1 引言\n提升工作效率的最佳方式之一是编写函数。函数比复制粘贴更强大、更通用、更自动化。\n具体而言，编写函数有以下优势：\n本章介绍三种实用的函数类型：\n我们将整合tidyverse中的多种函数，并依旧使用老熟人nycflights13作为示例数据来测试这些函数。",
    "crumbs": [
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>函数</span>"
    ]
  },
  {
    "objectID": "chapters/ch25_functions.html#引言",
    "href": "chapters/ch25_functions.html#引言",
    "title": "26  函数",
    "section": "",
    "text": "可以为函数起一个专属名称，让代码更易读。\n只需在一处更新代码，而无需修改多处。\n可在不同项目中复用代码，从而长期提升生产力。\n\n\n当复制粘贴某段代码超过两次，或同一代码有三份副本，就应该考虑将其改写为函数。\n\n\n\n向量函数：输入一个或多个向量，返回一个向量。\n数据框函数：输入一个数据框，返回一个数据框。\n绘图函数：输入一个数据框，返回一个图形。\n\n\nlibrary(tidyverse)  \nlibrary(nycflights13)",
    "crumbs": [
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>函数</span>"
    ]
  },
  {
    "objectID": "chapters/ch25_functions.html#向量函数",
    "href": "chapters/ch25_functions.html#向量函数",
    "title": "26  函数",
    "section": "26.2 向量函数",
    "text": "26.2 向量函数\n首先介绍向量函数。向量函数接受一个或多个向量作为输入，并返回一个向量作为输出。\n\n26.2.1 编写\n编写函数的第一步是分析重复代码，找出哪些部分是固定的，哪些部分是变化的。\n比如下面这个数据框相关代码：\ndf &lt;- tibble(\n  a = rnorm(5),\n  b = rnorm(5),\n  c = rnorm(5),\n  d = rnorm(5),\n)\n\ndf |&gt; mutate(\n  a = (a - min(a, na.rm = TRUE)) / \n    (max(a, na.rm = TRUE) - min(a, na.rm = TRUE)),\n  b = (b - min(b, na.rm = TRUE)) / \n    (max(b, na.rm = TRUE) - min(b, na.rm = TRUE)),\n  c = (c - min(c, na.rm = TRUE)) / \n    (max(c, na.rm = TRUE) - min(c, na.rm = TRUE)),\n  d = (d - min(d, na.rm = TRUE)) / \n    (max(d, na.rm = TRUE) - min(d, na.rm = TRUE)),\n)\n#&gt; # A tibble: 5 × 4\n#&gt;       a       b     c     d\n#&gt;   &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1 0.339  0.387  0.291 0    \n#&gt; 2 0.880 -0.613  0.611 0.557\n#&gt; 3 0     -0.0833 1     0.752\n#&gt; 4 0.795 -0.0822 0     1    \n#&gt; 5 1     -0.0952 0.580 0.394\n显然 mutate()中的部分有多次重复，不妨将其单独提出，每一行代表一次重复：\n(a - min(a, na.rm = TRUE)) / (max(a, na.rm = TRUE) - min(a, na.rm = TRUE))\n(b - min(b, na.rm = TRUE)) / (max(b, na.rm = TRUE) - min(b, na.rm = TRUE))\n(c - min(c, na.rm = TRUE)) / (max(c, na.rm = TRUE) - min(c, na.rm = TRUE))\n(d - min(d, na.rm = TRUE)) / (max(d, na.rm = TRUE) - min(d, na.rm = TRUE))  \n可以用一个占位符 █表示变化部分：\n(█ - min(█, na.rm = TRUE)) / (max(█, na.rm = TRUE) - min(█, na.rm = TRUE))\n要将其转换为函数，需要三个关键组成部分：\n\n函数名（name）：此处使用 rescale01，表示将向量缩放至 [0, 1]。\n参数（arguments）：此处只需一个参数，命名为 x。\n函数体（body）：即重复代码的逻辑。\n\n遵循以下模板：\nname &lt;- function(arguments) {\n  body\n}\n对应本例：\nrescale01 &lt;- function(x) {\n  (x - min(x, na.rm = TRUE)) / (max(x, na.rm = TRUE) - min(x, na.rm = TRUE))\n}\n可以用简单输入进行测试：\nrescale01(c(-10, 0, 10))         # [1] 0.0 0.5 1.0\nrescale01(c(1, 2, 3, NA, 5))     # [1] 0.00 0.25 0.50   NA 1.00\n随后重写 mutate() 调用：\ndf |&gt; mutate(\n  a = rescale01(a),\n  b = rescale01(b),\n  c = rescale01(c),\n  d = rescale01(d),\n)\n\n\n26.2.2 优化\n注意到 rescale01() 中 min() 和 max() 被多次调用，可以用 range()进行简化：\nrescale01 &lt;- function(x) {\n  rng &lt;- range(x, na.rm = TRUE)\n  (x - rng[1]) / (rng[2] - rng[1])\n}\n\nrange()函数接收数值向量，输出最小值和最大值。\n\n再用包含无穷值的向量检验函数：\nx &lt;- c(1:10, Inf)\nrescale01(x)  # 返回值含 NaN，不理想\n可以用 finite = TRUE 参数忽略无穷值：\nrescale01 &lt;- function(x) {\n  rng &lt;- range(x, na.rm = TRUE, finite = TRUE)\n  (x - rng[1]) / (rng[2] - rng[1])\n}\n\n\n26.2.3 变换函数（mutate functions）\n现在我们已大致了解了函数的编写过程，下面通过介绍一些具有特定功能的函数进行深入说明。\n变换函数是一类输入与输出的向量长度一致的函数，故而其结果适用于 mutate() 和 filter() 。\n标准化 Z-score函数的结构如下，与刚刚编写的rescale01比较类似：\nz_score &lt;- function(x) {\n  (x - mean(x, na.rm = TRUE)) / sd(x, na.rm = TRUE)\n}\n再如下面的字符向量操作，能够将首字母转为大写：\nfirst_upper &lt;- function(x) {\n  str_sub(x, 1, 1) &lt;- str_to_upper(str_sub(x, 1, 1))\n  x\n}\n\nfirst_upper(\"hello\")  # \"Hello\"\n\n细节说明：\n\nstr_sub(x, 1, 1)：提取每个字符串的第1个字符，1, 1 表示从第1个字符开始，到第1个字符结束。\nstr_to_upper()：将字符转为大写。\n最后的 x 表示返回修改后的完整字符串向量。\n\n\n\n\n26.2.4 汇总函数（summary functions）\n接下来是汇总函数，一般用于 summarize()，能够返回一个单值。\n下面是用逗号连接字符串的一个汇总函数：\ncommas &lt;- function(x) {\n  str_flatten(x, collapse = \", \", last = \" and \")\n}\n\ncommas(c(\"cat\", \"dog\", \"pigeon\"))  # \"cat, dog and pigeon\"\n\n细节说明：\n\nstr_flatten()：将字符向量合并为单个字符串。\ncollapse = \", \"表示普通元素间用逗号+空格分隔；last = \" and \"表示最后两个元素之间用 and 连接。\n\n\n也可以输入多个向量，而输出仍是单值。例如下面用于计算 MAPE（平均绝对百分比误差）的函数：\nmape &lt;- function(actual, predicted) {\n  sum(abs((actual - predicted) / actual)) / length(actual)\n}\n\n写函数时，以下 RStudio 快捷键非常方便：\n\n查看函数定义：将输入光标置于函数名上，按 F2。\n跳转到函数：按 Ctrl + . 可打开模糊搜索，可跳转到函数、文件或 Quarto 小节等位置。",
    "crumbs": [
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>函数</span>"
    ]
  },
  {
    "objectID": "chapters/ch25_functions.html#数据框函数",
    "href": "chapters/ch25_functions.html#数据框函数",
    "title": "26  函数",
    "section": "26.3 数据框函数",
    "text": "26.3 数据框函数\n当我们需要重复使用dplyr动词时，就可以考虑编写一个数据框函数。它们以数据框作为第一个参数，后面跟着一些额外的参数用于说明如何处理，并输出一个数据框或向量。\n\n26.3.1 间接引用与整洁求值\n当开始编写使用 dplyr 动词的函数时，我们很快就会遇到间接引用的问题。下面用一个简单函数grouped_mean()来说明。该函数的目标是根据 group_var 分组并计算 mean_var 的平均值：\ngrouped_mean &lt;- function(df, group_var, mean_var) {\n  df |&gt;\n    group_by(group_var) |&gt; \n    summarize(mean(mean_var))\n}\n看起来没啥问题，但是运行时会得到一个错误：\ndiamonds |&gt; grouped_mean(cut, carat)\n#&gt; Error in `group_by()`:\n#&gt; ! Must group by variables found in `.data`.\n#&gt; ✖ Column `group_var` is not found.\n不难发现，此函数似乎是想寻找本应在函数定义中充当变量的group_var。dplyr 默认直接捕获函数参数中写死的变量名（如 group_var），而不是评估新传入的参数名（如 group 和 x）。这就是“间接引用”。它产生的原因是 dplyr 采取“整洁求值”（tidy evaluation）的规则，本意是方便我们在数据框中直接引用变量名而无需特别处理，但在封装成函数时却成了绊脚石。\n好消息是，dplyr提供了解决方案，称为 embracing 🤗。embracing 将变量包裹在双层大括号中，例如 var 写成 { var }，意为使用参数中的值，而不是把参数本身当作变量名。\n因此，要让 grouped_mean() 正确工作，我们需要用 { } 包裹 group_var 和 mean_var：\ngrouped_mean &lt;- function(df, group_var, mean_var) {\n  df |&gt; \n    group_by({{ group_var }}) |&gt; \n    summarize(mean({{ mean_var }}))\n}\n\ndf |&gt; grouped_mean(group, x)\n#&gt; # A tibble: 1 × 2\n#&gt;   group `mean(x)`\n#&gt;   &lt;dbl&gt;     &lt;dbl&gt;\n#&gt; 1     1        10\n成功！\n\n\n26.3.2 什么时候使用 embracing？\n经过上节解释不难看出，编写数据框函数的关键是确定哪些函数的参数需要 embracing，而这可以从文档中查到 。\n大体分为两类：\n\n数据掩码（Data-masking）： arrange()、filter()、 summarize() 等对变量计算的函数。\n整洁选择（Tidy-selection）： select()、relocate() 、rename() 等选择变量的函数。\n\n\n\n26.3.3 常见用例\n如果你在处理数据时经常执行相同的某种汇总操作，便可以考虑将它们封装成一个辅助函数：\nsummary6 &lt;- function(data, var) {\n  data |&gt; summarize(\n    min = min({{ var }}, na.rm = TRUE),\n    mean = mean({{ var }}, na.rm = TRUE),\n    median = median({{ var }}, na.rm = TRUE),\n    max = max({{ var }}, na.rm = TRUE),\n    n = n(),\n    n_miss = sum(is.na({{ var }})),\n    .groups = \"drop\"\n  )\n}\n\ndiamonds |&gt; summary6(carat)\n#&gt; # A tibble: 1 × 6\n#&gt;     min  mean median   max     n n_miss\n#&gt;   &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt;  &lt;int&gt;\n#&gt; 1   0.2 0.798    0.7  5.01 53940      0\n\n将 summarize() 封装成辅助函数时，建议设置 .groups = \"drop\"，以清除所有分组属性，将数据框还原为普通表格。\n\n再来一例，下面这个新定义函数是 count() 的增强版，能够同时计算比例：\ncount_prop &lt;- function(df, var, sort = FALSE) {\n  df |&gt;\n    count({{ var }}, sort = sort) |&gt;\n    mutate(prop = n / sum(n))\n}\n\ndiamonds |&gt; count_prop(clarity)\n#&gt; # A tibble: 8 × 3\n#&gt;   clarity     n   prop\n#&gt;   &lt;ord&gt;   &lt;int&gt;  &lt;dbl&gt;\n#&gt; 1 I1        741 0.0137\n#&gt; 2 SI2      9194 0.170 \n#&gt; 3 SI1     13065 0.242 \n#&gt; 4 VS2     12258 0.227 \n#&gt; 5 VS1      8171 0.151 \n#&gt; 6 VVS2     5066 0.0939\n#&gt; # ℹ 2 more rows\n这个函数有三个参数：df、var 和 sort，只有 var 需要 embracing，因为它传递给了 count()。注意， sort 设置了默认值，如果用户未提供值，则默认为 FALSE。\n以上例子都是把数据框作为第一个参数，但如果反复使用相同的数据，也可以硬编码它。例如下面这个函数可直接定向使用 flights 数据集，定向选择 time_hour、carrier 和 flight：\nsubset_flights &lt;- function(rows, cols) {\n  flights |&gt; \n    filter({{ rows }}) |&gt; \n    select(time_hour, carrier, flight, {{ cols }})\n}\n\n\n26.3.4 数据掩码 vs. 整洁选择\n有时我们会想在使用 data-masking 的函数中选择变量。例如想定义一个 count_missing() 来统计缺失观测值的数量，可能会像这样写：\ncount_missing &lt;- function(df, group_vars, x_var) {\n  df |&gt; \n    group_by({{ group_vars }}) |&gt; \n    summarize(\n      n_miss = sum(is.na({{ x_var }})),\n      .groups = \"drop\"\n    )\n}\n\nflights |&gt; \n  count_missing(c(year, month, day), dep_time)\n#&gt; Error in `group_by()`:\n#&gt; ℹ In argument: `c(year, month, day)`.\n#&gt; Caused by error:\n#&gt; ! `c(year, month, day)` must be size 336776 or 1, not 1010328.\n函数报错了，因为 group_by() 属于 data-masking，而不是 tidy-selection。此时可以在对应函数里套一个 pick() 函数，就能让我们在 data-masking 函数中使用 tidy-selection 方式：\ncount_missing &lt;- function(df, group_vars, x_var) {\n  df |&gt; \n    group_by(pick({{ group_vars }})) |&gt; \n    summarize(\n      n_miss = sum(is.na({{ x_var }})),\n      .groups = \"drop\"\n  )\n}\nflights |&gt; \n  count_missing(c(year, month, day), dep_time)\n#&gt; # A tibble: 365 × 4\n#&gt;    year month   day n_miss\n#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;  &lt;int&gt;\n#&gt; 1  2013     1     1      4\n#&gt; 2  2013     1     2      8\n#&gt; 3  2013     1     3     10\n#&gt; 4  2013     1     4      6\n#&gt; 5  2013     1     5      3\n#&gt; 6  2013     1     6      1\n#&gt; # ℹ 359 more rows\npick() 的另一个实用场景是构建二维计数表。比如下面我们将全部行列变量计数，然后用 pivot_wider() 将计数转换成网格：\ncount_wide &lt;- function(data, rows, cols) {\n  data |&gt; \n    count(pick(c({{ rows }}, {{ cols }}))) |&gt; \n    pivot_wider(\n      names_from = {{ cols }}, \n      values_from = n,\n      names_sort = TRUE,\n      values_fill = 0\n    )\n}\n\ndiamonds |&gt; count_wide(c(clarity, color), cut)\n#&gt; # A tibble: 56 × 7\n#&gt;   clarity color  Fair  Good `Very Good` Premium Ideal\n#&gt;   &lt;ord&gt;   &lt;ord&gt; &lt;int&gt; &lt;int&gt;       &lt;int&gt;   &lt;int&gt; &lt;int&gt;\n#&gt; 1 I1      D         4     8           5      12    13\n#&gt; 2 I1      E         9    23          22      30    18\n#&gt; 3 I1      F        35    19          13      34    42\n#&gt; 4 I1      G        53    19          16      46    16\n#&gt; 5 I1      H        52    14          12      46    38\n#&gt; 6 I1      I        34     9           8      24    17\n#&gt; # ℹ 50 more rows",
    "crumbs": [
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>函数</span>"
    ]
  },
  {
    "objectID": "chapters/ch25_functions.html#绘图函数",
    "href": "chapters/ch25_functions.html#绘图函数",
    "title": "26  函数",
    "section": "26.4 绘图函数",
    "text": "26.4 绘图函数\n讲完数据框函数，现在来看看如何定义绘图函数。 aes() 同样是一个数据掩码函数（data-masking function），所以技巧大差不差。\n打个比方，假设我们需要制作很多直方图：\ndiamonds |&gt; \n  ggplot(aes(x = carat)) +\n  geom_histogram(binwidth = 0.1)\n\ndiamonds |&gt; \n  ggplot(aes(x = carat)) +\n  geom_histogram(binwidth = 0.05)\n如果可以把这个过程封装成一个 histogram 函数，那岂不是方便多了？确实很容易实现：\nhistogram &lt;- function(df, var, binwidth = NULL) {\n  df |&gt; \n    ggplot(aes(x = {{ var }})) + \n    geom_histogram(binwidth = binwidth)\n}\n\ndiamonds |&gt; histogram(carat, 0.1)\n这样运行后便可得到一个关于钻石克拉的直方图。\n上面自定义的histogram() 返回的是一个 ggplot2 图表对象，这意味着我们仍然可以像平常一样添加其它组件，只要记得把 |&gt; 换成 +。比如添加标签：\ndiamonds |&gt; \n  histogram(carat, 0.1) +\n  labs(x = \"Size (in carats)\", y = \"Number of diamonds\")\n\n26.4.1 更多变量\n基于新函数的框架，我们可以轻松地添加更多变量。例如，若想快速查看一个数据集是否呈线性关系，可以创建新函数linearity_check()来叠加一条平滑曲线和一条直线：\nlinearity_check &lt;- function(df, x, y) {\n  df |&gt;\n    ggplot(aes(x = {{ x }}, y = {{ y }})) +\n    geom_point() +\n    geom_smooth(method = \"loess\", formula = y ~ x, color = \"red\", se = FALSE) +\n    geom_smooth(method = \"lm\", formula = y ~ x, color = \"blue\", se = FALSE) \n}\n\nstarwars |&gt; \n  filter(mass &lt; 1000) |&gt; \n  linearity_check(mass, height)\n\n如此便可画出星球大战人物的身高与体重散点图，显示出正相关关系。红色曲线为平滑趋势线，蓝色线为最佳拟合直线。\n对于过于庞大的数据集，为避免图像重叠，不妨通过新定义使用六边形图来展示散点图的密度：\nhex_plot &lt;- function(df, x, y, z, bins = 20, fun = \"mean\") {\n  df |&gt; \n    ggplot(aes(x = {{ x }}, y = {{ y }}, z = {{ z }})) + \n    stat_summary_hex(\n      aes(color = after_scale(fill)), \n      bins = bins, \n      fun = fun,\n    )\n}\n\ndiamonds |&gt; hex_plot(carat, price, depth)\n\n\n\n26.4.2 与 tidyverse 结合\n高效的绘图函数一般都将数据处理和 ggplot2 相结合。例如使用 fct_infreq()函数生成一个按频率排序的垂直柱状图，同时要让频率最高的在顶部，则可定义sorted_bars()：\nsorted_bars &lt;- function(df, var) {\n  df |&gt; \n    mutate({{ var }} := fct_rev(fct_infreq({{ var }})))  |&gt;\n    ggplot(aes(y = {{ var }})) +\n    geom_bar()\n}\n\ndiamonds |&gt; sorted_bars(clarity)\n\n注意新的运算符 :=（海象运算符 walrus operator）。\n由于我们需要根据用户输入的数据生成变量名，且变量名需要放在等号 = 的左边，但 R 的语法不允许=左边是表达式。所以此处必须使用 :=替代 = 。\n\n\n\n\n26.4.3 图表标签\n还记得我们之前写的直方图函数吗？\nhistogram &lt;- function(df, var, binwidth = NULL) {\n  df |&gt; \n    ggplot(aes(x = {{ var }})) + \n    geom_histogram(binwidth = binwidth)\n}\n如果图表能自动标注变量名和 bin 宽度，岂不是更好？为了解决标注问题，我们可以使用 rlang::englue()。它的作用类似于 str_glue()：\n\n将 {} 中的值插入字符串。\n识别 { }，并自动插入变量名：\n\nhistogram &lt;- function(df, var, binwidth) {\n  label &lt;- rlang::englue(\"A histogram of {{ var }} with binwidth {binwidth}\")\n  \n  df |&gt; \n    ggplot(aes(x = {{ var }})) + \n    geom_histogram(binwidth = binwidth) + \n    labs(title = label)\n}\n\ndiamonds |&gt; histogram(carat, 0.1)",
    "crumbs": [
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>函数</span>"
    ]
  },
  {
    "objectID": "chapters/ch25_functions.html#代码风格规范",
    "href": "chapters/ch25_functions.html#代码风格规范",
    "title": "26  函数",
    "section": "26.5 代码风格规范",
    "text": "26.5 代码风格规范\n虽然函数或参数命名的规范性不会影响R对其的执行，但恰当的命名对代码的可读性至关重要。理想的函数名应当简洁明了，能准确传达函数的功能。\n通常而言，函数名宜采用动词，参数名宜采用名词。当然也有例外，比如某些约定成俗的名词，如均值函数mean()就比compute_mean()更合适。开发者应当灵活判断，大胆命名。\n列出一些命名的反面示例，仅供参考：\n# 名称过短\nf()\n\n# 非动词且表意模糊\nmy_awesome_function()\n\n# 正面示范（名称虽长但语义清晰）\nimpute_missing()\ncollapse_years()\n同样地，代码中空格的使用规范不影响使用效果，但会影响代码的可读性。务必遵循第4章的格式规范，并特别注意：\n\nfunction()后必须紧跟花括号{}，且函数体需缩进两个空格。\n建议在{ }内部添加额外空格（如{ color }），能显著提醒读者此处存在特殊语法操作。",
    "crumbs": [
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>函数</span>"
    ]
  },
  {
    "objectID": "chapters/ch26_iteration.html",
    "href": "chapters/ch26_iteration.html",
    "title": "27  迭代",
    "section": "",
    "text": "27.1 引言\n提升工作效率的最佳方式之一是编写函数。函数比复制粘贴更强大、更通用、更自动化。\n具体而言，编写函数有以下优势：\n本章介绍三种实用的函数类型：\n我们将整合tidyverse中的多种函数，并依旧使用老熟人nycflights13作为示例数据来测试这些函数。",
    "crumbs": [
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>迭代</span>"
    ]
  },
  {
    "objectID": "chapters/ch26_iteration.html#引言",
    "href": "chapters/ch26_iteration.html#引言",
    "title": "27  迭代",
    "section": "",
    "text": "可以为函数起一个专属名称，让代码更易读。\n只需在一处更新代码，而无需修改多处。\n可在不同项目中复用代码，从而长期提升生产力。\n\n\n当复制粘贴某段代码超过两次，或同一代码有三份副本，就应该考虑将其改写为函数。\n\n\n\n向量函数：输入一个或多个向量，返回一个向量。\n数据框函数：输入一个数据框，返回一个数据框。\n绘图函数：输入一个数据框，返回一个图形。\n\n\nlibrary(tidyverse)  \nlibrary(nycflights13)",
    "crumbs": [
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>迭代</span>"
    ]
  },
  {
    "objectID": "chapters/ch26_iteration.html#向量函数",
    "href": "chapters/ch26_iteration.html#向量函数",
    "title": "27  迭代",
    "section": "27.2 向量函数",
    "text": "27.2 向量函数\n首先介绍向量函数。向量函数接受一个或多个向量作为输入，并返回一个向量作为输出。\n\n27.2.1 编写\n编写函数的第一步是分析重复代码，找出哪些部分是固定的，哪些部分是变化的。\n比如下面这个数据框相关代码：\ndf &lt;- tibble(\n  a = rnorm(5),\n  b = rnorm(5),\n  c = rnorm(5),\n  d = rnorm(5),\n)\n\ndf |&gt; mutate(\n  a = (a - min(a, na.rm = TRUE)) / \n    (max(a, na.rm = TRUE) - min(a, na.rm = TRUE)),\n  b = (b - min(b, na.rm = TRUE)) / \n    (max(b, na.rm = TRUE) - min(b, na.rm = TRUE)),\n  c = (c - min(c, na.rm = TRUE)) / \n    (max(c, na.rm = TRUE) - min(c, na.rm = TRUE)),\n  d = (d - min(d, na.rm = TRUE)) / \n    (max(d, na.rm = TRUE) - min(d, na.rm = TRUE)),\n)\n#&gt; # A tibble: 5 × 4\n#&gt;       a       b     c     d\n#&gt;   &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1 0.339  0.387  0.291 0    \n#&gt; 2 0.880 -0.613  0.611 0.557\n#&gt; 3 0     -0.0833 1     0.752\n#&gt; 4 0.795 -0.0822 0     1    \n#&gt; 5 1     -0.0952 0.580 0.394\n显然 mutate()中的部分有多次重复，不妨将其单独提出，每一行代表一次重复：\n(a - min(a, na.rm = TRUE)) / (max(a, na.rm = TRUE) - min(a, na.rm = TRUE))\n(b - min(b, na.rm = TRUE)) / (max(b, na.rm = TRUE) - min(b, na.rm = TRUE))\n(c - min(c, na.rm = TRUE)) / (max(c, na.rm = TRUE) - min(c, na.rm = TRUE))\n(d - min(d, na.rm = TRUE)) / (max(d, na.rm = TRUE) - min(d, na.rm = TRUE))  \n可以用一个占位符 █表示变化部分：\n(█ - min(█, na.rm = TRUE)) / (max(█, na.rm = TRUE) - min(█, na.rm = TRUE))\n要将其转换为函数，需要三个关键组成部分：\n\n函数名（name）：此处使用 rescale01，表示将向量缩放至 [0, 1]。\n参数（arguments）：此处只需一个参数，命名为 x。\n函数体（body）：即重复代码的逻辑。\n\n遵循以下模板：\nname &lt;- function(arguments) {\n  body\n}\n对应本例：\nrescale01 &lt;- function(x) {\n  (x - min(x, na.rm = TRUE)) / (max(x, na.rm = TRUE) - min(x, na.rm = TRUE))\n}\n可以用简单输入进行测试：\nrescale01(c(-10, 0, 10))         # [1] 0.0 0.5 1.0\nrescale01(c(1, 2, 3, NA, 5))     # [1] 0.00 0.25 0.50   NA 1.00\n随后重写 mutate() 调用：\ndf |&gt; mutate(\n  a = rescale01(a),\n  b = rescale01(b),\n  c = rescale01(c),\n  d = rescale01(d),\n)\n\n\n27.2.2 优化\n注意到 rescale01() 中 min() 和 max() 被多次调用，可以用 range()进行简化：\nrescale01 &lt;- function(x) {\n  rng &lt;- range(x, na.rm = TRUE)\n  (x - rng[1]) / (rng[2] - rng[1])\n}\n\nrange()函数接收数值向量，输出最小值和最大值。\n\n再用包含无穷值的向量检验函数：\nx &lt;- c(1:10, Inf)\nrescale01(x)  # 返回值含 NaN，不理想\n可以用 finite = TRUE 参数忽略无穷值：\nrescale01 &lt;- function(x) {\n  rng &lt;- range(x, na.rm = TRUE, finite = TRUE)\n  (x - rng[1]) / (rng[2] - rng[1])\n}\n\n\n27.2.3 变换函数（mutate functions）\n现在我们已大致了解了函数的编写过程，下面通过介绍一些具有特定功能的函数进行深入说明。\n变换函数是一类输入与输出的向量长度一致的函数，故而其结果适用于 mutate() 和 filter() 。\n标准化 Z-score函数的结构如下，与刚刚编写的rescale01比较类似：\nz_score &lt;- function(x) {\n  (x - mean(x, na.rm = TRUE)) / sd(x, na.rm = TRUE)\n}\n再如下面的字符向量操作，能够将首字母转为大写：\nfirst_upper &lt;- function(x) {\n  str_sub(x, 1, 1) &lt;- str_to_upper(str_sub(x, 1, 1))\n  x\n}\n\nfirst_upper(\"hello\")  # \"Hello\"\n\n细节说明：\n\nstr_sub(x, 1, 1)：提取每个字符串的第1个字符，1, 1 表示从第1个字符开始，到第1个字符结束。\nstr_to_upper()：将字符转为大写。\n最后的 x 表示返回修改后的完整字符串向量。\n\n\n\n\n27.2.4 汇总函数（summary functions）\n接下来是汇总函数，一般用于 summarize()，能够返回一个单值。\n下面是用逗号连接字符串的一个汇总函数：\ncommas &lt;- function(x) {\n  str_flatten(x, collapse = \", \", last = \" and \")\n}\n\ncommas(c(\"cat\", \"dog\", \"pigeon\"))  # \"cat, dog and pigeon\"\n\n细节说明：\n\nstr_flatten()：将字符向量合并为单个字符串。\ncollapse = \", \"表示普通元素间用逗号+空格分隔；last = \" and \"表示最后两个元素之间用 and 连接。\n\n\n也可以输入多个向量，而输出仍是单值。例如下面用于计算 MAPE（平均绝对百分比误差）的函数：\nmape &lt;- function(actual, predicted) {\n  sum(abs((actual - predicted) / actual)) / length(actual)\n}\n\n写函数时，以下 RStudio 快捷键非常方便：\n\n查看函数定义：将输入光标置于函数名上，按 F2。\n跳转到函数：按 Ctrl + . 可打开模糊搜索，可跳转到函数、文件或 Quarto 小节等位置。",
    "crumbs": [
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>迭代</span>"
    ]
  },
  {
    "objectID": "chapters/ch26_iteration.html#数据框函数",
    "href": "chapters/ch26_iteration.html#数据框函数",
    "title": "27  迭代",
    "section": "27.3 数据框函数",
    "text": "27.3 数据框函数\n当我们需要重复使用dplyr动词时，就可以考虑编写一个数据框函数。它们以数据框作为第一个参数，后面跟着一些额外的参数用于说明如何处理，并输出一个数据框或向量。\n\n27.3.1 间接引用与整洁求值\n当开始编写使用 dplyr 动词的函数时，我们很快就会遇到间接引用的问题。下面用一个简单函数grouped_mean()来说明。该函数的目标是根据 group_var 分组并计算 mean_var 的平均值：\ngrouped_mean &lt;- function(df, group_var, mean_var) {\n  df |&gt;\n    group_by(group_var) |&gt; \n    summarize(mean(mean_var))\n}\n看起来没啥问题，但是运行时会得到一个错误：\ndiamonds |&gt; grouped_mean(cut, carat)\n#&gt; Error in `group_by()`:\n#&gt; ! Must group by variables found in `.data`.\n#&gt; ✖ Column `group_var` is not found.\n不难发现，此函数似乎是想寻找本应在函数定义中充当变量的group_var。dplyr 默认直接捕获函数参数中写死的变量名（如 group_var），而不是评估新传入的参数名（如 group 和 x）。这就是“间接引用”。它产生的原因是 dplyr 采取“整洁求值”（tidy evaluation）的规则，本意是方便我们在数据框中直接引用变量名而无需特别处理，但在封装成函数时却成了绊脚石。\n好消息是，dplyr提供了解决方案，称为 embracing 🤗。embracing 将变量包裹在双层大括号中，例如 var 写成 { var }，意为使用参数中的值，而不是把参数本身当作变量名。\n因此，要让 grouped_mean() 正确工作，我们需要用 { } 包裹 group_var 和 mean_var：\ngrouped_mean &lt;- function(df, group_var, mean_var) {\n  df |&gt; \n    group_by({{ group_var }}) |&gt; \n    summarize(mean({{ mean_var }}))\n}\n\ndf |&gt; grouped_mean(group, x)\n#&gt; # A tibble: 1 × 2\n#&gt;   group `mean(x)`\n#&gt;   &lt;dbl&gt;     &lt;dbl&gt;\n#&gt; 1     1        10\n成功！\n\n\n27.3.2 什么时候使用 embracing？\n经过上节解释不难看出，编写数据框函数的关键是确定哪些函数的参数需要 embracing，而这可以从文档中查到 。\n大体分为两类：\n\n数据掩码（Data-masking）： arrange()、filter()、 summarize() 等对变量计算的函数。\n整洁选择（Tidy-selection）： select()、relocate() 、rename() 等选择变量的函数。\n\n\n\n27.3.3 常见用例\n如果你在处理数据时经常执行相同的某种汇总操作，便可以考虑将它们封装成一个辅助函数：\nsummary6 &lt;- function(data, var) {\n  data |&gt; summarize(\n    min = min({{ var }}, na.rm = TRUE),\n    mean = mean({{ var }}, na.rm = TRUE),\n    median = median({{ var }}, na.rm = TRUE),\n    max = max({{ var }}, na.rm = TRUE),\n    n = n(),\n    n_miss = sum(is.na({{ var }})),\n    .groups = \"drop\"\n  )\n}\n\ndiamonds |&gt; summary6(carat)\n#&gt; # A tibble: 1 × 6\n#&gt;     min  mean median   max     n n_miss\n#&gt;   &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt;  &lt;int&gt;\n#&gt; 1   0.2 0.798    0.7  5.01 53940      0\n\n将 summarize() 封装成辅助函数时，建议设置 .groups = \"drop\"，以清除所有分组属性，将数据框还原为普通表格。\n\n再来一例，下面这个新定义函数是 count() 的增强版，能够同时计算比例：\ncount_prop &lt;- function(df, var, sort = FALSE) {\n  df |&gt;\n    count({{ var }}, sort = sort) |&gt;\n    mutate(prop = n / sum(n))\n}\n\ndiamonds |&gt; count_prop(clarity)\n#&gt; # A tibble: 8 × 3\n#&gt;   clarity     n   prop\n#&gt;   &lt;ord&gt;   &lt;int&gt;  &lt;dbl&gt;\n#&gt; 1 I1        741 0.0137\n#&gt; 2 SI2      9194 0.170 \n#&gt; 3 SI1     13065 0.242 \n#&gt; 4 VS2     12258 0.227 \n#&gt; 5 VS1      8171 0.151 \n#&gt; 6 VVS2     5066 0.0939\n#&gt; # ℹ 2 more rows\n这个函数有三个参数：df、var 和 sort，只有 var 需要 embracing，因为它传递给了 count()。注意， sort 设置了默认值，如果用户未提供值，则默认为 FALSE。\n以上例子都是把数据框作为第一个参数，但如果反复使用相同的数据，也可以硬编码它。例如下面这个函数可直接定向使用 flights 数据集，定向选择 time_hour、carrier 和 flight：\nsubset_flights &lt;- function(rows, cols) {\n  flights |&gt; \n    filter({{ rows }}) |&gt; \n    select(time_hour, carrier, flight, {{ cols }})\n}\n\n\n27.3.4 数据掩码 vs. 整洁选择\n有时我们会想在使用 data-masking 的函数中选择变量。例如想定义一个 count_missing() 来统计缺失观测值的数量，可能会像这样写：\ncount_missing &lt;- function(df, group_vars, x_var) {\n  df |&gt; \n    group_by({{ group_vars }}) |&gt; \n    summarize(\n      n_miss = sum(is.na({{ x_var }})),\n      .groups = \"drop\"\n    )\n}\n\nflights |&gt; \n  count_missing(c(year, month, day), dep_time)\n#&gt; Error in `group_by()`:\n#&gt; ℹ In argument: `c(year, month, day)`.\n#&gt; Caused by error:\n#&gt; ! `c(year, month, day)` must be size 336776 or 1, not 1010328.\n函数报错了，因为 group_by() 属于 data-masking，而不是 tidy-selection。此时可以在对应函数里套一个 pick() 函数，就能让我们在 data-masking 函数中使用 tidy-selection 方式：\ncount_missing &lt;- function(df, group_vars, x_var) {\n  df |&gt; \n    group_by(pick({{ group_vars }})) |&gt; \n    summarize(\n      n_miss = sum(is.na({{ x_var }})),\n      .groups = \"drop\"\n  )\n}\nflights |&gt; \n  count_missing(c(year, month, day), dep_time)\n#&gt; # A tibble: 365 × 4\n#&gt;    year month   day n_miss\n#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;  &lt;int&gt;\n#&gt; 1  2013     1     1      4\n#&gt; 2  2013     1     2      8\n#&gt; 3  2013     1     3     10\n#&gt; 4  2013     1     4      6\n#&gt; 5  2013     1     5      3\n#&gt; 6  2013     1     6      1\n#&gt; # ℹ 359 more rows\npick() 的另一个实用场景是构建二维计数表。比如下面我们将全部行列变量计数，然后用 pivot_wider() 将计数转换成网格：\ncount_wide &lt;- function(data, rows, cols) {\n  data |&gt; \n    count(pick(c({{ rows }}, {{ cols }}))) |&gt; \n    pivot_wider(\n      names_from = {{ cols }}, \n      values_from = n,\n      names_sort = TRUE,\n      values_fill = 0\n    )\n}\n\ndiamonds |&gt; count_wide(c(clarity, color), cut)\n#&gt; # A tibble: 56 × 7\n#&gt;   clarity color  Fair  Good `Very Good` Premium Ideal\n#&gt;   &lt;ord&gt;   &lt;ord&gt; &lt;int&gt; &lt;int&gt;       &lt;int&gt;   &lt;int&gt; &lt;int&gt;\n#&gt; 1 I1      D         4     8           5      12    13\n#&gt; 2 I1      E         9    23          22      30    18\n#&gt; 3 I1      F        35    19          13      34    42\n#&gt; 4 I1      G        53    19          16      46    16\n#&gt; 5 I1      H        52    14          12      46    38\n#&gt; 6 I1      I        34     9           8      24    17\n#&gt; # ℹ 50 more rows",
    "crumbs": [
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>迭代</span>"
    ]
  },
  {
    "objectID": "chapters/ch26_iteration.html#绘图函数",
    "href": "chapters/ch26_iteration.html#绘图函数",
    "title": "27  迭代",
    "section": "27.4 绘图函数",
    "text": "27.4 绘图函数\n讲完数据框函数，现在来看看如何定义绘图函数。 aes() 同样是一个数据掩码函数（data-masking function），所以技巧大差不差。\n打个比方，假设我们需要制作很多直方图：\ndiamonds |&gt; \n  ggplot(aes(x = carat)) +\n  geom_histogram(binwidth = 0.1)\n\ndiamonds |&gt; \n  ggplot(aes(x = carat)) +\n  geom_histogram(binwidth = 0.05)\n如果可以把这个过程封装成一个 histogram 函数，那岂不是方便多了？确实很容易实现：\nhistogram &lt;- function(df, var, binwidth = NULL) {\n  df |&gt; \n    ggplot(aes(x = {{ var }})) + \n    geom_histogram(binwidth = binwidth)\n}\n\ndiamonds |&gt; histogram(carat, 0.1)\n这样运行后便可得到一个关于钻石克拉的直方图。\n上面自定义的histogram() 返回的是一个 ggplot2 图表对象，这意味着我们仍然可以像平常一样添加其它组件，只要记得把 |&gt; 换成 +。比如添加标签：\ndiamonds |&gt; \n  histogram(carat, 0.1) +\n  labs(x = \"Size (in carats)\", y = \"Number of diamonds\")\n\n27.4.1 更多变量\n基于新函数的框架，我们可以轻松地添加更多变量。例如，若想快速查看一个数据集是否呈线性关系，可以创建新函数linearity_check()来叠加一条平滑曲线和一条直线：\nlinearity_check &lt;- function(df, x, y) {\n  df |&gt;\n    ggplot(aes(x = {{ x }}, y = {{ y }})) +\n    geom_point() +\n    geom_smooth(method = \"loess\", formula = y ~ x, color = \"red\", se = FALSE) +\n    geom_smooth(method = \"lm\", formula = y ~ x, color = \"blue\", se = FALSE) \n}\n\nstarwars |&gt; \n  filter(mass &lt; 1000) |&gt; \n  linearity_check(mass, height)\n\n如此便可画出星球大战人物的身高与体重散点图，显示出正相关关系。红色曲线为平滑趋势线，蓝色线为最佳拟合直线。\n对于过于庞大的数据集，为避免图像重叠，不妨通过新定义使用六边形图来展示散点图的密度：\nhex_plot &lt;- function(df, x, y, z, bins = 20, fun = \"mean\") {\n  df |&gt; \n    ggplot(aes(x = {{ x }}, y = {{ y }}, z = {{ z }})) + \n    stat_summary_hex(\n      aes(color = after_scale(fill)), \n      bins = bins, \n      fun = fun,\n    )\n}\n\ndiamonds |&gt; hex_plot(carat, price, depth)\n\n\n\n27.4.2 与 tidyverse 结合\n高效的绘图函数一般都将数据处理和 ggplot2 相结合。例如使用 fct_infreq()函数生成一个按频率排序的垂直柱状图，同时要让频率最高的在顶部，则可定义sorted_bars()：\nsorted_bars &lt;- function(df, var) {\n  df |&gt; \n    mutate({{ var }} := fct_rev(fct_infreq({{ var }})))  |&gt;\n    ggplot(aes(y = {{ var }})) +\n    geom_bar()\n}\n\ndiamonds |&gt; sorted_bars(clarity)\n\n注意新的运算符 :=（海象运算符 walrus operator）。\n由于我们需要根据用户输入的数据生成变量名，且变量名需要放在等号 = 的左边，但 R 的语法不允许=左边是表达式。所以此处必须使用 :=替代 = 。\n\n\n\n\n27.4.3 图表标签\n还记得我们之前写的直方图函数吗？\nhistogram &lt;- function(df, var, binwidth = NULL) {\n  df |&gt; \n    ggplot(aes(x = {{ var }})) + \n    geom_histogram(binwidth = binwidth)\n}\n如果图表能自动标注变量名和 bin 宽度，岂不是更好？为了解决标注问题，我们可以使用 rlang::englue()。它的作用类似于 str_glue()：\n\n将 {} 中的值插入字符串。\n识别 { }，并自动插入变量名：\n\nhistogram &lt;- function(df, var, binwidth) {\n  label &lt;- rlang::englue(\"A histogram of {{ var }} with binwidth {binwidth}\")\n  \n  df |&gt; \n    ggplot(aes(x = {{ var }})) + \n    geom_histogram(binwidth = binwidth) + \n    labs(title = label)\n}\n\ndiamonds |&gt; histogram(carat, 0.1)",
    "crumbs": [
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>迭代</span>"
    ]
  },
  {
    "objectID": "chapters/ch26_iteration.html#代码风格规范",
    "href": "chapters/ch26_iteration.html#代码风格规范",
    "title": "27  迭代",
    "section": "27.5 代码风格规范",
    "text": "27.5 代码风格规范\n虽然函数或参数命名的规范性不会影响R对其的执行，但恰当的命名对代码的可读性至关重要。理想的函数名应当简洁明了，能准确传达函数的功能。\n通常而言，函数名宜采用动词，参数名宜采用名词。当然也有例外，比如某些约定成俗的名词，如均值函数mean()就比compute_mean()更合适。开发者应当灵活判断，大胆命名。\n列出一些命名的反面示例，仅供参考：\n# 名称过短\nf()\n\n# 非动词且表意模糊\nmy_awesome_function()\n\n# 正面示范（名称虽长但语义清晰）\nimpute_missing()\ncollapse_years()\n同样地，代码中空格的使用规范不影响使用效果，但会影响代码的可读性。务必遵循第4章的格式规范，并特别注意：\n\nfunction()后必须紧跟花括号{}，且函数体需缩进两个空格。\n建议在{ }内部添加额外空格（如{ color }），能显著提醒读者此处存在特殊语法操作。",
    "crumbs": [
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>迭代</span>"
    ]
  },
  {
    "objectID": "chapters/ch27_field_guide_base_R.html",
    "href": "chapters/ch27_field_guide_base_R.html",
    "title": "28  Base R 实战指南",
    "section": "",
    "text": "28.1 引言\n本章介绍 Base R。\n本书前面重点介绍 tidyverse，是因为其套件遵循统一的设计理念，整洁优雅。但使用 tidyverse 必然需要 Base R ，比如从加载包的 library()，到数值汇总的 sum() 和 mean()，再到因子（factor）、日期（date）和 POSIXct 数据类型，以及所有基础运算符（如 +, -, /, *, |, &, ! 等）。\n而 Base R 的工作流程此前尚未系统讲解，本章将补全这最后一块拼图。\n本章以 Base R 为核心，为了对比差异，需加载 tidyverse 作为参照：",
    "crumbs": [
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Base R 实战指南</span>"
    ]
  },
  {
    "objectID": "chapters/ch27_field_guide_base_R.html#引言",
    "href": "chapters/ch27_field_guide_base_R.html#引言",
    "title": "28  Base R 实战指南",
    "section": "",
    "text": "library(tidyverse)",
    "crumbs": [
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Base R 实战指南</span>"
    ]
  },
  {
    "objectID": "chapters/ch27_field_guide_base_R.html#使用-选择多个元素",
    "href": "chapters/ch27_field_guide_base_R.html#使用-选择多个元素",
    "title": "28  Base R 实战指南",
    "section": "28.2 使用 [] 选择多个元素",
    "text": "28.2 使用 [] 选择多个元素\n[] 用于从向量和数据框中提取子组件，称为向量子集化。使用形式为 x[i] 或 x[i, j]。某些 dplyr 动词其实是 [] 的特殊形式。\n\n\n28.2.1 子集化向量\nx[i] 中的i有五种常见对象 ：\n\n正整数向量\n\n使用正整数子集化会保留对应位置的元素：\nx &lt;- c(\"one\", \"two\", \"three\", \"four\", \"five\")\nx[c(3, 2, 5)]\n#&gt; [1] \"three\" \"two\"   \"five\"\n通过重复，可得到比原来更长的向量，因此“子集化”这个词并不总是字面意义上的“变小”。\nx[c(1, 1, 5, 5, 5, 2)]\n#&gt; [1] \"one\"  \"one\"  \"five\" \"five\" \"five\" \"two\"\n\n负整数向量\n\n使用负整数则会删除指定位置的元素：\nx[c(-1, -3, -5)]\n#&gt; [1] \"two\"  \"four\"\n\n逻辑向量\n\n使用逻辑向量时，仅保留对应 TRUE 的位置：\nx &lt;- c(10, 3, NA, 5, 8, 1, NA)\n\n# 所有非缺失值\nx[!is.na(x)]\n#&gt; [1] 10  3  5  8  1\n\n# 所有偶数及NA\nx[x %% 2 == 0]\n#&gt; [1] 10 NA  8 NA\n\n字符向量\n\n如果一个向量有名称，可以用字符向量来进行子集化：\nx &lt;- c(abc = 1, def = 2, xyz = 5)\nx[c(\"xyz\", \"def\")]\n#&gt; xyz def \n#&gt;   5   2\n\n空值（Nothing）\n\n最后一种子集方式是空 x[]，返回完整的 x。\n\n\n\n28.2.2 子集化数据框\n数据框子集化有很多方法，最重要的是 df[rows, cols]，即分别选择行和列。rows 和 cols 可以是前述的任意一种向量类型。\n例如：\ndf &lt;- tibble(\n  x = 1:3, \n  y = c(\"a\", \"e\", \"f\"), \n  z = runif(3)\n)\n\n# 选择第1行第2列\ndf[1, 2]\n#&gt; # A tibble: 1 × 1\n#&gt;   y    \n#&gt;   &lt;chr&gt;\n#&gt; 1 a\n\n# 选择所有行和列\ndf[, c(\"x\", \"y\")]\n#&gt; # A tibble: 3 × 2\n#&gt;       x y    \n#&gt;   &lt;int&gt; &lt;chr&gt;\n#&gt; 1     1 a    \n#&gt; 2     2 e    \n#&gt; 3     3 f\n\n# 选择 x &gt; 1 的所有行\ndf[df$x &gt; 1, ]\n#&gt; # A tibble: 2 × 3\n#&gt;       x y         z\n#&gt;   &lt;int&gt; &lt;chr&gt; &lt;dbl&gt;\n#&gt; 1     2 e     0.834\n#&gt; 2     3 f     0.601\n\ndf$x 用于提取数据框中名为 x 的列。此处需要使用 $ 是因为 [ 不支持 tidy evaluation，所以必须显式写出变量来源。\n\n\n\n\n28.2.3 dplyr 的等效写法\n很多 dplyr 的动词其实就是 [] 的特殊形式。\nfilter() 相当于使用逻辑向量筛选行，同时排除缺失值：\ndf &lt;- tibble(\n  x = c(2, 3, 1, 1, NA), \n  y = letters[1:5], \n  z = runif(5)\n)\n\ndf |&gt; filter(x &gt; 1)\n\n# 等价于\ndf[!is.na(df$x) & df$x &gt; 1, ]\n[]中也可使用 which() 来自动去除 NA：\ndf[which(df$x &gt; 1), ]\narrange() 相当于使用整数向量（通常由 order() 创建）对行排序：\ndf |&gt; arrange(x, y)\n\n# 等价于\ndf[order(df$x, df$y), ]\n[]中降序排序可以使用 order(..., decreasing = TRUE)，或者对某列用 -rank(col)。\nselect() 和 relocate() 类似于使用字符向量选择列：\ndf |&gt; select(x, z)\n\n# 等价于\ndf[, c(\"x\", \"z\")]\nBase R 还提供了一个结合了 filter() 和 select() 功能的函数 subset()：\ndf |&gt; \n  filter(x &gt; 1) |&gt; \n  select(y, z)\n#&gt; # A tibble: 2 × 2\n#&gt;   y           z\n#&gt;   &lt;chr&gt;   &lt;dbl&gt;\n#&gt; 1 a     0.157  \n#&gt; 2 b     0.00740\n\n# 等价于\ndf |&gt; subset(x &gt; 1, c(y, z))",
    "crumbs": [
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Base R 实战指南</span>"
    ]
  },
  {
    "objectID": "chapters/ch27_field_guide_base_R.html#使用-和-选择单个元素",
    "href": "chapters/ch27_field_guide_base_R.html#使用-和-选择单个元素",
    "title": "28  Base R 实战指南",
    "section": "28.3 使用 $ 和 [[]] 选择单个元素",
    "text": "28.3 使用 $ 和 [[]] 选择单个元素\n[] 用于选择多个元素，而 [[]] 和 $ 用于提取单个元素。\n\n\n28.3.1 数据框\n[[]] 和 $ 可以用来从数据框中提取列。[[]] 可通过位置或名称访问，$ 则专用于通过名称访问：\ntb &lt;- tibble(\n  x = 1:4,\n  y = c(10, 4, 1, 21)\n)\n\n# 按位置访问\ntb[[1]]\n#&gt; [1] 1 2 3 4\n\n# 按名称访问\ntb[[\"x\"]]\n#&gt; [1] 1 2 3 4\ntb$x\n#&gt; [1] 1 2 3 4\n它们也可以用来创建新列，是mutate() 的等价写法：\ntb$z &lt;- tb$x + tb$y\ntb\n#&gt; # A tibble: 4 × 3\n#&gt;       x     y     z\n#&gt;   &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1     1    10    11\n#&gt; 2     2     4     6\n#&gt; 3     3     1     4\n#&gt; 4     4    21    25\n直接使用 $ 对于快速汇总非常方便。例如下面这一例，要找出最大钻石的重量，或者了解 cut 的取值范围，就不必用 summarize()：\nmax(diamonds$carat)\n#&gt; [1] 5.01\n\nlevels(diamonds$cut)\n#&gt; [1] \"Fair\"      \"Good\"      \"Very Good\" \"Premium\"   \"Ideal\"\ndplyr 也提供了 [[]] 和 $ 的等价函数：pull()。pull() 接受变量名称或变量位置作为参数，并返回该列，从而可以将上面的代码改写为管道：\ndiamonds |&gt; pull(carat) |&gt; max()\n#&gt; [1] 5.01\n\ndiamonds |&gt; pull(cut) |&gt; levels()\n#&gt; [1] \"Fair\"      \"Good\"      \"Very Good\" \"Premium\"   \"Ideal\"\n\n\n\n28.3.2 Tibbles\n在使用 $ 时，tibble 与 base 函数data.frame 有一些差异。 data.frame 会匹配变量名的前缀（即“部分匹配”），列不存在时不会报错：\ndf &lt;- data.frame(x1 = 1)\ndf$x\n#&gt; [1] 1\ndf$z\n#&gt; NULL\ntibble 则颇为严格，只精确匹配变量名，列不存在时发出警告：\ntb &lt;- tibble(x1 = 1)\n\ntb$x\n#&gt; Warning: Unknown or uninitialised column: `x`.\n#&gt; NULL\ntb$z\n#&gt; Warning: Unknown or uninitialised column: `z`.\n#&gt; NULL\n\n\n\n28.3.3 列表\n[[]] 和 $ 也可用于处理列表，我们须知晓它们与 [] 的区别。\n下面用一个名为 l 的列表来说明：\nl &lt;- list(\n  a = 1:3, \n  b = \"a string\", \n  c = pi, \n  d = list(-1, -5)\n)\n[] 提取的是子列表。无论提取多少元素，结果仍是列表；而[[ 和 $ 提取的是列表的单个元素：\nstr(l[1])\n#&gt; List of 1\n#&gt;  $ a: int [1:3] 1 2 3\nstr(l[[1]])\n#&gt;  int [1:3] 1 2 3\n\nstr(l[4])\n#&gt; List of 1\n#&gt; $ d:List of 2\n#&gt;  ..$ : num -1\n#&gt;  ..$ : num -5\nstr(l[[4]])\n#&gt; List of 2\n#&gt;  $ : num -1\n#&gt;  $ : num -5\n为了帮助读者记忆，来看看本书作者给的图例。假设有一个胡椒罐叫 pepper，其中装的是单独包装好的胡椒包。\n\n\npepper[1] 是装着第一个胡椒包的胡椒罐。\npepper[2] 是装着第二个胡椒包的胡椒罐。\npepper[1:2] 是装着两个胡椒包的胡椒罐。\npepper[[1]] 则是直接拿出一个胡椒包，为其本身。",
    "crumbs": [
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Base R 实战指南</span>"
    ]
  },
  {
    "objectID": "chapters/ch27_field_guide_base_R.html#apply-家族",
    "href": "chapters/ch27_field_guide_base_R.html#apply-家族",
    "title": "28  Base R 实战指南",
    "section": "28.4 Apply 家族",
    "text": "28.4 Apply 家族\napply 家族用于迭代，对应 across() 和 map 系列函数的功能。\nlapply()最为常用，与 purrr::map() 非常相似。实际上我们可以把第 26 章中所有的 map() 都换成 lapply()。\n虽然 base R 中没有完全等价于 across() 的函数，但通过结合 [] 和 lapply() 可以实现类似效果。因为数据框在底层实际上是由列组成的列表，所以对数据框使用 lapply() 会把函数应用到每一列上。\ndf &lt;- tibble(a = 1, b = 2, c = \"a\", d = \"b\", e = 4)\n\n# 首先找出数值型列\nnum_cols &lt;- sapply(df, is.numeric)\nnum_cols\n#&gt;     a     b     c     d     e \n#&gt;  TRUE  TRUE FALSE FALSE  TRUE\n\n# 然后用 lapply() 变换每一列，并替换原数据\ndf[, num_cols] &lt;- lapply(df[, num_cols, drop = FALSE], \\(x) x * 2)\ndf\n#&gt; # A tibble: 1 × 5\n#&gt;       a     b c     d         e\n#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt;\n#&gt; 1     2     4 a     b         8\n上面的代码还使用了一个新函数 sapply()。它类似于 lapply()，但其结果会对输入进行简化。purrr 中也有类似的函数 map_vec()，但第 26 章中未提及。\n此外，还有一个更严格的版本叫 vapply()，即 vector apply。它多了一个参数，用于指定输出模板，从而确保简化结果不受输入影响。例如，可以用 vapply() 来替代上面的 sapply()，明确指定 is.numeric() 返回一个长度为 1 的逻辑向量：\nvapply(df, is.numeric, logical(1))\n#&gt;     a     b     c     d     e \n#&gt;  TRUE  TRUE FALSE FALSE  TRUE\n接下来介绍tapply()，用于计算按组汇总的单个值。最常用的形式为tapply(x, group, fun)，x是要处理的列，group是用于分组的标准列，fun表示计算方式，比如下面对cut分组，并计算price的均值：\ntapply(diamonds$price, diamonds$cut, mean)\n#&gt;      Fair      Good Very Good   Premium     Ideal \n#&gt;  4358.758  3928.864  3981.760  4584.258  3457.542\n等价的dplyr写法是：\ndiamonds |&gt; \n  group_by(cut) |&gt; \n  summarize(price = mean(price))\n#&gt; # A tibble: 5 × 2\n#&gt;   cut       price\n#&gt;   &lt;ord&gt;     &lt;dbl&gt;\n#&gt; 1 Fair      4359.\n#&gt; 2 Good      3929.\n#&gt; 3 Very Good 3982.\n#&gt; 4 Premium   4584.\n#&gt; 5 Ideal     3458.\n显然，tapply() 返回的是命名向量，组合成数据框需要额外操作。\n最后介绍 apply()，专门用于矩阵和数组，基础用法是apply(x, margin, fun)，x是矩阵或数组，margin指定行或列，fun是计算方式。",
    "crumbs": [
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Base R 实战指南</span>"
    ]
  },
  {
    "objectID": "chapters/ch27_field_guide_base_R.html#for-循环",
    "href": "chapters/ch27_field_guide_base_R.html#for-循环",
    "title": "28  Base R 实战指南",
    "section": "28.5 for 循环",
    "text": "28.5 for 循环\nfor 循环是迭代的基础构建模块，是apply 和 map 等函数的底层逻辑。for 循环基本结构如下：\nfor (element in vector) {\n  # 一些操作\n}\nfor 循环最直接的用途与 walk() 相同，对列表的每个元素调用一个具有副作用的函数。\n例如在第 26.4.1 节中使用的 walk()：\npaths |&gt; walk(append_file)\n可以用 for 循环来实现同样的功能：\nfor (path in paths) {\n  append_file(path)\n}\n\n如果想保存输出，比如读取一个文件夹下的所有 Excel 文件，用map()操作如下：\npaths &lt;- dir(\"data/gapminder\", pattern = \"\\\\.xlsx$\", full.names = TRUE)\nfiles &lt;- map(paths, readxl::read_excel)\n而使用for循环则稍微复杂一些。\n首先需要提前明确输出的结构，在此例中，我们的输出应当是与 paths 长度相同的列表，可以用 vector() 来创建：\nfiles &lt;- vector(\"list\", length(paths))\n\nvector基本语法为vector(mode = \"logical\", length = 0)。model指定向量类型，默认为逻辑向量；length指定向量的初始长度（默认为0）。\n\n接着，我们不直接对 paths 的元素进行迭代，而是对其索引进行迭代，用 seq_along() 为 paths 中的每个元素生成一个索引：\nseq_along(paths)\n#&gt;  [1]  1  2  3  4  5  6  7  8  9 10 11 12\n使用索引，我们便可以将输入和输出中的位置一一对应起来，完成读取：\nfor (i in seq_along(paths)) {\n  files[[i]] &lt;- readxl::read_excel(paths[[i]])\n}\n\n将包含多个 tibble 的列表合并成一个 tibble，可以用 do.call() + rbind()：\ndo.call(rbind, files)\n#&gt; # A tibble: 1,704 × 5\n#&gt;   country     continent lifeExp      pop gdpPercap\n#&gt;   &lt;chr&gt;       &lt;chr&gt;       &lt;dbl&gt;    &lt;dbl&gt;     &lt;dbl&gt;\n#&gt; 1 Afghanistan Asia         28.8  8425333      779.\n#&gt; 2 Albania     Europe       55.2  1282697     1601.\n#&gt; 3 Algeria     Africa       43.1  9279525     2449.\n#&gt; 4 Angola      Africa       30.0  4232095     3521.\n#&gt; 5 Argentina   Americas     62.5 17876956     5911.\n#&gt; 6 Australia   Oceania      69.1  8691212    10040.\n#&gt; # ℹ 1,698 more rows\n比起先建立一个列表再保存结果，更简单的方法是逐步构建数据框：\nout &lt;- NULL\nfor (path in paths) {\n  out &lt;- rbind(out, readxl::read_excel(path))\n}\n但不推荐这种写法，因为当向量很长时这种方式会非常慢，这也正是“for 循环很慢”这一刻板印象的源头。但实际上，不是 for 循环慢，而是反复扩展向量的过程慢。",
    "crumbs": [
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Base R 实战指南</span>"
    ]
  },
  {
    "objectID": "chapters/ch27_field_guide_base_R.html#r-base-绘图",
    "href": "chapters/ch27_field_guide_base_R.html#r-base-绘图",
    "title": "28  Base R 实战指南",
    "section": "28.6 R base 绘图",
    "text": "28.6 R base 绘图\n尽管ggplot2几乎是最有优势的绘图工具，但base R绘图函数仍因其简洁性而具有实用价值，只需极少代码即可完成基础探索性图表。\n实际分析中最常见的 base R 图表有两种，分别是散点图plot()和直方图hist()。以下以diamonds数据集为例进行演示：\n# 左图：直方图\nhist(diamonds$carat)\n\n# 右图：散点图\nplot(diamonds$carat, diamonds$price)\n\n需注意，base R 绘图函数必须直接操作向量，因此需要通过$等方式从数据框中提取列。",
    "crumbs": [
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Base R 实战指南</span>"
    ]
  },
  {
    "objectID": "chapters/ch28_quarto.html",
    "href": "chapters/ch28_quarto.html",
    "title": "29  Quarto",
    "section": "",
    "text": "29.1 引言\nQuarto 是一个面向数据科学的统一创作框架，支持可完全复现的文档生成，且输出格式多样。\nQuarto 是一个命令行工具，而非 R 包，因此无法通过 ? 获取帮助。不过可查阅Quarto 官方文档。\n简言之，Quarto 就是进阶版的 R Markdown，它整合了 R Markdown 生态中的多个包（如 rmarkdown、bookdown、distill、xaringan 等），且扩展了对多语言（如 Python、Julia 和 R）的原生支持。\n使用 Quarto 需要安装命令行接口（CLI），但在 RStudio 中无须手动安装或加载，系统会在需要时自动完成相关配置。",
    "crumbs": [
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Quarto</span>"
    ]
  },
  {
    "objectID": "chapters/ch28_quarto.html#quarto-基础",
    "href": "chapters/ch28_quarto.html#quarto-基础",
    "title": "29  Quarto",
    "section": "29.2 Quarto 基础",
    "text": "29.2 Quarto 基础\nQuarto 文件包含三种重要的内容类型：\n\n可选的 YAML 头部信息，使用 --- 包围；\nR 代码块，用三重反引号（```）包围；\n普通文本，格式与markdown基本一致，比如 # 表示标题，_文本_ 表示斜体。\n\n下图展示 RStudio 中的 .qmd 文档，可以点击代码块顶部的Run按钮（形似播放键）来运行每个代码块，或按快捷键 Ctrl + Shift + Enter。RStudio 会执行代码并将结果嵌入代码块下方显示。\n\n如果不希望在文档中直接看到图表和输出，而想使用 RStudio 的 Console 和 Plots 面板，可以点击Render旁的齿轮图标，切换为“Chunk Output in Console”模式，如下图所示。\n\n要生成包含所有文本、代码和结果的完整报告，可点击Render按钮，或使用快捷键 Ctrl + Shift + K。也可以通过代码方式执行，使报告在 Viewer 面板中显示，同时生成一个 HTML 文件：\nquarto::quarto_render(\"diamond-sizes.qmd\")\n在渲染过程中，Quarto 首先将 .qmd 文件交给 knitr，它会执行所有代码块，并生成包含代码及其输出的 Markdown 文件。随后该 Markdown 文件会由 pandoc 处理，生成最终格式的文件（如 PDF、Word、HTML）。这个流程如下图所示。\n\n通过以下路径即可创建 .qmd 文件： File &gt; New File &gt; Quarto Document…\nRStudio 会启动一个向导，帮助我们预先填充一些常用内容，并提示如何使用 Quarto 的核心功能。",
    "crumbs": [
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Quarto</span>"
    ]
  },
  {
    "objectID": "chapters/ch28_quarto.html#可视化编辑器",
    "href": "chapters/ch28_quarto.html#可视化编辑器",
    "title": "29  Quarto",
    "section": "29.3 可视化编辑器",
    "text": "29.3 可视化编辑器\n在底层，Quarto 文档（.qmd 文件）中的正文使用 Markdown 编写。\n在可视化编辑器中，除了使用菜单栏按钮插入图像、表格、引用等，也可使用通用快捷键 ⌘ + /（Mac）或 Ctrl + /（Windows/Linux）插入。如果位于某行开头，只输入 / 也可以触发快捷方式。\n\n虽然可视化编辑器会以格式化方式展示内容，但底层仍以纯 Markdown 存储。可视化编辑器与源代码编辑器之间能够随时切换，从而方便查看和编辑内容。",
    "crumbs": [
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Quarto</span>"
    ]
  },
  {
    "objectID": "chapters/ch28_quarto.html#源代码编辑器",
    "href": "chapters/ch28_quarto.html#源代码编辑器",
    "title": "29  Quarto",
    "section": "29.4 源代码编辑器",
    "text": "29.4 源代码编辑器\n使用源代码编辑器编辑 Quarto 文档需要掌握markdown语法，下面简单展示部分格式。\n## Text formatting\n\n*italic* **bold** ~~strikeout~~ `code`\n\nsuperscript^2^ subscript~2~\n\n[underline]{.underline} [small caps]{.smallcaps}\n\n## Headings\n\n# 1st Level Header\n\n## 2nd Level Header\n\n### 3rd Level Header\n\n## Lists\n\n-   Bulleted list item 1\n\n-   Item 2\n\n    -   Item 2a\n\n    -   Item 2b\n\n1.  Numbered list item 1\n\n2.  Item 2.\n    The numbers are incremented automatically in the output.\n\n## Links and images\n\n&lt;http://example.com&gt;\n\n[linked phrase](http://example.com)\n\n![optional caption text](quarto.png){fig-alt=\"Quarto logo and the word quarto spelled in small case letters\"}\n\n## Tables\n\n| First Header | Second Header |\n|--------------|---------------|\n| Content Cell | Content Cell  |\n| Content Cell | Content Cell  |",
    "crumbs": [
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Quarto</span>"
    ]
  },
  {
    "objectID": "chapters/ch28_quarto.html#代码块",
    "href": "chapters/ch28_quarto.html#代码块",
    "title": "29  Quarto",
    "section": "29.5 代码块",
    "text": "29.5 代码块\n在 Quarto 文档中插入一个代码块可以通过以下三种方式完成：\n\n使用快捷键：Cmd + Option + I（Mac） / Ctrl + Alt + I（Windows/Linux）\n点击编辑器工具栏中的 “Insert” 按钮图标\n手动输入代码块分隔符，比如```{r}\n\n代码块本身还有一个新快捷键：Cmd/Ctrl + Shift + Enter，可一次运行整个代码块。\n以下小节介绍代码块的头部结构：以 ```{r} 开始，后续添加代码块标签和多个块选项，每项单独占一行，前缀为 #|。\n\n\n29.5.1 块标签\n代码块可以指定一个可选的标签，例如：\n```{r}\n#| label: simple-addition\n1 + 1\n```\n输出：\n#&gt; [1] 2\n标签有三个好处：\n\n能通过 RStudio 编辑器左下角的代码导航器快速跳转至特定块。\n便于后续引用。\n可构建缓存依赖关系。\n\n标签应简短且具描述性，不能含空格，建议使用连字符 - 分隔单词（不推荐使用下划线 _）。\n有一个特殊标签setup。当处于笔记本模式时，名为 setup 的代码块将在其它代码运行前被自动执行。\n此外，块标签必须唯一，不可重复。\n\n\n\n29.5.2 块选项\n可通过在代码块开头指定选项，对代码块输出进行控制。knitr 提供了近 60 个选项，可参考完整列表：https://yihui.org/knitr/options。\n以下是最常用的一些选项：\n\neval: false —— 不运行代码。适用于展示示例代码，或临时屏蔽一大段代码而不逐行注释。\ninclude: false —— 运行代码，但不显示代码和结果。适合用于初始化设置代码。\necho: false —— 不显示代码，但保留结果。适用于隐藏底层 R 代码。\nmessage: false / warning: false —— 不显示消息或警告信息。\nresults: hide —— 隐藏文本输出；\nfig-show: hide —— 隐藏图形输出。\nerror: true —— 即使代码报错也继续渲染。\n\n这些选项以 #| 前缀写在代码块头部，例如：\n```{r}\n#| label: simple-multiplication\n#| eval: false\n2 * 2\n```\n\n\n\n29.5.3 全局选项\n随着 knitr 使用的深入，可能默认的块选项不再符合需求，那么就需要在文档层面进行全局设置。在 YAML 区域中通过 execute: 字段设置默认块选项。\n例如，想要不显示代码，只展示结果，可以设置：\ntitle: \"My report\"\nexecute:\n  echo: false\n由于 Quarto 是多语言设计，并非所有 knitr 选项都可放在 execute 下（部分选项仅适用于 knitr，不适用于其他执行引擎如 Jupyter）。但可以使用 knitr和opts_chunk 设置 knitr 专属的全局选项。\n例如要将注释符设置为 #&gt;，并将代码与输出紧密排列，可设置：\ntitle: \"Tutorial\"\nknitr:\n  opts_chunk:\n    comment: \"#&gt;\"\n    collapse: true\n\n\n\n29.5.4 内联代码\n除了代码块，还可使用内联语法将 R 代码嵌入 Quarto 文本中。",
    "crumbs": [
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Quarto</span>"
    ]
  },
  {
    "objectID": "chapters/ch28_quarto.html#图形",
    "href": "chapters/ch28_quarto.html#图形",
    "title": "29  Quarto",
    "section": "29.6 图形",
    "text": "29.6 图形\nQuarto 文档中的图形可以直接嵌入，也可以由代码块生成。\n要从外部文件嵌入图像，可以在 RStudio 的可视化编辑器中使用 “Insert” 菜单并选择 Figure / Image。\nQuarto 中主要有五个选项用于调节图形尺寸：\n\nfig-width\nfig-height\nfig-asp\nout-width\nout-height\n\n图像尺寸调整比较复杂，因为图像有两个尺寸：R 生成图形的实际大小，以及输出文档中显示的大小。\n下面通过各种需求来介绍选项。\n图形保持一致的宽度会更美观，故而可以在默认设置中设定：\nfig-width: 6    # 图形宽度 6 英寸  \nfig-asp: 0.618  # 黄金比例  \n用 out-width 控制图形的输出宽度，建议设为输出文档正文宽度的一个百分比，比如：\nout-width: \"70%\"\nfig-align: center\n如果要在一行中放多个图形，可以使用 layout-ncol 设置为 2（两图并排）、3（三图并排）等等。这相当于自动为每张图设置了 out-width 为 50%、33% 等。\n如果图中文字太小，则调整 fig-width，且通常需要通过试错来确定最佳宽高比。\n若要在文字中穿插代码和图形，你可以使用 fig-show: hold，从而能让图形在代码之后展示。\n要为图添加标题，可以使用 fig-cap。添加标题后，图像会变成“浮动图形”（可编号、可引用）。",
    "crumbs": [
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Quarto</span>"
    ]
  },
  {
    "objectID": "chapters/ch28_quarto.html#表格",
    "href": "chapters/ch28_quarto.html#表格",
    "title": "29  Quarto",
    "section": "29.7 表格",
    "text": "29.7 表格\n生成表格同样有两种方式。一种是直接通过 “Insert Table” 菜单插入的 Markdown 表格；另一种是由代码块生成表格。\n默认情况下，Quarto 会以类似控制台输出的形式打印数据框和矩阵：\nmtcars[1:5, ]\n#&gt;                    mpg cyl disp  hp drat    wt  qsec vs am gear carb\n#&gt; Mazda RX4         21.0   6  160 110 3.90 2.620 16.46  0  1    4    4\n#&gt; Mazda RX4 Wag     21.0   6  160 110 3.90 2.875 17.02  0  1    4    4\n#&gt; Datsun 710        22.8   4  108  93 3.85 2.320 18.61  1  1    4    1\n#&gt; Hornet 4 Drive    21.4   6  258 110 3.08 3.215 19.44  1  0    3    1\n#&gt; Hornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2\n如果希望数据的展示方式更有条理，可以使用 knitr::kable() 函数。例如此代码会生成下面的表格：\nknitr::kable(mtcars[1:5, ])\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmpg\ncyl\ndisp\nhp\ndrat\nwt\nqsec\nvs\nam\ngear\ncarb\n\n\n\n\n\nMazda RX4\n21.0\n6\n160\n110\n3.90\n2.620\n16.46\n0\n1\n4\n4\n\n\nMazda RX4 Wag\n21.0\n6\n160\n110\n3.90\n2.875\n17.02\n0\n1\n4\n4\n\n\nDatsun 710\n22.8\n4\n108\n93\n3.85\n2.320\n18.61\n1\n1\n4\n1\n\n\nHornet 4 Drive\n21.4\n6\n258\n110\n3.08\n3.215\n19.44\n1\n0\n3\n1\n\n\nHornet Sportabout\n18.7\n8\n360\n175\n3.15\n3.440\n17.02\n0\n0\n3\n2",
    "crumbs": [
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Quarto</span>"
    ]
  },
  {
    "objectID": "chapters/ch28_quarto.html#缓存",
    "href": "chapters/ch28_quarto.html#缓存",
    "title": "29  Quarto",
    "section": "29.8 缓存",
    "text": "29.8 缓存\n一般来说，每次渲染文档时都会从一个完全干净的环境重新开始。这从可重复性的角度出发固然很好，能确保所有重要的计算都写已进代码。然而，如果一些计算耗时特别长，再次渲染会很痛苦。\n解决方案是设置 cache: true，从文档层次（也就是全局）缓存所有计算的结果：\n---\ntitle: \"My Document\"\nexecute: \n  cache: true\n---\n也可以在代码块级别启用缓存，仅缓存某个特定代码块中的计算结果：\n\n# 一段耗时计算的代码\n\n不过，默认情况下缓存只基于代码自身，不包含依赖项。例如以下代码中，processed_data 代码块依赖于 raw-data 代码块：\n```{r}\n#| label: raw-data\n#| cache: true\nrawdata &lt;- readr::read_csv(\"a_very_large_file.csv\")\n\n```{{r}}\n#| label: processed_data\n#| cache: true\nprocessed_data &lt;- rawdata |&gt; \n  filter(!is.na(import_var)) |&gt; \n  mutate(new_variable = complicated_transformation(x, y, z))\n```\n此时若缓存作为附属的 processed_data ，则意味着如果 raw-data 的调用发生变化，它并不会重新运行。可以使用 dependson 选项来避免这个问题，该选项应包含一个字符向量，列出该缓存块依赖的所有代码块。knitr 检测到被依赖代码发生变化时，会更新缓存块的结果。\n```{r}\n#| label: processed-data\n#| cache: true\n#| dependson: \"raw-data\"\nprocessed_data &lt;- rawdata |&gt; \n  filter(!is.na(import_var)) |&gt; \n  mutate(new_variable = complicated_transformation(x, y, z))\n```\n若要让缓存随着外部文件的变化而更新，可以使用 cache.extra 。该选项接受任意 R 表达式，只要其结果变化，缓存就会失效。\n另外还有一个实用函数file.mtime()，它会返回文件的最后修改时间。例如：\n```{{r}}\n#| label: raw-data\n#| cache: true\n#| cache.extra: !expr file.mtime(\"a_very_large_file.csv\")\nrawdata &lt;- readr::read_csv(\"a_very_large_file.csv\")\n```\n建议定期清理所有缓存，使用：\nknitr::clean_cache()",
    "crumbs": [
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Quarto</span>"
    ]
  },
  {
    "objectID": "chapters/ch28_quarto.html#修bug",
    "href": "chapters/ch28_quarto.html#修bug",
    "title": "29  Quarto",
    "section": "29.9 修bug",
    "text": "29.9 修bug\nQuarto 文档并非交互式环境，调试过程可能不太直观。但究其错误根源，主要分为文档结构问题与内嵌代码问题两类。\n一个典型的结构性错误是代码块标签重复，极易发生在复制粘贴时。解决方法：检查报错信息或文档源码，找到重复的标签名，手动将其修改为全局唯一的名称，例如将重复的 unnamed-chunk-1 分别改为 data-loading 和 plot-generation。\n当错误由 R 代码本身引起时，核心的排查思路是在交互式环境中复现问题。方法：首先重启 R 会话，创造一个干净的环境，然后运行 Ctrl + Alt + R 执行文档中的所有代码块。一旦成功复现，就可以像处理普通 R 脚本一样，使用 print()、browser() 或调试器进行逐行交互式诊断。\n如果无法在交互环境中复现，则证明两者环境存在差异，必须进行系统排查。系统性解决方法：首先，通过包含 getwd() 的代码块确认 Quarto 的工作目录，并在交互会话中通过 setwd() 切换到相同路径。其次，在问题代码块顶部设置 error: true，确保渲染不会因报错而中断；然后，在代码块内部关键步骤后，插入 str()、print() 或 ls() 等语句，将变量内容、数据结构乃至当前环境中的所有对象名称打印输出，通过对比两份输出结果，即可发现隐藏的变量差异或依赖缺失。",
    "crumbs": [
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Quarto</span>"
    ]
  },
  {
    "objectID": "chapters/ch28_quarto.html#yaml",
    "href": "chapters/ch28_quarto.html#yaml",
    "title": "29  Quarto",
    "section": "29.10 YAML",
    "text": "29.10 YAML\nQuarto 使用 YAML 调整输出的细节。\n\n\n29.10.1 自包含\nHTML 文档通常依赖诸多外部资源（例如图片、CSS 样式表、JavaScript 等），默认情况下这些文件会被放在与 .qmd 文件同目录下的 _files 文件夹中，并非自包含。\n若要将报告通过电子邮件发送出去，便常常需要自包含的 HTML 文件，其中嵌入所有依赖文件。可以如下设置：\nformat:\n  html:\n    embed-resources: true\n生成的文件是自包含的，在浏览器中显示时不需要任何外部文件或网络连接。",
    "crumbs": [
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Quarto</span>"
    ]
  },
  {
    "objectID": "chapters/ch28_quarto.html#参数",
    "href": "chapters/ch28_quarto.html#参数",
    "title": "29  Quarto",
    "section": "29.11 参数",
    "text": "29.11 参数\nQuarto 文档中可以包含一个或多个动态参数，格式为：\n\n在YAML中使用 params 字段对参数进行指定。例如，下面这个例子使用参数 my_class 来决定要展示哪一类汽车：\n---\nformat: html\nparams:\n  my_class: \"suv\"\n---\n另外也可以通过 !expr 来动态执行任意 R 表达式。例如用于设置日期/时间参数：\nparams:\n  start: !expr lubridate::ymd(\"2015-01-01\")\n  snapshot: !expr lubridate::ymd_hms(\"2015-01-01 12:30:00\")",
    "crumbs": [
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Quarto</span>"
    ]
  },
  {
    "objectID": "chapters/ch28_quarto.html#参考文献与引用",
    "href": "chapters/ch28_quarto.html#参考文献与引用",
    "title": "29  Quarto",
    "section": "29.12 参考文献与引用",
    "text": "29.12 参考文献与引用\n要使用可视化编辑器添加引用，选择Insert &gt; Citation。可以从多种来源插入引用：\n\nDOI（文献数字对象唯一标识符）\nZotero 个人或团队图书馆\nCrossref、DataCite 或 PubMed 的搜索结果\n本地 .bib 文献数据库文件\n\n在源码编辑器中，使用引用标识符进行引用。其格式为 '@' + 文献条目ID，再放到方括号中。例如：\n多个引用用分号分隔\nBlah blah [@smith04; @doe99].\n\n可以在方括号内添加任意注释\nBlah blah [see @doe99, pp. 33-35; also @smith04, ch. 1].\n\n去掉方括号以创建正文引用\n@smith04 says blah, or @smith04 [p. 33] says blah.\n\n在引用前加 `-` 省略作者名\nSmith says blah [-@smith04].\n在渲染文档时，Quarto 会构建参考文献并附加到文档末尾，但不会自动添加章节标题，因此要手动添加。",
    "crumbs": [
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Quarto</span>"
    ]
  },
  {
    "objectID": "chapters/ch28_quarto.html#工作流程",
    "href": "chapters/ch28_quarto.html#工作流程",
    "title": "29  Quarto",
    "section": "29.13 工作流程",
    "text": "29.13 工作流程\nQuarto 的一大优势是紧密整合了代码与文本，既可开发代码，又能记录思路。\nQuarto的记录应追求三大目标：\n\n追溯完整过程。系统性地记录每个操作步骤及其背后的决策逻辑，能够确保重要信息不会遗失。\n显性思考。实时记录分析思路和反思过程，形成严谨的分析逻辑链。从而提升最终报告的质量，减少后期文档整理的工作量。\n团队协作。数据分析本质上是协作性工作，记录信息利于团队知识传递及后续工作延续。\n\n作者对于工作记录的方法论如下：\n\n给记录文件取一个有描述性且易懂的文件名，且开头一段应当简要说明分析目的。\n使用 YAML 头部的 date 字段记录你开始工作的日期时，使用 ISO8601 格式（YYYY-MM-DD），避免歧义：\ndate: 2016-08-23\n如果在某个分析思路上投入了大量时间，但最终发现是死胡同，也不要删除！以后重新回顾这个分析时，它可以作为前车之鉴。\n最好在 R 之外进行数据录入。若不得不记录少量数据，应使用 tibble::tribble() 明确列出。\n如果发现数据文件中有错误，绝不直接修改原始文件， 而应该写代码去修正该值，并添加注释。\n结束每天的工作前，执行完整渲染验证文档可运行性，同时记得清除缓存。\n如果希望代码在未来依然可复现（比如一年后能再次运行），就需要追踪代码使用的包的版本。可使用 renv 将包保存在项目目录中。也可以代码块中运行 sessionInfo()，便能知道当前使用了哪些包。\n建议将自己的每个笔记本放在独立的项目中，并制定标准化命名方案。",
    "crumbs": [
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Quarto</span>"
    ]
  },
  {
    "objectID": "chapters/ch29_quarto_formats.html",
    "href": "chapters/ch29_quarto_formats.html",
    "title": "30  Quarto Formats",
    "section": "",
    "text": "30.1 引言\n上节提到 Quarto 可用来生成 HTML 文档。本章将简要介绍用 Quarto 输出其他类型的文件。\n设置文档输出的方式有两种：",
    "crumbs": [
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>Quarto Formats</span>"
    ]
  },
  {
    "objectID": "chapters/ch29_quarto_formats.html#引言",
    "href": "chapters/ch29_quarto_formats.html#引言",
    "title": "30  Quarto Formats",
    "section": "",
    "text": "修改 YAML 头部：\n\ntitle: \"Diamond sizes\"\nformat: html\n\n手动调用 quarto::quarto_render()：\n\nquarto::quarto_render(\"diamond-sizes.qmd\", output_format = \"docx\")\n\noutput_format 参数可以接受一个值列表，故而能同时输出多种类型文件：\nquarto::quarto_render(\"diamond-sizes.qmd\", output_format = c(\"docx\", \"pdf\"))",
    "crumbs": [
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>Quarto Formats</span>"
    ]
  },
  {
    "objectID": "chapters/ch29_quarto_formats.html#输出选项",
    "href": "chapters/ch29_quarto_formats.html#输出选项",
    "title": "30  Quarto Formats",
    "section": "30.2 输出选项",
    "text": "30.2 输出选项\nQuarto 给输出文件提供了多种选项。以下网址集合全部可选选项：https://quarto.org/docs/output-formats/all-formats.html。\n要修改默认选项，需使用扩展格式字段。例如，如果想渲染一个带浮动目录的 HTML，可以这样写：\nformat:\n  html:\n    toc: true\n    toc_float: true\n还可以通过提供格式列表来渲染成多个输出：\nformat:\n  html:\n    toc: true\n    toc_float: true\n  pdf: default\n  docx: default\n\npdf: default表示不修改任何默认选项",
    "crumbs": [
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>Quarto Formats</span>"
    ]
  },
  {
    "objectID": "chapters/ch29_quarto_formats.html#文档",
    "href": "chapters/ch29_quarto_formats.html#文档",
    "title": "30  Quarto Formats",
    "section": "30.3 文档",
    "text": "30.3 文档\n除了HTML，Quarto还可以生成其他类型的文档。\n\npdf：通过 LaTeX（一个开源文档排版系统）生成 PDF。\ndocx：生成 Microsoft Word（.docx）文档。\nodt：生成 OpenDocument Text（.odt）文档。\nrtf：生成富文本格式（.rtf）文档。\ngfm：生成 GitHub 风格的 Markdown（.md）文档。\nipynb：生成 Jupyter Notebook（.ipynb）。\n\n在生成共享文档时，应隐藏源代码，仅保留执行结果。可在文档 YAML 中更改全局选项：\nexecute:\n  echo: false",
    "crumbs": [
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>Quarto Formats</span>"
    ]
  },
  {
    "objectID": "chapters/ch29_quarto_formats.html#演示文稿",
    "href": "chapters/ch29_quarto_formats.html#演示文稿",
    "title": "30  Quarto Formats",
    "section": "30.4 演示文稿",
    "text": "30.4 演示文稿\nQuarto 还能用来制作演示文稿。虽然它在视觉控制方面不如 Keynote 或 PowerPoint 灵活，但能自动插入 R 代码的结果，节省大量时间。\n演示文稿的工作方式是将内容分割成幻灯片，每遇到一个二级标题（##）时，就会开始一个新的幻灯片。而一级标题（#）表示一个新章节的开始，会生成一个章节标题幻灯片，且默认在页面居中。\nQuarto 支持多种演示文稿格式，包括：\n\nrevealjs —— 使用 revealjs 制作的 HTML 演示文稿\npptx —— PowerPoint 演示文稿\nbeamer —— 使用 LaTeX Beamer 制作的 PDF 演示文稿",
    "crumbs": [
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>Quarto Formats</span>"
    ]
  },
  {
    "objectID": "chapters/ch29_quarto_formats.html#交互性",
    "href": "chapters/ch29_quarto_formats.html#交互性",
    "title": "30  Quarto Formats",
    "section": "30.5 交互性",
    "text": "30.5 交互性\n使用 Quarto 创建的 HTML 文档也可以包含交互组件。下面介绍两种在 Quarto 文档中加入交互的方式：htmlwidgets 和 Shiny。\n\n\n30.5.1 htmlwidgets\nHTML本身就是交互式格式，而通过htmlwidgets（一种能生成交互式HTML可视化的R函数包）可以充分利用这一特性。例如下面这串代码生成一个leaflet交互式地图，但只能在网页端查看并操作。\nlibrary(leaflet)\nleaflet() |&gt;\n  setView(174.764, -36.877, zoom = 16) |&gt; \n  addTiles() |&gt;\n  addMarkers(174.764, -36.877, popup = \"Maungawhau\") \n有很多 R 包都可以提供 htmlwidgets，包括：\n\ndygraphs —— 交互式时间序列可视化\nDT —— 交互式表格\nthreejs —— 交互式 3D 图形\nDiagrammeR —— 图表（如流程图、简单的节点-链接图）\n\n\n\n\n30.5.2 Shiny\nhtmlwidgets 所有交互都发生在浏览器中，与 R 无关。而 Shiny 与之相对，是一个能让我们用 R 代码创建交互的包。\n要在 Quarto 文档中调用 Shiny 代码，可以在 YAML 头部添加：\ntitle: \"Shiny Web App\"\nformat: html\nserver: shiny\n然后，使用输入函数向文档添加交互组件：\nlibrary(shiny)\n\ntextInput(\"name\", \"What is your name?\")\nnumericInput(\"age\", \"How old are you?\", NA, min = 0, max = 150)\n这些代码会生成两个输入框：\n\n可以用 input$name 和 input$age 引用输入值，当输入值更改时相关代码也会自动更新。\nShiny 的交互发生在服务器端，故而相关应用需要 Shiny 服务器才能在线运行。\n想进一步学习 Shiny，推荐阅读 《Mastering Shiny》。",
    "crumbs": [
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>Quarto Formats</span>"
    ]
  },
  {
    "objectID": "chapters/ch29_quarto_formats.html#网站与图书",
    "href": "chapters/ch29_quarto_formats.html#网站与图书",
    "title": "30  Quarto Formats",
    "section": "30.6 网站与图书",
    "text": "30.6 网站与图书\n通过简单配置，Quarto 可生成完整网站或图书：\n\n将所有 .qmd 文件置于同一目录，index.qmd 会自动成为首页\n创建 _quarto.yml 文件并指定项目类型为website或book。\n\n网站示例：\nproject:\n  type: website\n\nwebsite:\n  title: \"A website on color scales\"\n  navbar:\n    left:\n      - href: index.qmd\n        text: Home\n      - href: viridis-colors.qmd\n        text: Viridis colors\n      - href: terrain-colors.qmd\n        text: Terrain colors\n图书示例：\nproject:\n  type: book\n\nbook:\n  title: \"A book on color scales\"\n  author: \"Jane Coloriste\"\n  chapters:\n    - index.qmd\n    - intro.qmd\n    - viridis-colors.qmd\n    - terrain-colors.qmd\n\nformat:\n  html:\n    theme: cosmo\n  pdf: default\n  epub: default\n\n参考链接：\n\nQuarto 网站开发\nQuarto 图书制作",
    "crumbs": [
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>Quarto Formats</span>"
    ]
  },
  {
    "objectID": "chapters/ch29_quarto_formats.html#其他输出格式",
    "href": "chapters/ch29_quarto_formats.html#其他输出格式",
    "title": "30  Quarto Formats",
    "section": "30.7 其他输出格式",
    "text": "30.7 其他输出格式\nQuarto 还能以各种格式输出，以下再列两例：\n\n参考模板库，输出期刊文章。\n使用format: ipynb输出 Jupyter Notebook。\n\n参考Quarto格式集合网站可了解更多输出格式。",
    "crumbs": [
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>Quarto Formats</span>"
    ]
  },
  {
    "objectID": "afterword.html",
    "href": "afterword.html",
    "title": "31  后记",
    "section": "",
    "text": "后记\n本次笔记合集到此告一段落。能有机会在此与诸君分享这本笔记合集，实属荣幸。相较于前一合集《生信数据技能》，我在编写此合集的过程中又有了新的感悟。\n首先，知识是学不完的。生信的蓝海之大，常令我嗟叹。R 语言在生信中不过沧海一粟，然而光是这一粟，便足以让人日复一日在文档与资料里沉湎。翻阅资料的时间越长，就越能体会到一个朴素的事实：我这一生所能触及的，只可能是自身的边界，而决非生信的尽头。\n其次，人脑是很健忘的。重要的资料翻看多少遍都不为过。不过若只是单纯过了眼瘾，手不跟着眼实操，就会“朝闻道，夕忘道”。有时我翻看自己从前写的推文，偶尔也会生出一种陌生的恍惚感。知识常看常新，代码越练越精！\n最后，生命总是向上的。去年动笔写《生信数据技能》的笔记时，满篇代码如天书般横亘眼前，越读越觉得高深莫测。而今再度翻阅，略加思索便能理解大半。至于这本《R for Data Science》，对于目前的我其中仍有一些部分并不算熟练，但这又何妨？未来的我，必将在今日的基石上拾级而进。\n此笔记合集虽经反复斟酌，然限于学识与视野，疏漏与偏误在所难免。恳请读者不吝指正，共同探讨、互相砥砺，愿与诸君在思维的激荡中，共同精进。\n丁加\n2025年12月16日于湘雅",
    "crumbs": [
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>后记</span>"
    ]
  }
]