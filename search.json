[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "R4DS Notes from DJ",
    "section": "",
    "text": "序\n恭喜您发现这片蓝海！此站点用于呈现本人研读《R for Data Science》期间所整理的系统化笔记。\n《R for Data Science》由 Hadley Wickham 主编，被视为当代 R 语言生态的关键基石。全书以 tidyverse 为方法论核心，将数据导入、整理、转换、可视化、建模与再现性文档组织为一个一致而清晰的分析工作流，使读者能够在统一的语义框架下理解“以数据为中心”的思维方式。其价值不仅在于介绍函数与语法，更在于重塑 R 社区对数据科学流程的整体认识，是近年来影响力最为深远的 R 语言教材之一。\n自 2025 年 3 月起，本人围绕全书内容持续整理读书笔记。除基础操作外，还重点聚焦 tidy 数据结构、管道化表达、图形语法及工作流设计原则等核心机制，并结合个人实践对部分概念进行再组织与适度延展。近半年的积累逐渐构成一个较为完整的知识框架，故将其汇整于此，与诸君共享。\n若文中有理解偏差或论述不尽之处，诚挚期待指正。若这些笔记能为正在学习 tidyverse 或构建 R 数据分析流程的读者带来参考价值，则深感荣幸！\n本书在线阅读网址：https://r4ds.hadley.nz/\n开场白结束，祝各位阅读愉快。\n丁加\n2025年11月22日于湘雅",
    "crumbs": [
      "序"
    ]
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "导入",
    "section": "",
    "text": "上图展示了完成一个数据科学项目的基本模型，也是全书的核心思想。\n\n导入。读取文本文件、数据库或 API 数据，是整个流程的起点。\n规整。通过结构化与清洗，使数据具有一致的语义形式，便于后续分析。\n转换。包含筛选、创建变量、变换尺度、生成汇总统计等操作。\n可视化。以图形揭示模式、验证假设，使数据关系得以直观呈现。\n建模。在可视化基础上进行定量推断，是进一步精确回答问题的工具。\n交流。通过图表、模型与文档向他人清晰传递数据分析的过程与结论。\n\n上述六个步骤均依赖稳定的编程能力。数据科学并非要求精湛的程序设计，但掌握必要的编码技能可显著提升分析效率，使工作流更具连贯性与可复用性。",
    "crumbs": [
      "导入"
    ]
  },
  {
    "objectID": "chapters/ch1_data_visualization.html",
    "href": "chapters/ch1_data_visualization.html",
    "title": "1  数据可视化",
    "section": "",
    "text": "1.1 引言\nggplot2是所有R可视化工具中最优雅的之一。 本章需载入下列R包：",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>数据可视化</span>"
    ]
  },
  {
    "objectID": "chapters/ch1_data_visualization.html#引言",
    "href": "chapters/ch1_data_visualization.html#引言",
    "title": "1  数据可视化",
    "section": "",
    "text": "library(tidyverse)\nlibrary(palmerpenguins) # 包含示例数据\nlibrary(ggthemes) # 提供色盲调色板",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>数据可视化</span>"
    ]
  },
  {
    "objectID": "chapters/ch1_data_visualization.html#绘制企鹅数据图",
    "href": "chapters/ch1_data_visualization.html#绘制企鹅数据图",
    "title": "1  数据可视化",
    "section": "1.2 绘制企鹅数据图",
    "text": "1.2 绘制企鹅数据图\n本书开篇甩出一系列问题：企鹅的脚蹼长度和体重之间的关系是怎样的？是线性？非线性？这种关系是否因企鹅的种类而异？与地理位置有关吗？针对这些问题，我们将进行可视化操作以回答。\n首先了解一些术语：\n\n变量(variable)是可以测量的数量、质量等属性。\n值(value)是测量变量时变量的状态。变量的值可能会因测量而异。\n观测值(observation)是在相近条件下进行的一组测量 （通常就是在同一时间对同一对象的所有值）。一个观测值将包含多个值，每个值都与不同的变量相关联。\n表格数据(tabular data)是一组值，每个值都与一个变量和一个观测值相关联。\n\n接下来输入palmerpenguins::penguins以打开示例数据的数据框。注意到并未显示出所有变量。\n&gt; palmerpenguins::penguins\n# A tibble: 344 × 8\n   species island  bill_length_mm bill_depth_mm\n   &lt;fct&gt;   &lt;fct&gt;            &lt;dbl&gt;         &lt;dbl&gt;\n 1 Adelie  Torger…           39.1          18.7\n 2 Adelie  Torger…           39.5          17.4\n 3 Adelie  Torger…           40.3          18  \n 4 Adelie  Torger…           NA            NA  \n 5 Adelie  Torger…           36.7          19.3\n 6 Adelie  Torger…           39.3          20.6\n 7 Adelie  Torger…           38.9          17.8\n 8 Adelie  Torger…           39.2          19.6\n 9 Adelie  Torger…           34.1          18.1\n10 Adelie  Torger…           42            20.2\n# ℹ 334 more rows\n# ℹ 4 more variables: flipper_length_mm &lt;int&gt;,\n#   body_mass_g &lt;int&gt;, sex &lt;fct&gt;, year &lt;int&gt;\n# ℹ Use `print(n = ...)` to see more rows\n也可使用glimpse(penguins)，查看所有变量和每个变量的前几个观测值的替代视图。\n&gt; glimpse(penguins)\nRows: 344\nColumns: 8\n$ species           &lt;fct&gt; Adelie, Adelie, Adelie, Adelie, Ad…\n$ island            &lt;fct&gt; Torgersen, Torgersen, Torgersen, T…\n$ bill_length_mm    &lt;dbl&gt; 39.1, 39.5, 40.3, NA, 36.7, 39.3, …\n$ bill_depth_mm     &lt;dbl&gt; 18.7, 17.4, 18.0, NA, 19.3, 20.6, …\n$ flipper_length_mm &lt;int&gt; 181, 186, 195, NA, 193, 190, 181, …\n$ body_mass_g       &lt;int&gt; 3750, 3800, 3250, NA, 3450, 3650, …\n$ sex               &lt;fct&gt; male, female, female, NA, female, …\n$ year              &lt;int&gt; 2007, 2007, 2007, 2007, 2007, 2007…\n此外还可运行view(penguins)，打开交互式数据查看器。\n我们的目标是用可视化图显示这些企鹅的脚蹼长度和体重、种类之间的关系。所以接下来开始介绍ggplot()这一核心函数。\n第一个参数是data，表示我们绘图所需的数据集，此处即ggplot(data = penguins)。但由于我们还没有声明具体绘图方式，因此现在画布尚为空白。\n第二个参数为mapping，通常与美学函数(aes)成对出现。aes()函数中x和y的参数要分别映射到 x 轴和 y 轴，在本例中，我们将脚蹼长度映射到x，将体重映射到y，ggplot2 会在参数中查找映射的变量。故而输入：\nggplot(\n  data = penguins,\n  mapping = aes(x = flipper_length_mm, y = body_mass_g)\n)\n\n现在画布上出现了坐标轴，脚蹼长度为 x 轴，体重为 y 轴。但是还没有图线，因为尚未设置绘图模板。\n下面定义绘图模板geom (geometric object)。不同类型的图以不同类型的基础几何图形组成。 - 条形图使用条形 geom_bar() - 折线图使用线geom_line() - 箱线图使用箱型 geom_boxplot() - 散点图使用点geom_point()\n注意geom函数与ggplot函数是并列的，二者以加号相连。不妨尝试画一个散点图：\nggplot(\n  data = penguins,\n  mapping = aes(x = flipper_length_mm, y = body_mass_g)\n) +\n  geom_point()\n#&gt; Warning: Removed 2 rows containing missing values or values outside the scale range\n#&gt; (`geom_point()`).\n\n我们注意到生成图像时有警告信息，是因为数据中有两只企鹅缺少体重或脚蹼长度值，ggplot2 无法在图上表示缺失值。ggplot2 贯彻不让任何缺失值静默地缺失这一理念。\n接下来，我们需要将物种这一变量纳入图中，可以通过使用不同颜色的点来表示不同物种。使用color=&lt;变量&gt;参数即可实现。绘制完成后可以发现ggplot2帮我们附上了一个图例。\nggplot(\n  data = penguins,\n  mapping = aes(x = flipper_length_mm, y = body_mass_g, color = species)\n) +\n  geom_point()\n\n为了让图像更直观，最好再添加一个图层，以显示体重和脚蹼长度之间关系的平滑曲线，用geom_smooth()函数表示。由于平滑曲线是一个新的几何对象，与散点图并存，故而函数geom_smooth(method = \"lm\")也应独立，用加号连接。其中lm表示线性模型(linear model)。\nggplot(\n  data = penguins,\n  mapping = aes(x = flipper_length_mm, y = body_mass_g, color = species)\n) +\n  geom_point() +\n  geom_smooth(method = \"lm\")\n\n此代码输出的图包含三条线，分别表示三个物种，看起来颇为凌乱。如果曲线的对象是整个数据，就能做到只输出一条总线，那么如何设置？\n实际上，ggplot函数里的参数是影响所有geom的，而各个geom函数里的参数则各自为营而互不干扰。因此可让颜色只在散点图中作为物种区分，从而不影响平滑曲线：\nggplot(\n  data = penguins,\n  mapping = aes(x = flipper_length_mm, y = body_mass_g)\n) +\n  geom_point(mapping = aes(color = species)) +\n  geom_smooth(method = \"lm\")\n\n现在得到的图像美观多了，但仍有进步空间。考虑到色盲人士，只用颜色区分物种貌似不太妥当，可以将点改为多种形状来区分。使用shape=&lt;变量&gt;参数即可实现。同样也会附上图例。\nggplot(\n  data = penguins,\n  mapping = aes(x = flipper_length_mm, y = body_mass_g)\n) +\n  geom_point(mapping = aes(color = species, shape = species)) +\n  geom_smooth(method = \"lm\")\n\n最后一步，我们可以添加一个用于解释图像的函数labs()，从而为图添加标题和副标题，并以与美学映射匹配的方式添加坐标轴文字，并定义图例的标签等等。此外，还可以使用 ggthemes 包中的函数改进调色板，进一步照顾色盲人士。\n&gt; ggplot(\n+     data = penguins,\n+     mapping = aes(x = flipper_length_mm, y = body_mass_g)\n+ ) +\n+     geom_point(aes(color = species, shape = species)) +\n+     geom_smooth(method = \"lm\") +\n+     labs(\n+         title = \"Body mass and flipper length\",\n+         subtitle = \"Dimensions for Adelie, Chinstrap, and Gentoo Penguins\",\n+         x = \"Flipper length (mm)\", y = \"Body mass (g)\",\n+         color = \"Species\", shape = \"Species\"\n+     ) +\n+     scale_color_colorblind()",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>数据可视化</span>"
    ]
  },
  {
    "objectID": "chapters/ch1_data_visualization.html#调用-ggplot2",
    "href": "chapters/ch1_data_visualization.html#调用-ggplot2",
    "title": "1  数据可视化",
    "section": "1.3 调用 ggplot2",
    "text": "1.3 调用 ggplot2\nggplot函数的核心用法已阐述完毕，下面将以更简洁的形式呈现，省略参数名称（data和mapping）。所以上一节中的某一命令可简化为：\nggplot(\n  data = penguins,\n  mapping = aes(x = flipper_length_mm, y = body_mass_g)\n) +\n  geom_point()\n当然也可以借助R的管道进行简化：\npenguins |&gt; \n  ggplot(aes(x = flipper_length_mm, y = body_mass_g)) + \n  geom_point()",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>数据可视化</span>"
    ]
  },
  {
    "objectID": "chapters/ch1_data_visualization.html#分布可视化",
    "href": "chapters/ch1_data_visualization.html#分布可视化",
    "title": "1  数据可视化",
    "section": "1.4 分布可视化",
    "text": "1.4 分布可视化\n如果要将企鹅的种类等类别变量(categorical variable)可视化，可使用条形图geom_bar()如下：\nggplot(penguins, aes(x = species)) +\n  geom_bar()\n\n如此便可生成对应条形图，但是排列是无序的。借助fct_infreq()函数按照每个类别的数量进行降序排序：\nggplot(penguins, aes(x = fct_infreq(species))) +\n  geom_bar()\n\n如果要对企鹅的体重等数值变量(numerical variable)进行可视化，可使用直方图geom_histogram()：\nggplot(penguins, aes(x = body_mass_g)) +\n  geom_histogram(binwidth = 200)\n\n指令中的 binwidth 参数设置直方图中的间隔宽度。在应用直方图时，需要尝试多种 binwidth参数，以找到最顺眼且最合理的样式。比如设置为20时显然过于密集了：\n\n数值分布还可以用密度图geom_density()进行可视化，相当于连接直方图各个长条的顶点绘制的曲线：\nggplot(penguins, aes(x = body_mass_g)) +\n  geom_density()\n#&gt; Warning: Removed 2 rows containing non-finite outside the scale range\n#&gt; (`stat_density()`).",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>数据可视化</span>"
    ]
  },
  {
    "objectID": "chapters/ch1_data_visualization.html#关系可视化",
    "href": "chapters/ch1_data_visualization.html#关系可视化",
    "title": "1  数据可视化",
    "section": "1.5 关系可视化",
    "text": "1.5 关系可视化\n为了可视化变量间的关系，我们需要将至少两个变量映射到美学。下面将介绍用于可视化两个或多个变量之间关系的常用绘图。\n\n1.5.1 数值变量和类别变量\n要对数值变量和类别变量进行关系可视化，可使用箱线图geom_boxplot()。\n箱线图由以下部分组成：\n\n一个表示数据中间半部分范围的框，该距离称为四分位距 （IQR），从分布的第 25 个百分位数延伸到第 75 个百分位数。框中间有一条横线，显示分布的中位数，即第 50 个百分位数。这三条线体现数据的分散程度，以及分布是关于中位数对称还是偏向于某一侧。\n超过框的任一边缘 IQR 1.5 倍的观测值的数据会以点的形式单独标注，称为outliers。\n从框的两端延伸并到达最远的非异常值点的线称作须线(whisker)。\n\n\n现在使用箱线图将企鹅体重与物种的关系可视化：\nggplot(penguins, aes(x = species, y = body_mass_g)) +\n  geom_boxplot()\n\n关系的可视化也可以使用密度图，不过较前文有所进阶。使用linewidth参数自定义线条粗细：\n&gt; ggplot(penguins, aes(x = body_mass_g, color = species)) +\n+ geom_density(linewidth = 0.75)\n\n可以用fill参数为密度曲线填充颜色，同时使用alpha参数设置填充的透明度：\nggplot(penguins, aes(x = body_mass_g, color = species, fill = species)) +\n  geom_density(alpha = 0.5)\n\n\n\n1.5.2 两个类别变量\n使用堆叠条形图来可视化两个类别变量的关系。例如要处理物种和岛名的关系：\nggplot(penguins, aes(x = island, fill = species)) +\n  geom_bar()\n\n像这样直接生成的条形图反映了绝对数值，但是对于各岛企鹅物种占比的对比不太直观。此时可设置参数position=\"fill\"的方式让相对频率更直观：\nggplot(penguins, aes(x = island, fill = species)) +\n  geom_bar(position = \"fill\")\n\n\n\n1.5.3 两个数值变量\n书中指出，散点图是可视化两个数值变量之间关系的最常用图。\nggplot(penguins, aes(x = flipper_length_mm, y = body_mass_g)) +\n  geom_point()\n\n\n\n1.5.4 三个或更多变量\n针对三个变量，我们可以加入更多美学要素以表示变量，比如用点的颜色表示物种，用点的形状表示岛屿：\nggplot(penguins, aes(x = flipper_length_mm, y = body_mass_g)) +\n  geom_point(aes(color = species, shape = island))\n\n但是这样做的缺陷非常明显，图片十分杂乱，若变量更多则更糟糕。故而有另一种方案：分面。即使用多个子图以表示类别变量。\n要进行分面，则使用facet_wrap()函数，参数为符号~后加上需要分面的类别变量名称。例如将岛屿进行分面：\nggplot(penguins, aes(x = flipper_length_mm, y = body_mass_g)) +\n  geom_point(aes(color = species, shape = species)) +\n  facet_wrap(~island)",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>数据可视化</span>"
    ]
  },
  {
    "objectID": "chapters/ch1_data_visualization.html#保存绘图",
    "href": "chapters/ch1_data_visualization.html#保存绘图",
    "title": "1  数据可视化",
    "section": "1.6 保存绘图",
    "text": "1.6 保存绘图\n使用ggsave()函数保存最近一次所画图像，参数file可设置图像名称及路径。比如：\nggplot(penguins, aes(x = flipper_length_mm, y = body_mass_g)) +\n  geom_point()\nggsave(filename = \"penguin-plot.png\")",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>数据可视化</span>"
    ]
  },
  {
    "objectID": "chapters/ch2_workflow_basics.html",
    "href": "chapters/ch2_workflow_basics.html",
    "title": "2  工作流基础",
    "section": "",
    "text": "2.1 代码基础\n在进一步学习本书前，必须确保具备运行 R 代码的基础能力，并且掌握RStudio中的核心功能。\n数学计算：\n创建新对象：\n创建向量：\n向量的基本算术会应用于其中每个元素：\n创建对象所用的赋值语句都是object &lt;- value格式。R中有一个常用快捷键Alt+-，用于迅速打出&lt;-符号，且前后各自带一个空格。",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>工作流基础</span>"
    ]
  },
  {
    "objectID": "chapters/ch2_workflow_basics.html#代码基础",
    "href": "chapters/ch2_workflow_basics.html#代码基础",
    "title": "2  工作流基础",
    "section": "",
    "text": "&gt; 1 / 200 * 30\n[1] 0.15\n\n&gt; (59 + 73 + 2) / 3\n[1] 44.66667\n\n&gt; sin(pi / 2)\n[1] 1\n\n&gt; x &lt;- 5\n\n&gt; primes &lt;- c(2, 3, 5, 7, 11, 13)\n\n&gt; primes * 2\n[1]  4  6 10 14 22 26",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>工作流基础</span>"
    ]
  },
  {
    "objectID": "chapters/ch2_workflow_basics.html#注释",
    "href": "chapters/ch2_workflow_basics.html#注释",
    "title": "2  工作流基础",
    "section": "2.2 注释",
    "text": "2.2 注释\n#符号后接的内容表示注释，R将忽略该内容。在编写的代码趋于复杂时，务必养成加上注释的习惯，可为日后弄清代码含义节省大量时间。",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>工作流基础</span>"
    ]
  },
  {
    "objectID": "chapters/ch2_workflow_basics.html#对象的名称",
    "href": "chapters/ch2_workflow_basics.html#对象的名称",
    "title": "2  工作流基础",
    "section": "2.3 对象的名称",
    "text": "2.3 对象的名称\n一般来说，对象名称有三种命名方式。\n\n蛇型（单词间用下划线连接，如how_to_name）\n驼峰型（单词首字母大写，如HowToName）\n点分隔型（如how.to.name）\n\n将对象命名后，要再次调用则不用将名称全部输入。输入前几个字母后，按Tab键可以快捷选择对应前缀的对象；或者使用Ctrl+↑快捷键选择过去输入的指令。\nRStudio右上角的environment会显示当前已命名的对象。",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>工作流基础</span>"
    ]
  },
  {
    "objectID": "chapters/ch2_workflow_basics.html#调用函数",
    "href": "chapters/ch2_workflow_basics.html#调用函数",
    "title": "2  工作流基础",
    "section": "2.4 调用函数",
    "text": "2.4 调用函数\nR中调用函数的方式为f_name(arg1 = val1, arg2 = val2, ...)。\n例如使用seq()函数生成规则的数值序列。\n&gt; seq(1,5)\n[1] 1 2 3 4 5\nRStudio有一个很贴心的辅助功能，当输入一个上引号或左括号时能自动生成另一半，防止出错。",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>工作流基础</span>"
    ]
  },
  {
    "objectID": "chapters/ch3_data_transformation.html",
    "href": "chapters/ch3_data_transformation.html",
    "title": "3  数据处理",
    "section": "",
    "text": "3.1 引言\n可视化是数据分析时的重要手段，但前提是数据格式严格符合要求。因此针对格式不当的数据需要进行一些处理。\n本章主要介绍使用dplyr包对数据进行处理，dplyr同样归属于tidyverse。另外为了举例，还需加载含有纽约航班信息的包：\nnycflights13包中包含 2013 年从纽约市出发的所有 336,776 个航班，记录在nycflights13::flights里：\nflights表格是一个 “Tibble”，这是一种特殊的数据框。Tibble 和普通数据框之间最重要的区别是其显示方式，tibble专为大型数据集而设计，因此它们仅显示前几行，并且仅显示适配屏幕大小的列。如果使用 RStudio操作则更方便，会打开一个可交互、可滚动、可筛选的视图。\n注意到表头下方用尖括号标注了数据类型，大致有：\n本章将学习5个dplyr核心函数，用于数据处理，大致为：\n上述5个函数的工作方式大致相同，有以下共通点：\n下面对其一一阐述。",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>数据处理</span>"
    ]
  },
  {
    "objectID": "chapters/ch3_data_transformation.html#引言",
    "href": "chapters/ch3_data_transformation.html#引言",
    "title": "3  数据处理",
    "section": "",
    "text": "&gt; library(nycflights13)\n&gt; library(tidyverse)\n\nflights\n#&gt; # A tibble: 336,776 × 19\n#&gt;    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n#&gt; 1  2013     1     1      517            515         2      830            819\n#&gt; 2  2013     1     1      533            529         4      850            830\n#&gt; 3  2013     1     1      542            540         2      923            850\n#&gt; 4  2013     1     1      544            545        -1     1004           1022\n#&gt; 5  2013     1     1      554            600        -6      812            837\n#&gt; 6  2013     1     1      554            558        -4      740            728\n#&gt; # ℹ 336,770 more rows\n#&gt; # ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, …\n\n\n\nint 表示整数型变量。\ndbl表示双精度浮点数型变量，或称实数。\nchr 表示字符向量，或称字符串。\nlgl表示逻辑型变量，是一个仅包括 TRUE 和 FALSE 的向量。\nfctr 表示因子，R用其来表示具有固定数目的值的分类变量。\ndate 表示日期型变量。\ndttm 表示日期时间(日期+时间)型变量。\n\n\n\n按值筛选(filter())。\n对行进行重新排序(arrange())\n按名称选取变量(select())\n使用现有变量的函数创建新变量(mutate())\n将多个值总结为一个摘要统计量(summarize())\n\n\n\n第一个参数是数据框。\n后续参数使用不带引号的变量名称，描述针对数据框进行的操作。\n输出结果是一个新数据框。",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>数据处理</span>"
    ]
  },
  {
    "objectID": "chapters/ch3_data_transformation.html#行",
    "href": "chapters/ch3_data_transformation.html#行",
    "title": "3  数据处理",
    "section": "3.2 行",
    "text": "3.2 行\n操作数据行的最主要函数为：\n\nfilter()：用于筛选数据。改变的是行的种类，但不改变顺序；\narrange()：用于排序。改变的是行的顺序，但不改变行的内容。\n\n这两个函数仅作用于行，不会修改列。\n此外，还有 distinct() 函数，用于查找具有唯一值的行。与 arrange() 和 filter() 不同，distinct() 在筛选行的同时也可以选择性地修改列。\n\n3.2.1 filter()\nfilter() 函数用于根据列中的值保留数据框中的某些行。第一个参数是数据框，后续的参数是判断各行是否保留的条件。例如，以下代码能找出所有起飞延误超过 120 分钟的航班：\nflights |&gt; \n  filter(dep_delay &gt; 120)\n除了 &gt;（大于）之外，还可以使用以下比较运算符：\n\n&gt;=（大于等于）\n&lt;（小于）\n&lt;=（小于等于）\n==（等于）\n!=（不等于）\n\n还可以使用 & 或 , 表示“与”（同时满足多个条件），使用 | 表示“或”（满足任一条件）。例如要筛选出所有在1月1日起飞的航班：\nflights |&gt; \n  filter(month == 1 & day == 1)\n结合 | 与 == 时，有一个简洁的写法：%in%，用于匹配某个变量是否属于一组值之一。比如筛选1月或2月的航班：\nflights |&gt; \n  filter(month %in% c(1, 2))\n在运行 filter() 时，dplyr 会返回一个新的数据框，而不会修改原始的 flights 数据集。要保存筛选结果，使用赋值操作符 &lt;-：\njan1 &lt;- flights |&gt; \n  filter(month == 1 & day == 1)\n初学者常犯以下两点错误\n\n用 = 判断相等，而非 ==。此时 filter() 会报错提醒：\n\nflights |&gt; \n  filter(month = 1)\n#&gt; Error in `filter()`:\n#&gt; ! We detected a named input.\n#&gt; ℹ This usually means that you've used `=` instead of `==`.\n#&gt; ℹ Did you mean `month == 1`?\n\n像口语一样写“或”条件：\n\nflights |&gt; \n  filter(month == 1 | 2)\n正确写法是 month == 1 | month == 2。\n\n\n3.2.2 arrange()\narrange() 根据某些列的值对行进行排序。它接收数据框及一组列名或表达式。如果提供多个列名，则后面的列用于在前面的列值相同时进一步排序。\n例如，下面的代码按年、月、日和起飞时间排序，得到的是最早起飞的航班排在前面：\nflights |&gt; \n  arrange(year, month, day, dep_time)\n若希望按某列的降序排列，可以用 desc()：\n# 按照起飞延误时间从大到小排序\nflights |&gt; \n  arrange(desc(dep_delay))\n\n\n3.2.3 distinct()\ndistinct() 查找数据框中所有唯一（去重）行。在实际使用中，更常用于获取某些列组合的唯一值，且会保留每组中第一次出现的那一行。\n# 删除重复行\nflights |&gt; \n  distinct()\n# 获取所有起点和终点的组合\nflights |&gt; \n  distinct(origin, dest)\n如需保留其他列信息，可添加 .keep_all = TRUE参数。\n若希望获取各组合的出现次数，使用 count() 更为合适，并可通过 sort = TRUE 参数按频数降序排列：\nflights |&gt;\n  count(origin, dest, sort = TRUE)",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>数据处理</span>"
    ]
  },
  {
    "objectID": "chapters/ch3_data_transformation.html#列操作",
    "href": "chapters/ch3_data_transformation.html#列操作",
    "title": "3  数据处理",
    "section": "3.3 列操作",
    "text": "3.3 列操作\n在数据处理过程中，有四个 dplyr 中的重要函数可用于操作列而不改变行的结构：\n\nmutate()：基于现有列创建新列。\nselect()：筛选保留指定列。\nrename()：重命名列。\nrelocate()：重新排列列的位置。\n\n\n3.3.1 mutate()\nmutate() 用于在数据框中添加新列，这些新列的值是通过现有列计算得出的。例如：\nflights |&gt; \n  mutate(\n    gain = dep_delay - arr_delay,\n    speed = distance / air_time * 60\n  )\n此代码添加了两个新列 gain（“起飞延误”减去“到达延误”）和 speed（飞行速度，单位：mph）。默认情况下，新列会添加在数据框的最右侧。为了便于观察，可以使用 .before 参数控制其插入的位置：\nflights |&gt; \n  mutate(\n    gain = dep_delay - arr_delay,\n    speed = distance / air_time * 60,\n    .before = 1\n  )\n#&gt; # A tibble: 336,776 × 21\n#&gt;    gain speed  year month   day dep_time sched_dep_time dep_delay arr_time\n#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;\n#&gt; 1    -9  370.  2013     1     1      517            515         2      830\n#&gt; 2   -16  374.  2013     1     1      533            529         4      850\n#&gt; 3   -31  408.  2013     1     1      542            540         2      923\n#&gt; 4    17  517.  2013     1     1      544            545        -1     1004\n#&gt; 5    19  394.  2013     1     1      554            600        -6      812\n#&gt; 6   -16  288.  2013     1     1      554            558        -4      740\n#&gt; # ℹ 336,770 more rows\n#&gt; # ℹ 12 more variables: sched_arr_time &lt;int&gt;, arr_delay &lt;dbl&gt;, …\n此外，.after 可用于将新列插入某一指定列之后。.keep 参数可控制哪些列被保留。例如仅保留参与 mutate() 计算的列：\nflights |&gt; \n  mutate(\n    gain = dep_delay - arr_delay,\n    hours = air_time / 60,\n    gain_per_hour = gain / hours,\n    .keep = \"used\"\n  )\n\n注意：若未将结果赋值回对象（如 flights 或新对象），新生成的变量仅在当前操作中可见，不会永久保存。\n\n\n\n\n3.3.2 select()\n在处理包含大量变量的数据集时，select() 可用于快速提取需要研究的列。常见用法包括：\n# 指定列名\nselect(year, month, day)\n\n# 选择连续区间\nselect(year:day)\n\n# 排除某一列区间\nselect(!year:day)\n\n# 选择字符型列\nselect(where(is.character))\n还可使用辅助函数进行模式匹配：\n\nstarts_with(\"abc\")：匹配以 abc 开头的列名。\nends_with(\"xyz\")：匹配以 xyz 结尾的列名。\ncontains(\"ijk\")：包含 ijk 的列名。\nnum_range(\"x\", 1:3)：匹配 x1, x2, x3。\n\n此外，也可在 select() 中重命名列，但是只保留被选择的列，未被选中的列会被移除。\nflights |&gt; \n  select(tail_num = tailnum)\n\n\n3.3.3 rename()\n若只想重命名部分列而保留所有现有列，可使用 rename()：\nflights |&gt; \n  rename(tail_num = tailnum)\n相比 select()，rename() 不会改变列的数量，仅修改名称。\n若存在大量命名不规范的列名，可考虑使用 janitor::clean_names() 进行批量清洗。\n\n3.3.3.1 relocate()\nrelocate() 用于调整列的顺序，可以将某些更关键的列移动到前面：\nflights |&gt; \n  relocate(time_hour, air_time)\n#&gt; # A tibble: 336,776 × 19\n#&gt;   time_hour           air_time  year month   day dep_time sched_dep_time\n#&gt;   &lt;dttm&gt;                 &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;\n#&gt; 1 2013-01-01 05:00:00      227  2013     1     1      517            515\n#&gt; 2 2013-01-01 05:00:00      227  2013     1     1      533            529\n#&gt; 3 2013-01-01 05:00:00      160  2013     1     1      542            540\n#&gt; 4 2013-01-01 05:00:00      183  2013     1     1      544            545\n#&gt; 5 2013-01-01 06:00:00      116  2013     1     1      554            600\n#&gt; 6 2013-01-01 05:00:00      150  2013     1     1      554            558\n#&gt; # ℹ 336,770 more rows\n#&gt; # ℹ 12 more variables: dep_delay &lt;dbl&gt;, arr_time &lt;int&gt;, …\n.before 或 .after 精确定位：\nflights |&gt; \n  relocate(year:dep_time, .after = time_hour)\nflights |&gt; \n  relocate(starts_with(\"arr\"), .before = dep_time)",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>数据处理</span>"
    ]
  },
  {
    "objectID": "chapters/ch3_data_transformation.html#管道符",
    "href": "chapters/ch3_data_transformation.html#管道符",
    "title": "3  数据处理",
    "section": "3.4 管道符",
    "text": "3.4 管道符\n管道符提升代码的可读性、简洁性和逻辑性，避免嵌套调用。\n\n3.4.1 Base R 管道操作符 |&gt;\n自 R 4.1.0 起，R 语言原生支持管道符 |&gt;。其核心原理是“把前一步的结果作为后一个函数的第一个参数”。\n举例，找出飞往 IAH 的航班中速度最快的几架飞机：\nflights |&gt;\n  filter(dest == \"IAH\") |&gt;\n  mutate(speed = distance / air_time * 60) |&gt;\n  select(year:day, dep_time, carrier, flight, speed) |&gt;\n  arrange(desc(speed))\n等价于嵌套写法：\narrange(\n  select(\n    mutate(\n      filter(flights, dest == \"IAH\"),\n      speed = distance / air_time * 60\n    ),\n    year:day, dep_time, carrier, flight, speed\n  ),\n  desc(speed)\n)\n\n\n3.4.2 |&gt; 与 %&gt;% 的区别\n|&gt; 是 base R 提供的原生操作符，不依赖任何包。\n%&gt;% 来源于 magrittr 包（tidyverse 的一部分），功能更强。比如可使用.占位符传递非首参数。\n不过，如果只在 dplyr 和 ggplot2 语境下处理数据，|&gt; 通常已足够。",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>数据处理</span>"
    ]
  },
  {
    "objectID": "chapters/ch3_data_transformation.html#分组操作与汇总",
    "href": "chapters/ch3_data_transformation.html#分组操作与汇总",
    "title": "3  数据处理",
    "section": "3.5 分组操作与汇总",
    "text": "3.5 分组操作与汇总\n管道操作仅简化流程，但对某些任务，如“对每个月统计平均延误时间”，则需要借助分组与汇总函数。\n\n3.5.1 group_by()\n示例：按月份分组\nflights |&gt;\n  group_by(month)\n此时返回的 tibble 看似不变，但其实多了一个“分组结构”属性，后续函数如 summarize() 将以此分组为单位运算。\n\n\n3.5.2 summarize()\n用于计算每组的统计量，如平均数、个数、最大值等。\nflights |&gt;\n  group_by(month) |&gt;\n  summarize(\n    avg_delay = mean(dep_delay, na.rm = TRUE),\n    flight_count = n()\n  )\n\n\nna.rm = TRUE 用于忽略缺失值；\nn() 返回当前分组的行数（即航班数）；\n默认情况下 summarize() 会“剥离”最后一个分组变量。\n\n\n\n\n3.5.3 多重分组与 .groups 参数\n可同时按多个变量分组：\nflights |&gt;\n  group_by(year, month, day) |&gt;\n  summarize(avg_delay = mean(dep_delay, na.rm = TRUE))\n可通过 .groups 参数明确控制输出是否保留某层分组：\nsummarize(..., .groups = \"drop_last\")  # 保留上层分组\nsummarize(..., .groups = \"drop\")       # 全部取消分组\nsummarize(..., .groups = \"keep\")       # 保留所有分组\n\n\n3.5.4 ungroup()移除分组结构\n若后续不再需分组操作，需要使用 ungroup() 函数进行声明，避免出现意外。\ndaily_summary |&gt;\n  ungroup() |&gt;\n  summarize(total_flights = sum(n))\n\n\n3.5.5 slice_*() 系列函数：获取组内特定行\nslice_*() 系列函数常用于提取组内最值、样本等，结果保留原始列结构。\n\nslice_head(n = 1)：每组取最前一行\nslice_tail(n = 1)：每组取最后一行\nslice_max(order_by, n = 1)：每组取最大值\nslice_min(order_by, n = 1)：每组取最小值\nslice_sample(n = 1)：每组随机取一行\n\n例如，找出每个目的地到达延误最长的航班：\nflights |&gt;\n  group_by(dest) |&gt;\n  slice_max(arr_delay, n = 1) |&gt;\n  relocate(dest)\n默认行为中，若多个航班并列最大延误，则全部保留。若需限制为仅一行，可加 with_ties = FALSE。\n\n\n3.5.6 .by 参数\ndplyr 1.1.0 引入 .by 参数，提供了一种更简洁、局部化的分组操作语法。与传统 group_by() 不同，.by 仅在当前动词范围内生效，不影响后续操作的分组状态，适合一次性分组计算。\n基本用法如下例所示：\nflights |&gt; \n  summarize(\n    delay = mean(dep_delay, na.rm = TRUE), \n    n = n(),\n    .by = month\n  )\n可支持多变量分组：\nflights |&gt; \n  summarize(\n    delay = mean(dep_delay, na.rm = TRUE), \n    n = n(),\n    .by = c(origin, dest)\n  )\n.by参数特性总结如下：\n\n作用范围限于当前动词，运算结束即“自动取消分组”；\n可用于 summarize()、mutate()、filter() 等所有动词；\n避免了 .groups 警告信息，简化结果处理流程；\n写法更贴近函数式风格，便于封装与组合。\n\n以下是两种写法的对比：\n\n传统写法：\n\nflights |&gt; \n  group_by(month) |&gt; \n  summarize(delay = mean(dep_delay, na.rm = TRUE)) |&gt; \n  ungroup()\n\n.by 简化：\n\n``` r flights |&gt; summarize(delay = mean(dep_delay, na.rm = TRUE), .by = month)",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>数据处理</span>"
    ]
  },
  {
    "objectID": "chapters/ch4_workflow_code_style.html",
    "href": "chapters/ch4_workflow_code_style.html",
    "title": "4  工作流之代码格式",
    "section": "",
    "text": "4.1 命名规范\n代码的编写格式往往直接影响代码的可读性和维护性。对于编程新手，建议从一开始就养成规范的书写习惯，这不仅有利于团队协作，也能让自己在回顾旧代码时更加轻松。\n本章整理了 tidyverse 推荐的格式，并作为全书的统一准则。初期遵循规范可能略感繁琐，但通过持续练习，这些规范将逐步内化为自然习惯。\n可借助 styler 包自动格式化代码。\n装载后，在 RStudio 中使用快捷键 Ctrl + Shift + P 打开命令面板，输入 “styler” 即可快速查看 styler 提供的所有快捷方式。\n命名变量建议使用小写字母、数字与下划线 _，下划线用于分隔单词：\n变量名应具备描述性，长不是问题，总比晦涩的缩写更易理解。在命名一组相关变量时，推荐使用统一前缀而非后缀，以提升自动补全功能的效率：",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>工作流之代码格式</span>"
    ]
  },
  {
    "objectID": "chapters/ch4_workflow_code_style.html#命名规范",
    "href": "chapters/ch4_workflow_code_style.html#命名规范",
    "title": "4  工作流之代码格式",
    "section": "",
    "text": "# 推荐\nshort_flights &lt;- flights |&gt; filter(air_time &lt; 60)\n\n# 不推荐\nSHORTFLIGHTS &lt;- flights |&gt; filter(air_time &lt; 60)\n\ndep_time, dep_delay, dep_gate  # 推荐\ntime_dep, delay_dep, gate_dep  # 不推荐",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>工作流之代码格式</span>"
    ]
  },
  {
    "objectID": "chapters/ch4_workflow_code_style.html#空格",
    "href": "chapters/ch4_workflow_code_style.html#空格",
    "title": "4  工作流之代码格式",
    "section": "4.2 空格",
    "text": "4.2 空格\n运算符（如 +, -, == 等）两侧需保留空格，唯独幂运算符 ^ 可不加。赋值符号 &lt;- 左右也应空格分隔：\nz &lt;- (a + b)^2 / d\n函数调用中，括号内不加空格，逗号后需空格：\nmean(x, na.rm = TRUE)\nmutate() 等参数较多的函数，可通过空格对齐等号以提升可读性：\nflights |&gt; \n  mutate(\n    speed      = distance / air_time,\n    dep_hour   = dep_time %/% 100,\n    dep_minute = dep_time %%  100\n  )",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>工作流之代码格式</span>"
    ]
  },
  {
    "objectID": "chapters/ch4_workflow_code_style.html#管道符",
    "href": "chapters/ch4_workflow_code_style.html#管道符",
    "title": "4  工作流之代码格式",
    "section": "4.3 管道符",
    "text": "4.3 管道符\nRStuido中管道符快捷键为 Ctrl + Shift + M。\ntidyverse 推荐使用原生管道 |&gt;，符号前后各留一个空格。管道符通常置于行尾，方便续写。例如：\nflights |&gt;  \n  filter(!is.na(arr_delay), !is.na(tailnum)) |&gt; \n  count(dest)\n若函数（如 summarize()）包含命名参数，每个参数独立成行。而无命名参数（如 filter()）可根据行的长度决定是否换行。\n管道中各层缩进两格。若参数分行书写，则进一步缩进。闭括号 ) 建议单独成行。下方代码格式为例：\nflights |&gt;  \n  group_by(tailnum) |&gt; \n  summarize(\n    delay = mean(arr_delay, na.rm = TRUE),\n    n = n()\n  )\n尽管有些简单操作可一行完成，但建议从一开始就分层书写，为后续扩展留出余地：\n# 简洁但维护性差\ndf |&gt; mutate(y = x + 1)\n\n# 更推荐写法\ndf |&gt; \n  mutate(\n    y = x + 1\n  )\n若管道超过 10–15 行，建议引入中间变量，分阶段处理，尤其是在数据结构发生重大变化时（如 pivot, summarize）。",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>工作流之代码格式</span>"
    ]
  },
  {
    "objectID": "chapters/ch4_workflow_code_style.html#ggplot2-格式规范",
    "href": "chapters/ch4_workflow_code_style.html#ggplot2-格式规范",
    "title": "4  工作流之代码格式",
    "section": "4.4 ggplot2 格式规范",
    "text": "4.4 ggplot2 格式规范\nggplot2 中的图层添加使用 +，应置于行尾，格式上与管道 |&gt; 保持一致：\nflights |&gt; \n  group_by(month) |&gt; \n  summarize(delay = mean(arr_delay, na.rm = TRUE)) |&gt; \n  ggplot(aes(x = month, y = delay)) +\n  geom_point() +\n  geom_line()\n参数较多时建议换行并对齐，提升可读性：\nflights |&gt; \n  group_by(dest) |&gt; \n  summarize(\n    distance = mean(distance),\n    speed = mean(distance / air_time, na.rm = TRUE)\n  ) |&gt; \n  ggplot(aes(x = distance, y = speed)) +\n  geom_smooth(\n    method = \"loess\",\n    span = 0.5,\n    se = FALSE, \n    color = \"white\", \n    linewidth = 4\n  ) +\n  geom_point()\n需注意，+ 与 |&gt; 的格式有时无法完全统一，因为 ggplot2 比管道符出现得更早，故尚难以在设计上兼容。",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>工作流之代码格式</span>"
    ]
  },
  {
    "objectID": "chapters/ch4_workflow_code_style.html#分节注释",
    "href": "chapters/ch4_workflow_code_style.html#分节注释",
    "title": "4  工作流之代码格式",
    "section": "4.5 分节注释",
    "text": "4.5 分节注释\n在脚本较长时，可用注释划分逻辑区域，例如：\n# Load data --------------------------------------\n\n# Plot data --------------------------------------\nRStudio 支持导航栏跳转：使用 Ctrl + Shift + R 插入分节注释，并快速定位不同部分。",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>工作流之代码格式</span>"
    ]
  },
  {
    "objectID": "chapters/ch4_workflow_code_style.html#练手",
    "href": "chapters/ch4_workflow_code_style.html#练手",
    "title": "4  工作流之代码格式",
    "section": "4.6 练手",
    "text": "4.6 练手\n示例一：\n原始代码：\nflights|&gt;filter(dest==\"IAH\")|&gt;group_by(year,month,day)|&gt;summarize(n=n(),\ndelay=mean(arr_delay,na.rm=TRUE))|&gt;filter(n&gt;10)\n规范格式：\nflights |&gt; \n  filter(dest == \"IAH\") |&gt; \n  group_by(year, month, day) |&gt; \n  summarize(\n    n = n(),\n    delay = mean(arr_delay, na.rm = TRUE)\n  ) |&gt; \n  filter(n &gt; 10)\n示例二：\n原始代码：\nflights|&gt;filter(carrier==\"UA\",dest%in%c(\"IAH\",\"HOU\"),sched_dep_time&gt;\n0900,sched_arr_time&lt;2000)|&gt;group_by(flight)|&gt;summarize(delay=mean(\narr_delay,na.rm=TRUE),cancelled=sum(is.na(arr_delay)),n=n())|&gt;filter(n&gt;10)\n规范格式：\nflights |&gt; \n  filter(\n    carrier == \"UA\",\n    dest %in% c(\"IAH\", \"HOU\"),\n    sched_dep_time &gt;  0900,\n    sched_arr_time &lt; 2000\n  ) |&gt; \n  group_by(flight) |&gt; \n  summarize(\n    delay = mean(arr_delay, na.rm = TRUE),\n    cancelled = sum(is.na(arr_delay)),\n    n = n()\n  ) |&gt; \n  filter(n &gt; 10)",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>工作流之代码格式</span>"
    ]
  },
  {
    "objectID": "chapters/ch5_data_tidying.html",
    "href": "chapters/ch5_data_tidying.html",
    "title": "5  数据整洁化",
    "section": "",
    "text": "5.1 引言\n数据可视化和建模都要求数据处于“整洁”格式（tidy format）。虽然无法控制获取数据的原始结构，但可通过数据整理将其转换为整洁结构。\n本章展示：\ntidyr 是 tidyverse 的核心之一，故我们须先载入tidyverse。",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>数据整洁化</span>"
    ]
  },
  {
    "objectID": "chapters/ch5_data_tidying.html#引言",
    "href": "chapters/ch5_data_tidying.html#引言",
    "title": "5  数据整洁化",
    "section": "",
    "text": "整洁数据的定义与原则；\n如何使用 tidyr 包中的函数进行数据整洁化；\n如何识别和处理缺失值。\n\n\nlibrary(tidyverse)",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>数据整洁化</span>"
    ]
  },
  {
    "objectID": "chapters/ch5_data_tidying.html#整洁数据",
    "href": "chapters/ch5_data_tidying.html#整洁数据",
    "title": "5  数据整洁化",
    "section": "5.2 整洁数据",
    "text": "5.2 整洁数据\n整洁数据具有以下三个核心特征：\n\n每个变量成一列；\n每个观测值成一行；\n每个观测单位成一个表。\n\ntable1\n#&gt; # A tibble: 6 × 4\n#&gt;   country      year  cases population\n#&gt;   &lt;chr&gt;       &lt;dbl&gt;  &lt;dbl&gt;      &lt;dbl&gt;\n#&gt; 1 Afghanistan  1999    745   19987071\n#&gt; 2 Afghanistan  2000   2666   20595360\n#&gt; 3 Brazil       1999  37737  172006362\n#&gt; 4 Brazil       2000  80488  174504898\n#&gt; 5 China        1999 212258 1272915272\n#&gt; 6 China        2000 213766 1280428583\n在 table1 中，每行表示一个国家在某一年的观测，有 country, year, cases, population 四列，结构清晰，便于进一步处理和可视化。\n可以基于已有变量创建派生变量。例如：\n# 计算每万人中的发病率\ntable1 |&gt;\n  mutate(rate = cases / population * 10000)\n#&gt; # A tibble: 6 × 5\n#&gt;   country      year  cases population  rate\n#&gt;   &lt;chr&gt;       &lt;dbl&gt;  &lt;dbl&gt;      &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1 Afghanistan  1999    745   19987071 0.373\n#&gt; 2 Afghanistan  2000   2666   20595360 1.29 \n#&gt; 3 Brazil       1999  37737  172006362 2.19 \n#&gt; 4 Brazil       2000  80488  174504898 4.61 \n#&gt; 5 China        1999 212258 1272915272 1.67 \n#&gt; 6 China        2000 213766 1280428583 1.67\n\n# 计算每年病例数\ntable1 |&gt; \n  group_by(year) |&gt; \n  summarize(total_cases = sum(cases))\n#&gt; # A tibble: 2 × 2\n#&gt;    year total_cases\n#&gt;   &lt;dbl&gt;       &lt;dbl&gt;\n#&gt; 1  1999      250740\n#&gt; 2  2000      296920\n可视化如下：\n# 可视化\nggplot(table1, aes(x = year, y = cases)) +\n  geom_line(aes(group = country), color = \"grey50\") +\n  geom_point(aes(color = country, shape = country)) +\n  scale_x_continuous(breaks = c(1999, 2000)) # x-axis breaks at 1999 and 2000",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>数据整洁化</span>"
    ]
  },
  {
    "objectID": "chapters/ch5_data_tidying.html#pivot_long",
    "href": "chapters/ch5_data_tidying.html#pivot_long",
    "title": "5  数据整洁化",
    "section": "5.3 pivot_long()",
    "text": "5.3 pivot_long()\n虽然整洁数据貌似很好实现，但现实中的数据往往不符合整洁格式。两个常见原因：\n\n数据为录入/展示方便而设计（如宽格式）\n多数数据制作者未系统学习整洁数据的规范\n\n下面逐一介绍相关问题及解决方法。\n\n5.3.1 错误其一 | 变量作为列名\n下面这个名为 billboard 的数据集记录了 2000 年歌曲的公告牌排名：\nbillboard\n#&gt; # A tibble: 317 × 79\n#&gt;   artist       track               date.entered   wk1   wk2   wk3   wk4   wk5\n#&gt;   &lt;chr&gt;        &lt;chr&gt;               &lt;date&gt;       &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1 2 Pac        Baby Don't Cry (Ke… 2000-02-26      87    82    72    77    87\n#&gt; 2 2Ge+her      The Hardest Part O… 2000-09-02      91    87    92    NA    NA\n#&gt; 3 3 Doors Down Kryptonite          2000-04-08      81    70    68    67    66\n#&gt; 4 3 Doors Down Loser               2000-10-21      76    76    72    69    67\n#&gt; 5 504 Boyz     Wobble Wobble       2000-04-15      57    34    25    17    17\n#&gt; 6 98^0         Give Me Just One N… 2000-08-19      51    39    34    26    26\n#&gt; # ℹ 311 more rows\n#&gt; # ℹ 71 more variables: wk6 &lt;dbl&gt;, wk7 &lt;dbl&gt;, wk8 &lt;dbl&gt;, wk9 &lt;dbl&gt;, …\n表格宽度相当浮夸，因为制表者将不同星期这一变量作为列名，整整列出了76列星期（此处引用的表格仅展示wk1~wk5）。显然，星期数是一个变量，将其作为列名很不合理、很不整洁。\n使用 pivot_longer() 可进行处理，将星期这一变量进行转置：\nbillboard |&gt; \n  pivot_longer(\n    cols = starts_with(\"wk\"), \n    names_to = \"week\", \n    values_to = \"rank\"\n  )\n#&gt; # A tibble: 24,092 × 5\n#&gt;    artist track                   date.entered week   rank\n#&gt;    &lt;chr&gt;  &lt;chr&gt;                   &lt;date&gt;       &lt;chr&gt; &lt;dbl&gt;\n#&gt;  1 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk1      87\n#&gt;  2 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk2      82\n#&gt;  3 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk3      72\n#&gt;  4 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk4      77\n#&gt;  5 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk5      87\n#&gt;  6 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk6      94\n#&gt;  7 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk7      99\n#&gt;  8 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk8      NA\n#&gt;  9 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk9      NA\n#&gt; 10 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk10     NA\n#&gt; # ℹ 24,082 more rows\n参数解释：\n\ncols用于指定需要转置的列。除了starts_with(\"wk\")，也可写成!c(artist, track, date.entered)\nnames_to用于命名新产生的列，此处将该列命名为week\nvalues_to用于命名存储在原各个列下的变量分离后产生的新列，此处将该列命名为 rank\n\n需注意，week和rank都需要加上引号，因为这是正在创建的新变量。\n初步处理完毕，不知道你有没有发现一个问题：如果原表的某个歌曲还未到wk76就已经跌出榜单而观测值为空白，那么转置后岂不是会产生若干只含有NA的行？这显然仍需改进。\n方法很简单，只需在pivot_longer()中加上一个参数：values_drop_na = TRUE，即可删去只含NA的行。\n将转置后表格命名为 billboard_longer 并进行可视化如下图所示：\n\n\n\n5.3.2 pivot_long() 的运作原理\n通过上一节的例子能看到pivot函数的奇妙之处，让人不禁好奇其原理如何。接下来以另一个数据框为例进行展示。\n假设有 3 名患者，id 分别是 A 、 B 和 C，现在对每位患者进行两次血压测量，以此创建 tibble 如下。\ndf &lt;- tribble(\n  ~id,  ~bp1, ~bp2,\n   \"A\",  100,  120,\n   \"B\",  140,  115,\n   \"C\",  120,  125\n)\n\ntribble()函数用于快捷创建tibble。\n\n接下来我们需要将其修整为新的数据框，含有三个变量：id、measurement、value，如下实现：\ndf |&gt; \n  pivot_longer(\n    cols = bp1:bp2,\n    names_to = \"measurement\",\n    values_to = \"value\"\n  )\n#&gt; # A tibble: 6 × 3\n#&gt;   id    measurement value\n#&gt;   &lt;chr&gt; &lt;chr&gt;       &lt;dbl&gt;\n#&gt; 1 A     bp1           100\n#&gt; 2 A     bp2           120\n#&gt; 3 B     bp1           140\n#&gt; 4 B     bp2           115\n#&gt; 5 C     bp1           120\n#&gt; 6 C     bp2           125\n下列组图形象地展现了这一转置过程：\n\n已经是变量的列需要重复，每个转置列重复一次。\n\n\n\n转置列的列名将成为新列中的值。对于原始数据集的每一行，这些值需要重复一次。\n\n\n单元格值也会成为新变量中的值，其名称由values_to定义，且逐行展开。\n\n\n\n5.3.3 错误其二 | 列名包含多个变量\n有时制表者为了图方便，列名可能一次性塞入了若干变量，导致要素过多而很不整洁。下面以一名为 who2 的整理了结核病的数据框为例。\nwho2\n#&gt; # A tibble: 7,240 × 58\n#&gt;   country      year sp_m_014 sp_m_1524 sp_m_2534 sp_m_3544 sp_m_4554\n#&gt;   &lt;chr&gt;       &lt;dbl&gt;    &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;\n#&gt; 1 Afghanistan  1980       NA        NA        NA        NA        NA\n#&gt; 2 Afghanistan  1981       NA        NA        NA        NA        NA\n#&gt; 3 Afghanistan  1982       NA        NA        NA        NA        NA\n#&gt; 4 Afghanistan  1983       NA        NA        NA        NA        NA\n#&gt; 5 Afghanistan  1984       NA        NA        NA        NA        NA\n#&gt; 6 Afghanistan  1985       NA        NA        NA        NA        NA\n#&gt; # ℹ 7,234 more rows\n#&gt; # ℹ 51 more variables: sp_m_5564 &lt;dbl&gt;, sp_m_65 &lt;dbl&gt;, sp_f_014 &lt;dbl&gt;, …\n这里解释一下制表者对第三列及后续列的命名思路：以下划线分为三个部分，第一部分表示诊断方法，第二部分表示性别，第三部分表示年龄范围。比如 sp_m_014 表示诊断方式sp，男性，0~14岁。\n可见若拆分后该表将包含六个变量：国家、年份、诊断方法、性别、年龄范围、患者数。\n下面依然使用pivot_long()函数进行修整：\nwho2 |&gt; \n  pivot_longer(\n    cols = !(country:year),\n    names_to = c(\"diagnosis\", \"gender\", \"age\"), \n    names_sep = \"_\",\n    values_to = \"count\"\n  )\n#&gt; # A tibble: 405,440 × 6\n#&gt;   country      year diagnosis gender age   count\n#&gt;   &lt;chr&gt;       &lt;dbl&gt; &lt;chr&gt;     &lt;chr&gt;  &lt;chr&gt; &lt;dbl&gt;\n#&gt; 1 Afghanistan  1980 sp        m      014      NA\n#&gt; 2 Afghanistan  1980 sp        m      1524     NA\n#&gt; 3 Afghanistan  1980 sp        m      2534     NA\n#&gt; 4 Afghanistan  1980 sp        m      3544     NA\n#&gt; 5 Afghanistan  1980 sp        m      4554     NA\n#&gt; 6 Afghanistan  1980 sp        m      5564     NA\n#&gt; # ℹ 405,434 more rows\n这里有新增参数names_sep，可将对应列以指定方式进行拆分。\n这个例子同时体现了同时命名多个新列的方式，即使用集合c()。\n\n\n5.3.4 错误其三 | 列名同时包含变量的名称与值\n还有更复杂的错误，即变量的名与值相混合。下面以一个名为 household 的记录家庭孩子数与姓名的数据框为例。\nhousehold\n#&gt; # A tibble: 5 × 5\n#&gt;   family dob_child1 dob_child2 name_child1 name_child2\n#&gt;    &lt;int&gt; &lt;date&gt;     &lt;date&gt;     &lt;chr&gt;       &lt;chr&gt;      \n#&gt; 1      1 1998-11-26 2000-01-29 Susan       Jose       \n#&gt; 2      2 1996-06-22 NA         Mark        &lt;NA&gt;       \n#&gt; 3      3 2002-07-11 2004-04-05 Sam         Seth       \n#&gt; 4      4 2004-10-10 2009-08-27 Craig       Khai       \n#&gt; 5      5 2000-12-05 2005-02-28 Parker      Gracie\n可以看出新的挑战是：列名包含两个变量名（dob、name）和另一变量的值（child，值为 1 或 2）。\n为解决这一问题，需要在给参数names_to提供的向量的首位加一个.value，这并不是某一个变量名称，而是表示使用转置列名的第一个组分作为输出中的变量名（既然要有组分之分，故还得加一个names_sep参数）。同时别忘了values_drop_na = TRUE参数，因为一个孩子的家庭会出现 NA行。\nhousehold |&gt; \n  pivot_longer(\n    cols = !family, \n    names_to = c(\".value\", \"child\"), \n    names_sep = \"_\", \n    values_drop_na = TRUE\n  )\n#&gt; # A tibble: 9 × 4\n#&gt;   family child  dob        name \n#&gt;    &lt;int&gt; &lt;chr&gt;  &lt;date&gt;     &lt;chr&gt;\n#&gt; 1      1 child1 1998-11-26 Susan\n#&gt; 2      1 child2 2000-01-29 Jose \n#&gt; 3      2 child1 1996-06-22 Mark \n#&gt; 4      3 child1 2002-07-11 Sam  \n#&gt; 5      3 child2 2004-04-05 Seth \n#&gt; 6      4 child1 2004-10-10 Craig\n#&gt; # ℹ 3 more rows",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>数据整洁化</span>"
    ]
  },
  {
    "objectID": "chapters/ch5_data_tidying.html#pivot_wider",
    "href": "chapters/ch5_data_tidying.html#pivot_wider",
    "title": "5  数据整洁化",
    "section": "5.4 pivot_wider()",
    "text": "5.4 pivot_wider()\n整个 5.3 节均使用pivot_long()函数对表格进行修整，整体变得更长。下面讨论将数据框变宽的修整情形，以包含医疗保险患者体检数据的数据框为例：\ncms_patient_experience\n#&gt; # A tibble: 500 × 5\n#&gt;   org_pac_id org_nm                     measure_cd   measure_title   prf_rate\n#&gt;   &lt;chr&gt;      &lt;chr&gt;                      &lt;chr&gt;        &lt;chr&gt;              &lt;dbl&gt;\n#&gt; 1 0446157747 USC CARE MEDICAL GROUP INC CAHPS_GRP_1  CAHPS for MIPS…       63\n#&gt; 2 0446157747 USC CARE MEDICAL GROUP INC CAHPS_GRP_2  CAHPS for MIPS…       87\n#&gt; 3 0446157747 USC CARE MEDICAL GROUP INC CAHPS_GRP_3  CAHPS for MIPS…       86\n#&gt; 4 0446157747 USC CARE MEDICAL GROUP INC CAHPS_GRP_5  CAHPS for MIPS…       57\n#&gt; 5 0446157747 USC CARE MEDICAL GROUP INC CAHPS_GRP_8  CAHPS for MIPS…       85\n#&gt; 6 0446157747 USC CARE MEDICAL GROUP INC CAHPS_GRP_12 CAHPS for MIPS…       24\n#&gt; # ℹ 494 more rows\n现在研究的重点是组织名称（org_nm），要确保每个组织名称仅有一行。\n此时使用pivot_wider()进行修正如下：\ncms_patient_experience |&gt; \n  pivot_wider(\n    id_cols = starts_with(\"org\"),\n    names_from = measure_cd,\n    values_from = prf_rate\n  )\n#&gt; # A tibble: 95 × 8\n#&gt;   org_pac_id org_nm           CAHPS_GRP_1 CAHPS_GRP_2 CAHPS_GRP_3 CAHPS_GRP_5\n#&gt;   &lt;chr&gt;      &lt;chr&gt;                  &lt;dbl&gt;       &lt;dbl&gt;       &lt;dbl&gt;       &lt;dbl&gt;\n#&gt; 1 0446157747 USC CARE MEDICA…          63          87          86          57\n#&gt; 2 0446162697 ASSOCIATION OF …          59          85          83          63\n#&gt; 3 0547164295 BEAVER MEDICAL …          49          NA          75          44\n#&gt; 4 0749333730 CAPE PHYSICIANS…          67          84          85          65\n#&gt; 5 0840104360 ALLIANCE PHYSIC…          66          87          87          64\n#&gt; 6 0840109864 REX HOSPITAL INC          73          87          84          67\n#&gt; # ℹ 89 more rows\n#&gt; # ℹ 2 more variables: CAHPS_GRP_8 &lt;dbl&gt;, CAHPS_GRP_12 &lt;dbl&gt;\n参数说明：\n\nid_cols表示保留的列的特征，此处仅保留以 org 开头的列，而排除了 measure_title 列\nnames_from表示新列名在原表中所在列的列名\nvalues_from表示新列中包含变量值在原表中所在列的列名\n\n\n5.4.1 pivot_wider() 的运作原理\n为了了解工作原理，再次从一个最简单的数据集开始。假设有两个 id 为 A 和 B 的两名患者，对患者 A 进行了 3 次血压测量，对患者 B 进行了 2 次：\ndf &lt;- tribble(\n  ~id, ~measurement, ~value,\n  \"A\",        \"bp1\",    100,\n  \"B\",        \"bp1\",    140,\n  \"B\",        \"bp2\",    115, \n  \"A\",        \"bp2\",    120,\n  \"A\",        \"bp3\",    105\n)\n下面从 value 列取值，从 measurement 列取列名：\ndf |&gt; \n  pivot_wider(\n    names_from = measurement,\n    values_from = value\n  )\n#&gt; # A tibble: 2 × 4\n#&gt;   id      bp1   bp2   bp3\n#&gt;   &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1 A       100   120   105\n#&gt; 2 B       140   115    NA\n首先，此过程需要弄清楚新的行和列中的内容。新列的名称将是 measurement 中的唯一值，可通过distinct()函数确认：\ndf |&gt; \n  distinct(measurement) |&gt; \n  pull()\n#&gt; [1] \"bp1\" \"bp2\" \"bp3\"\n默认情况下，输出的新行由所有未进入新列名或值的变量决定，这些行称为id_cols。如下：\ndf |&gt; \n  select(-measurement, -value) |&gt; \n  distinct()\n#&gt; # A tibble: 2 × 1\n#&gt;   id   \n#&gt;   &lt;chr&gt;\n#&gt; 1 A    \n#&gt; 2 B\n然后，pivot_wider()将这些结果组合起来，生成一个空数据框：\ndf |&gt; \n  select(-measurement, -value) |&gt; \n  distinct() |&gt; \n  mutate(x = NA, y = NA, z = NA)\n#&gt; # A tibble: 2 × 4\n#&gt;   id    x     y     z    \n#&gt;   &lt;chr&gt; &lt;lgl&gt; &lt;lgl&gt; &lt;lgl&gt;\n#&gt; 1 A     NA    NA    NA   \n#&gt; 2 B     NA    NA    NA\n最后它会使用输入中的数据填充所有NA值。在这种情况下，并非输出中的每个单元格在输入中都有相应的值，因为患者 B 没有第三次血压测量，因此该单元格仍然缺失。",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>数据整洁化</span>"
    ]
  },
  {
    "objectID": "chapters/ch6_workflow_scripts_projects.html",
    "href": "chapters/ch6_workflow_scripts_projects.html",
    "title": "6  脚本与项目",
    "section": "",
    "text": "6.0.0.0.1 6.1.1 运行代码\n本章介绍用于组织代码的两个基本要素：脚本、项目。\n##脚本\n当工作变得更加复杂时，只用控制台运行代码显得力不从心，此时可使用脚本。在 RStudio 中，点击“文件”菜单，选择新建 R 脚本即可出现空白脚本。此时共有四个窗口，如图所示。\n脚本编辑器是构建复杂ggplot图或长管道的最佳位置。\n快捷键如下：\n建议使用library(所需的包)作为脚本开头。这样，如果要共享代码，可以让他人知晓需要安装的软件包。但绝不应包含在共享脚本中加install.packages(\"包\")，不太厚道。",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>脚本与项目</span>"
    ]
  },
  {
    "objectID": "chapters/ch6_workflow_scripts_projects.html#项目",
    "href": "chapters/ch6_workflow_scripts_projects.html#项目",
    "title": "6  脚本与项目",
    "section": "6.1 项目",
    "text": "6.1 项目\n有时我们需要暂时退出 R，稍后再返回分析；有时我们需要将外部数据导入 R，处理后再对外反馈。\n要处理这两种情况，需要认清两个问题：\n\n真理的源头是什么？或者说什么文件能够永久记录我们曾做过的工作？\n我们所做的分析位于何处？\n\n\n6.1.1 真理的源头\n作为初学者，可以依靠当前 R 环境来保留在整个分析过程中创建的所有对象。但是为了更轻松地处理大型项目或与他人协作，真理的源头应该是 R 脚本。\n使用 R 脚本（和数据文件），我们才能重新创建环境。相反，仅使用当前环境，重新创建 R 脚本则要困难得多，要么必须从内存中重新键入大量代码（在此过程中不可避免地会犯错误），要么必须仔细挖掘 R 历史记录。\n为了保证让 R 脚本成为一切事实的根据，强烈建议设置不要在 RStudio 会话之间保留工作区。即做到两点：\n\n取消勾选RData into workspace\n设置Save workspace to .RData on exit:为Never\n\n如下图所示即可：\n\n或许这会带来一些短期的不便，因为现在重新启动 RStudio 时，它将不再记住上次运行的代码，所创建的对象或读取的数据集也将无影无踪。\n但是短期的不便可以省去长期的痛苦，它会迫使我们在代码中专注于所有重要的过程。\n书中在此推荐两个快捷键：\n\n按 Cmd/Ctrl + Shift + 0/F10 重新启动 R。\n按 Cmd/Ctrl + Shift + S 重新运行当前脚本。\n\n\nRStudio 服务器\n如果使用的是 RStudio 服务器，则默认情况下永远不会重新启动 R 会话。当关闭 RStudio 服务器选项卡时，实际上服务器仍会在后台运行。下次返回时，会发现与上次离开的地方一模一样。因此定期重启变得更加重要，这样才便于从头开始。\n\n\n6.1.1.0.1 6.2.2 分析文件位于何处？\nR 的工作目录概念绝不可忽视。这是 R 查找要求它加载的文件的位置，以及它所放置的保存文件的位置。RStudio 在控制台顶部显示当前工作目录：\n\n可以通过运行getwd()命令打印工作目录：\n&gt; getwd()\n[1] \"C:/Users/LENOVO/Desktop/r_packages/BLIT/blit/R\"\n可以从 R 中设置工作目录，但书中不建议这样做：\n&gt; setwd(\"/path/to/my/CoolProject\")\n因为有更好的方法管理工作——RStudio项目。\n\n\n\n6.1.2 RStudio项目\n将项目的所有相关文件（输入数据、R 脚本、分析结果）全部保存在同一个目录中是非常明智的做法， RStudio 也对此提供了内置支持。\n下面实操为例，创建一个阅读本书剩余部分时专用的项目：\n\n随后在脚本编辑器中输入以下命令并保存文件，将其命名为 “diamonds.R”。再创建一个名为 “data” 的新文件夹。最后，运行完整脚本，该脚本会将相关 PNG 和 CSV 文件保存到项目目录中。本书后续会对这些文件进行探索。\nlibrary(tidyverse)\n\nggplot(diamonds, aes(x = carat, y = price)) + \n  geom_hex()\nggsave(\"diamonds.png\")\n\nwrite_csv(diamonds, \"data/diamonds.csv\")\n退出 RStudio，在电脑上找到该项目文件夹，双击.Rproj文件即可重新打开项目。\n\n\n6.1.3 相对和绝对路径\n一旦进入项目，就最好只使用相对路径，而非绝对路径。\n为什么？举例说明：如果一个叫 Dingjia 的人做了个项目，编辑了一个data/diamonds.csv文件，显然使用的是相对路径，而其绝对路径为/Users/Dingjia/Documents/r4ds/data/diamonds。现在协作者 Zhangsan 要在自己的电脑上运行代码，即可正常进行，因为相对路径指向的绝对路径为/Users/Zhangsan/Documents/r4ds/data/diamonds。\n从以上例子可以看出，使用相对路径对于共享协作意义非凡。\n但还有一点要注意，不同操作系统的分隔符存在差异，例如Mac 和 Linux 使用正斜杠（/），Windows 使用反斜杠（\\ ）。在 R 中，反斜杠需要连续键入两个才可被识别，这很繁琐恼人，故建议直接使用正斜杠。",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>脚本与项目</span>"
    ]
  },
  {
    "objectID": "chapters/ch7_data_import.html",
    "href": "chapters/ch7_data_import.html",
    "title": "7  数据导入",
    "section": "",
    "text": "7.1 引言\n本章介绍如何读取纯文本矩形数据文件，如何将数据写入文件，以及如何创建数据框。\n主要学习readr包，同样是tidyverse的组成部分。",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>数据导入</span>"
    ]
  },
  {
    "objectID": "chapters/ch7_data_import.html#引言",
    "href": "chapters/ch7_data_import.html#引言",
    "title": "7  数据导入",
    "section": "",
    "text": "library(tidyverse)",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>数据导入</span>"
    ]
  },
  {
    "objectID": "chapters/ch7_data_import.html#从文件中读取数据",
    "href": "chapters/ch7_data_import.html#从文件中读取数据",
    "title": "7  数据导入",
    "section": "7.2 从文件中读取数据",
    "text": "7.2 从文件中读取数据\n首先重点介绍最常见的矩形数据文件类型 CSV（Comma-Separated Values）。\n下面是一个简单的 CSV 文件。第一行（通常称为标题行）提供列名称，接下的六行提供数据。列之间用逗号分隔。\nStudent ID,Full Name,favourite.food,mealPlan,AGE\n1,Sunil Huffmann,Strawberry yoghurt,Lunch only,4\n2,Barclay Lynn,French fries,Lunch only,5\n3,Jayendra Lyne,N/A,Breakfast and lunch,7\n4,Leon Rossini,Anchovies,Lunch only,\n5,Chidiegwu Dunkel,Pizza,Breakfast and lunch,five\n6,Güvenç Attila,Ice cream,Lunch only,6\n使用read_csv()将文件读取到R中。其第一个参数最重要——文件路径（也可以使用URL）。\nstudents &lt;- read_csv(\"data/students.csv\")\nstudents &lt;- read_csv(\"https://pos.it/r4ds-students-csv\")\n读入数据后，通常需要先对其进行转换，以便在分析时更易使用。带着这一目的，我们再审视一下这个数据表。\nstudents\n#&gt; # A tibble: 6 × 5\n#&gt;   `Student ID` `Full Name`      favourite.food     mealPlan            AGE  \n#&gt;          &lt;dbl&gt; &lt;chr&gt;            &lt;chr&gt;              &lt;chr&gt;               &lt;chr&gt;\n#&gt; 1            1 Sunil Huffmann   Strawberry yoghurt Lunch only          4    \n#&gt; 2            2 Barclay Lynn     French fries       Lunch only          5    \n#&gt; 3            3 Jayendra Lyne    N/A                Breakfast and lunch 7    \n#&gt; 4            4 Leon Rossini     Anchovies          Lunch only          &lt;NA&gt; \n#&gt; 5            5 Chidiegwu Dunkel Pizza              Breakfast and lunch five \n#&gt; 6            6 Güvenç Attila    Ice cream          Lunch only          6\n有两个问题：\n\n默认情况下，read_csv()会将空字符串\"\"识别为 NA，但注意到原表中有个“N/A”，并未在R中显示为NA，可以单独设置将其读取为NA。\nStudent ID和Full Name两个列名有引号，是因为原表中列名包含空格，不合法，除非在读取时用引号标注。\n\n&gt; students &lt;- read_csv(\"data/students.csv\", na = c(\"N/A\", \"\"))\n&gt; students |&gt; \n  rename(\n    student_id = `Student ID`,\n    full_name = `Full Name`\n  )\n&gt; students\n#&gt; # A tibble: 6 × 5\n#&gt;   `Student ID` `Full Name`      favourite.food     mealPlan            AGE  \n#&gt;          &lt;dbl&gt; &lt;chr&gt;            &lt;chr&gt;              &lt;chr&gt;               &lt;chr&gt;\n#&gt; 1            1 Sunil Huffmann   Strawberry yoghurt Lunch only          4    \n#&gt; 2            2 Barclay Lynn     French fries       Lunch only          5    \n#&gt; 3            3 Jayendra Lyne    &lt;NA&gt;               Breakfast and lunch 7    \n#&gt; 4            4 Leon Rossini     Anchovies          Lunch only          &lt;NA&gt; \n#&gt; 5            5 Chidiegwu Dunkel Pizza              Breakfast and lunch five \n#&gt; 6            6 Güvenç Attila    Ice cream          Lunch only          6\n接下来考虑数据类型与数据本身的校正，有两点需要关注。\n\nmeal_plan是一个分类变量，应该在R中表示为因子（fct），而非字符（chr）。\nage列中有一个数据为five而非数字5。\n\nstudents |&gt;\n  janitor::clean_names() |&gt;\n  mutate(\n    meal_plan = factor(meal_plan),\n    age = parse_number(if_else(age == \"five\", \"5\", age))\n  )\n#&gt; # A tibble: 6 × 5\n#&gt;   student_id full_name        favourite_food     meal_plan           age  \n#&gt;        &lt;dbl&gt; &lt;chr&gt;            &lt;chr&gt;              &lt;fct&gt;               &lt;chr&gt;\n#&gt; 1          1 Sunil Huffmann   Strawberry yoghurt Lunch only          4    \n#&gt; 2          2 Barclay Lynn     French fries       Lunch only          5    \n#&gt; 3          3 Jayendra Lyne    &lt;NA&gt;               Breakfast and lunch 7    \n#&gt; 4          4 Leon Rossini     Anchovies          Lunch only          &lt;NA&gt; \n#&gt; 5          5 Chidiegwu Dunkel Pizza              Breakfast and lunch five \n#&gt; 6          6 Güvenç Attila    Ice cream          Lunch only          6\n这样便基本改完了。\n另外read_csv()函数可以快捷生成格式化为 CSV 文件的文本字符串：\nread_csv(\n  \"a,b,c\n  1,2,3\n  4,5,6\"\n)\n#&gt; # A tibble: 2 × 3\n#&gt;       a     b     c\n#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1     1     2     3\n#&gt; 2     4     5     6\n通常，默认使用数据的第一行作为列名。但是，经常能在文件顶部看到有几行元数据，干扰列名的指定。可以使用skip = n跳过前n行，或者使用cmment = #丢弃所有以#开头的行：\nread_csv(\n  \"The first line of metadata\n  The second line of metadata\n  x,y,z\n  1,2,3\",\n  skip = 2\n)\n#&gt; # A tibble: 1 × 3\n#&gt;       x     y     z\n#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1     1     2     3\n\nread_csv(\n  \"# A comment I want to skip\n  x,y,z\n  1,2,3\",\n  comment = \"#\"\n)\n#&gt; # A tibble: 1 × 3\n#&gt;       x     y     z\n#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1     1     2     3\n在某些情况下，数据可能没有列名。可以使用 col_names = FALSE来指出不要将第一行视为标题，而是从X1到Xn按顺序标记它们：\nread_csv(\n  \"1,2,3\n  4,5,6\",\n  col_names = FALSE\n)\n#&gt; # A tibble: 2 × 3\n#&gt;      X1    X2    X3\n#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1     1     2     3\n#&gt; 2     4     5     6\n或者，可以传递一个字符向量给col_names，从而自定义列名：\nread_csv(\n  \"1,2,3\n  4,5,6\",\n  col_names = c(\"x\", \"y\", \"z\")\n)\n#&gt; # A tibble: 2 × 3\n#&gt;       x     y     z\n#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1     1     2     3\n#&gt; 2     4     5     6\n一旦掌握了read_csv()，其他类似函数便迎刃而解。\n\nread_csv2()读取以分号分隔的文件，在用逗号作为较大位数分隔符的国家很常见。\nread_tsv()读取制表符分隔的文件。\nread_delim()读入包含任何分隔符的文件，自动猜测分隔符。\nread_fwf()读取固定宽度的文件。\nread_table()读取固定宽度文件的一种常见变体，其中列由空格分隔。\nread_log()读取 Apache 样式的日志文件。",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>数据导入</span>"
    ]
  },
  {
    "objectID": "chapters/ch7_data_import.html#控制列类型",
    "href": "chapters/ch7_data_import.html#控制列类型",
    "title": "7  数据导入",
    "section": "7.3 控制列类型",
    "text": "7.3 控制列类型\nCSV文件不包含有关变量类型的信息（即它是logical、number、string 等），故readr会自己猜测类型。\n但这难免会存在失误。最常见的原因是列中包含意外值，且一般会误判为chr。如果用NA之外的字符表示缺失值也称为意外值。比如：\n&gt; simple_csv &lt;- \"\n  x\n  10\n  .\n  20\n  30\"\n&gt; read_csv(simple_csv)\n#&gt; # A tibble: 4 × 1\n#&gt;   x    \n#&gt;   &lt;chr&gt;\n#&gt; 1 10   \n#&gt; 2 .    \n#&gt; 3 20   \n#&gt; 4 30\n这个表很短，很快能发现预期外字符的位置，当数据特别长时需要一种特定方法。通过col_types参数自主指定每列的数据类型，然后看readr在哪报错即可。\ndf &lt;- read_csv(\n  simple_csv, \n  col_types = list(x = col_double()) #指定数据列的类型为双精度浮点数\n)\n#&gt; Warning: One or more parsing issues, call `problems()` on your data frame for\n#&gt; details, e.g.:\n#&gt;   dat &lt;- vroom(...)\n#&gt;   problems(dat)\n现在readr指出操作存在问题，并建议我们使用problems()函数进一步确认。\nproblems(df)\n#&gt; # A tibble: 1 × 5\n#&gt;     row   col expected actual file                            \n#&gt;   &lt;int&gt; &lt;int&gt; &lt;chr&gt;    &lt;chr&gt;  &lt;chr&gt;                           \n#&gt; 1     3     1 a double .      /tmp/RtmpqR32wU/file2304111d9453\n第 3 行第 1 列存在问题，其中 readr 期望得到双精度浮点数，但得到的只是一个. 。这表明此数据集使用.表示缺失值。所以设置 na = \".\"即可让所有意外值回到正轨。\nread_csv(simple_csv, na = \".\")\n#&gt; # A tibble: 4 × 1\n#&gt;       x\n#&gt;   &lt;dbl&gt;\n#&gt; 1    10\n#&gt; 2    NA\n#&gt; 3    20\n#&gt; 4    30\n像上面col_double()一样的列类型函数共有九种：\n\ncol_logical()和col_double()读取逻辑量和实数。\ncol_integer()读取整数。\ncol_character()读取字符串。\ncol_factor()、col_date()、col_datetime() 分别创建因子、日期和时间。\ncol_number()是一个数字解析器，它忽略非数字组件，对货币数据特别有用。\ncol_skip()跳过一列，使其不包含在结果中，如果有一个大型 CSV 文件并且只想使用某些列，这对于加快读取数据很有效。\n\n除了用list()进行指定，还有cols()，且用.default参数表示所有列：\nanother_csv &lt;- \"\nx,y,z\n1,2,3\"\n\nread_csv(\n  another_csv, \n  col_types = cols(.default = col_character())\n)\n#&gt; # A tibble: 1 × 3\n#&gt;   x     y     z    \n#&gt;   &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;\n#&gt; 1 1     2     3\n另外还有cols_only()值得一提，它可以只读取我们指定类型的列：\nread_csv(\n  another_csv,\n  col_types = cols_only(x = col_character())\n)\n#&gt; # A tibble: 1 × 1\n#&gt;   x    \n#&gt;   &lt;chr&gt;\n#&gt; 1 1",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>数据导入</span>"
    ]
  },
  {
    "objectID": "chapters/ch7_data_import.html#多个文件读取数据",
    "href": "chapters/ch7_data_import.html#多个文件读取数据",
    "title": "7  数据导入",
    "section": "7.4 多个文件读取数据",
    "text": "7.4 多个文件读取数据\n有时，数据被拆分为多个文件，而不是包含在单个文件中。如下例一次性读取：\nsales_files &lt;- c(\"data/01-sales.csv\", \"data/02-sales.csv\", \"data/03-sales.csv\")\nread_csv(sales_files, id = \"file\")\n#&gt; # A tibble: 19 × 6\n#&gt;   file              month    year brand  item     n\n#&gt;   &lt;chr&gt;             &lt;chr&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1 data/01-sales.csv January  2019     1  1234     3\n#&gt; 2 data/01-sales.csv January  2019     1  8721     9\n#&gt; 3 data/01-sales.csv January  2019     1  1822     2\n#&gt; 4 data/01-sales.csv January  2019     2  3333     1\n#&gt; 5 data/01-sales.csv January  2019     2  2156     9\n#&gt; 6 data/01-sales.csv January  2019     2  3987     6\n#&gt; # ℹ 13 more rows\n注意到id参数为表格添加了一个指定名称的新列，该列用于标识数据来自的源文件。",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>数据导入</span>"
    ]
  },
  {
    "objectID": "chapters/ch7_data_import.html#文件写入",
    "href": "chapters/ch7_data_import.html#文件写入",
    "title": "7  数据导入",
    "section": "7.5 文件写入",
    "text": "7.5 文件写入\n要将CSV等文件保存回磁盘，，使用write_csv()和write_tsv()类型函数。有两个主要参数，一个是数据框，一个是保存的地址。\nwrite_csv(students, \"students.csv\")\n但是这样有个弊端。我们都知道CSV文件不包含列的类型，所以即便我们已经修改过表格，而写入后再读取仍会恢复原样。有两种解决办法保留列类型：\n\n使用write_rds()和read_rds()函数。rds是以R自定义的二进制存储格式，所以我们要重新加载时的R对象与当时存储的是完全相同的。\narrow包中的write_parquet()和read_parquet()函数。这同样是二进制存储格式，且不限于R，可以跨编程语言共享。",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>数据导入</span>"
    ]
  },
  {
    "objectID": "chapters/ch7_data_import.html#数据输入",
    "href": "chapters/ch7_data_import.html#数据输入",
    "title": "7  数据导入",
    "section": "7.6 数据输入",
    "text": "7.6 数据输入\n有时会需要我们自己手搓一个tibble，有两个函数来实现。\n\ntibble()。在输入数据时横向排列。\n\ntibble(\n  x = c(1, 2, 5), \n  y = c(\"h\", \"m\", \"g\"),\n  z = c(0.08, 0.83, 0.60)\n)\n#&gt; # A tibble: 3 × 3\n#&gt;       x y         z\n#&gt;   &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt;\n#&gt; 1     1 h      0.08\n#&gt; 2     2 m      0.83\n#&gt; 3     5 g      0.6\n\ntribble()。在输入数据时纵向排列，更方便排版。注意输入时列标题以~开头。\n\ntribble(\n  ~x, ~y, ~z,\n  1, \"h\", 0.08,\n  2, \"m\", 0.83,\n  5, \"g\", 0.60\n)\n#&gt; # A tibble: 3 × 3\n#&gt;       x y         z\n#&gt;   &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt;\n#&gt; 1     1 h      0.08\n#&gt; 2     2 m      0.83\n#&gt; 3     5 g      0.6\n\ntribble表示：transposed tibble",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>数据导入</span>"
    ]
  },
  {
    "objectID": "chapters/ch8_workflow_getting_help.html",
    "href": "chapters/ch8_workflow_getting_help.html",
    "title": "8  工作流：获取帮助",
    "section": "",
    "text": "8.1 8.1 Google\n本章介绍获取R相关知识的途径。\n用Google限定关键词搜索，如R包名称等。当R报错时，可直接将报错信息进行检索，大概率会有人曾遇到一样的问题。\n运行Sys.setenv(LANGUAGE = \"en\")命令将报错信息以英文呈现，从而便于检索到更多信息。\n另外 Stack Overflow 网站是一个与程序相关的 IT 技术问答网站，可以在这获取帮助。",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>工作流：获取帮助</span>"
    ]
  },
  {
    "objectID": "chapters/ch8_workflow_getting_help.html#创建-reprex",
    "href": "chapters/ch8_workflow_getting_help.html#创建-reprex",
    "title": "8  工作流：获取帮助",
    "section": "8.2 8.2 创建 reprex",
    "text": "8.2 8.2 创建 reprex\n如果谷歌没有搜到有帮助的信息，则需要自己准备一个 reprex 去提问。所谓 reprex 就是：minimal reproducible example 。\n手动创建 reprex 时，很容易不小心遗漏某些内容，可能导致代码无法在其他人的计算机上运行。使用 reprex 包可以避免这个问题，它也是 tidyverse 包的一部分。\n假设将此代码复制到剪贴板上：\ny &lt;- 1:4\nmean(y)\n然后在R中输入reprex::reprex()，一个渲染好的 HTML 预览会显示在 RStudio 的查看器或默认浏览器中。同时，reprex 会自动复制到剪贴板。剪贴板内容如下：\n``` r\ny &lt;- 1:4\nmean(y)\n#&gt; [1] 2.5\n```\n\n&lt;sup&gt;Created on 2025-06-01 with [reprex v2.1.1](https://reprex.tidyverse.org \"reprex v2.1.1\")&lt;/sup&gt;\n\n其实就是markdown格式的代码块。\n\n要使示例具有可重复性，需要包含三项内容：必需的包、数据和代码。\n\n包要在脚本开头加载。要检查软件包是否使用的是最新版，可以运行tidyverse_update()函数。\n使用能揭示问题的最小数据子集。\n确保代码易于其他人阅读：\n\n规范使用空格，变量名称简洁但信息丰富。\n使用注释。\n尽量删除与问题无关的所有内容。",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>工作流：获取帮助</span>"
    ]
  },
  {
    "objectID": "chapters/ch8_workflow_getting_help.html#自我投资",
    "href": "chapters/ch8_workflow_getting_help.html#自我投资",
    "title": "8  工作流：获取帮助",
    "section": "8.3 8.3 自我投资",
    "text": "8.3 8.3 自我投资\n每天花点时间学习 R。\ntidyverse博客：https://www.tidyverse.org/blog/\nR Weekly：https://rweekly.org/",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>工作流：获取帮助</span>"
    ]
  },
  {
    "objectID": "chapters/ch9_layers.html",
    "href": "chapters/ch9_layers.html",
    "title": "9  图层",
    "section": "",
    "text": "9.1 引言\n本章将在学习图形的分层语法时扩展ggplot2基础，从更深入地研究美学映射、几何对象和分面开始。然后介绍 ggplot2 在创建绘图时在后台进行的统计转换，这些变换用于计算要绘制的新值，例如条形图中条形的高度或箱形图中的中位数。另外还将了解位置调整，用于修改几何在绘图中的显示方式。最后，简要介绍坐标系相关内容。",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>图层</span>"
    ]
  },
  {
    "objectID": "chapters/ch9_layers.html#美学映射",
    "href": "chapters/ch9_layers.html#美学映射",
    "title": "9  图层",
    "section": "9.2 美学映射",
    "text": "9.2 美学映射\n\n“The greatest value of a picture is when it forces us to notice what we never expected to see.” — John Tukey\n\nmpg数据框与ggplot2包捆绑，包含 38 个汽车模型的 234 个观测值。\nmpg\n#&gt; # A tibble: 234 × 11\n#&gt;   manufacturer model displ  year   cyl trans      drv     cty   hwy fl   \n#&gt;   &lt;chr&gt;        &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt;      &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt;\n#&gt; 1 audi         a4      1.8  1999     4 auto(l5)   f        18    29 p    \n#&gt; 2 audi         a4      1.8  1999     4 manual(m5) f        21    29 p    \n#&gt; 3 audi         a4      2    2008     4 manual(m6) f        20    31 p    \n#&gt; 4 audi         a4      2    2008     4 auto(av)   f        21    30 p    \n#&gt; 5 audi         a4      2.8  1999     6 auto(l5)   f        16    26 p    \n#&gt; 6 audi         a4      2.8  1999     6 manual(m5) f        18    26 p    \n#&gt; # ℹ 228 more rows\n#&gt; # ℹ 1 more variable: class &lt;chr&gt;\n变量解释：\n\ndispl：汽车的发动机尺寸，以升为单位。数值变量。\nhwy：汽车在高速公路上的燃油效率，以每加仑英里数 （mpg） 为单位。当它们行驶相同的距离时，燃油效率低的汽车比燃油效率高的汽车消耗更多的燃料。数值变量。\nclass： 汽车类型。分类变量。\n\n下面先初步可视化displ和hwy的关系。用散点图即可，数值变量映射到x和y美学，分类变量映射到color或shape美学。\n# 上图\nggplot(mpg, aes(x = displ, y = hwy, color = class)) +\n  geom_point()\n\n# 下图\nggplot(mpg, aes(x = displ, y = hwy, shape = class)) +\n  geom_point()\n#&gt; Warning: The shape palette can deal with a maximum of 6 discrete values because more\n#&gt; than 6 becomes difficult to discriminate\n#&gt; ℹ you have requested 7 values. Consider specifying shapes manually if you\n#&gt;   need that many of them.\n#&gt; Warning: Removed 62 rows containing missing values or values outside the scale range\n#&gt; (`geom_point()`).\n\n\n当映射到class和shape时，收到两个警告：\n\n形状调色板最多可以处理 6 个离散值，因为超过 6 个就很难区分；现在有 7 个。如果必须具有形状，请考虑手动指定形状。\ngeom_point()删除了包含缺失值的 62 行。\n\n同样，我们也可以将class映射到 size或alpha 美学，分别控制点的大小和透明度。\n# 上图\nggplot(mpg, aes(x = displ, y = hwy, size = class)) +\n  geom_point()\n#&gt; Warning: Using size for a discrete variable is not advised.\n\n# 下图\nggplot(mpg, aes(x = displ, y = hwy, alpha = class)) +\n  geom_point()\n#&gt; Warning: Using alpha for a discrete variable is not advised.\n\n\n也会产生警告：\n\n不建议对离散变量使用 alpha。\n\n还可以手动将 geom 的视觉属性设置参数。例如，我们可以将绘图中的所有点设为蓝色：\nggplot(mpg, aes(x = displ, y = hwy)) + \n  geom_point(color = \"blue\")\n\n在这里，颜色不传达有关变量的信息，而只是更改绘图外观。\n\n字符串形式的颜色名称，例如color = \"blue\"\n以 mm 为单位的点的大小，例如size = 1\n点的形状以数字表示，例如shape = 1。更多形状如图所示。",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>图层</span>"
    ]
  },
  {
    "objectID": "chapters/ch9_layers.html#几何对象",
    "href": "chapters/ch9_layers.html#几何对象",
    "title": "9  图层",
    "section": "9.3 几何对象",
    "text": "9.3 几何对象\n\n9.3.1 相似点图分析\n\n\n两幅图都展示了汽车高速燃油效率与发动机排量的关系。上边的图是散点图，下边的图显示了跟随这些变量关系轨迹的平滑曲线，并且周围还显示了置信区间。\n虽然两幅图描述的是相同的数据，但它们并不完全相同。每幅图使用不同的几何对象(geom)来表示数据。左边的图使用点几何对象(point geom)，右边的图使用平滑几何对象(smooth geom)，即一条拟合数据的平滑线。\n要改变图中的几何对象，可以更改ggplot()中的几何函数。例如，要分别创建上述两幅图，可以使用以下代码：\n# 上图\nggplot(mpg, aes(x = displ, y = hwy)) + \n  geom_point()\n\n# 下图\nggplot(mpg, aes(x = displ, y = hwy)) + \n  geom_smooth()\n\n\n9.3.2 映射\nggplot2中的每个几何函数都接受一个映射参数，可以在几何层中局部定义，也可以在ggplot()层中全局定义。然而，并非每个美学属性都适用于每个几何对象。例如，可以设置点的形状，但不能设置所谓线的“type”。如果这样做，ggplot2会忽略该美学映射。\n但是话又说回来，可以设置线的“linetype”。\n\n\n以下代码展示了如何使用不同的线型来表示不同类型驱动系统的汽车：\n# 上图\nggplot(mpg, aes(x = displ, y = hwy, shape = drv)) + \n  geom_smooth()\n\n# 下图\nggplot(mpg, aes(x = displ, y = hwy, linetype = drv)) + \n  geom_smooth()\n而且可以在同一图形中包含多个几何对象。例如，以下代码将原始数据点和平滑曲线叠加在一起：\nggplot(mpg, aes(x = displ, y = hwy, color = drv)) + \n  geom_point() +\n  geom_smooth(aes(linetype = drv))\n\n\n\n9.3.3 分组\n许多几何函数，如geom_smooth()，使用单个几何对象来显示多行数据。对于这些函数，可以将其美学设置为分类变量来绘制多个对象。实践中，当将美学映射到离散变量时，ggplot2会自动为这些几何对象分组数据。\nggplot(mpg, aes(x = displ, y = hwy)) +\n  geom_smooth(aes(color = drv), show.legend = FALSE)\n\n\n\n9.3.4 几何对象变换\n几何对象是ggplot2的基本构建块。通过改变几何对象可改变图形的外观，从而揭示数据的不同特征。例如，下面的直方图和密度图揭示了高速里程的分布是双峰且右偏的，而箱线图则揭示了两个潜在的离群值。\n\n\n\n# 上图：直方图\nggplot(mpg, aes(x = hwy)) +\n  geom_histogram(binwidth = 2)\n\n# 中图：密度图\nggplot(mpg, aes(x = hwy)) +\n  geom_density()\n\n# 下图：箱线图\nggplot(mpg, aes(x = hwy)) +\n  geom_boxplot()\n\n\n9.3.5 扩展几何对象\nggplot2提供了40多种几何对象，但这些并不涵盖所有可能的图形。如果需要不同的几何对象，建议首先查看扩展包，看看是否有人已经实现了。例如，ggridges包可用于制作山脊线图，这对于可视化分类变量不同水平的数值变量的密度很有效。\nlibrary(ggridges)\n\nggplot(mpg, aes(x = hwy, y = drv, fill = drv, color = drv)) +\n  geom_density_ridges(alpha = 0.5, show.legend = FALSE)",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>图层</span>"
    ]
  },
  {
    "objectID": "chapters/ch9_layers.html#分面",
    "href": "chapters/ch9_layers.html#分面",
    "title": "9  图层",
    "section": "9.4 分面",
    "text": "9.4 分面\n第一章介绍了使用facet_wrap()进行分面，它将图形分割为子图，每个子图基于一个分类变量显示数据的一个子集。\nggplot(mpg, aes(x = displ, y = hwy)) + \n  geom_point() + \n  facet_wrap(~cyl)\n\n要用两个变量的组合对图形进行分面，可以从facet_wrap()切换到facet_grid()。facet_grid()的第一个参数形如行~列。\nggplot(mpg, aes(x = displ, y = hwy)) + \n  geom_point() + \n  facet_grid(drv ~ cyl)\n\n默认情况下，每个分面共享相同的x轴和y轴比例和范围。这在想要跨分面比较数据时很有效，但当想要更好地可视化每个分面内的关系时可能会受限制。在分面函数中设置scales参数为\"free_x\"可允许跨列的不同x轴比例，\"free_y\"可允许跨行的不同y轴比例，\"free\"则表示两者共存。\nggplot(mpg, aes(x = displ, y = hwy)) + \n  geom_point() + \n  facet_grid(drv ~ cyl, scales = \"free\")",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>图层</span>"
    ]
  },
  {
    "objectID": "chapters/ch9_layers.html#统计变换",
    "href": "chapters/ch9_layers.html#统计变换",
    "title": "9  图层",
    "section": "9.5 统计变换",
    "text": "9.5 统计变换\n以一个基础的柱状图为例，通过 geom_bar() 或 geom_col() 绘制。下图展示了 diamonds 数据集中按照切工（cut）分组的钻石总数。该数据集来自 ggplot2 包，包含约 5.4 万颗钻石的信息，包括每颗钻石的价格（price）、克拉数（carat）、颜色（color）、净度（clarity）和切工（cut）。图中显示，相较于低质量切工，拥有高质量切工的钻石更多。\nggplot(diamonds, aes(x = cut)) + \n  geom_bar()\n\n图的 x 轴是来自 diamonds 数据集的 cut 变量，而 y 轴显示的是 count，但 count 并不是 diamonds 中的变量！那么 count 是从哪里来的？\n许多图形（如散点图）会绘制数据集中的原始值。而另一些图形（如柱状图）则会计算新的值进行绘图：\n\n柱状图、直方图与频率多边图 会将数据分箱（bin），然后绘制每个箱中数据点的数量；\n平滑曲线（smoothers） 会拟合模型并绘制模型预测值；\n箱线图（boxplots） 会计算分布的五数摘要（最小值、下四分位数、中位数、上四分位数、最大值），并以特定格式的箱体呈现。\n\n用于为图形计算新值的算法称为 stat，即统计变换（statistical transformation）的简称。下图展示了 geom_bar() 中这一过程的工作机制。\n\n\n绘制柱状图的三个步骤： 第一步，geom_bar() 从原始数据集 diamonds 开始； 第二步，geom_bar() 使用 count 这个 stat 对数据进行转换，生成一个包含 cut 值与 count 值的数据集； 第三步，geom_bar() 使用这个经过变换的数据来构建图形：cut 映射到 x 轴，count 映射到 y 轴。\n简言之，当我们创建柱状图时，首先从原始数据出发，接着聚合以统计每个柱状的观测数，最后将这些计算所得的变量映射到图形属性上。\n\n可以通过查看 stat 参数的默认值来了解某个 geom 使用了哪个 stat。例如，运行 ?geom_bar 可看到其默认的 stat 是 \"count\"，这意味着 geom_bar() 实际上使用的是 stat_count()。stat_count() 的文档与 geom_bar() 在同一页面上。如果向下滚动，可以在“Computed variables”（计算变量）部分看到该 stat 计算出两个新变量：count 与 prop。\n每个 geom 都有一个默认的 stat，每个 stat 也有一个默认的 geom。因此，通常在使用 geoms 时无需考虑背后的统计变换。但在以下三种情形下，可能需要显式使用 stat：\n\n重设默认的 stat\n\n在下面的代码中，将 geom_bar() 的 stat 从默认的 \"count\" 更改为 \"identity\"。这样可以将柱子的高度直接映射为某个变量的原始值，而非自动统计得到的数量。\ndiamonds |&gt;\n  count(cut) |&gt;\n  ggplot(aes(x = cut, y = n)) +\n  geom_bar(stat = \"identity\")\n\n\n重写变换后变量的美学映射\n\n例如，可能希望绘制柱状图显示每类钻石的比例，而不是数量：\nggplot(diamonds, aes(x = cut, y = after_stat(prop), group = 1)) + \n  geom_bar()\n\n\n在代码中明确突出统计变换的过程\n\n例如，可以使用 stat_summary() 来强调正在对 y 值进行摘要计算：该 stat 会对每个唯一的 x 值进行汇总。\nggplot(diamonds) + \n  stat_summary(\n    aes(x = cut, y = depth),\n    fun.min = min,\n    fun.max = max,\n    fun = median\n  )\n\nggplot2 提供了超过 20 种 stat 可供使用。每一个 stat 都是一个函数，因此可以通过 ?stat_bin 的形式获取帮助文档。",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>图层</span>"
    ]
  },
  {
    "objectID": "chapters/ch9_layers.html#位置调整",
    "href": "chapters/ch9_layers.html#位置调整",
    "title": "9  图层",
    "section": "9.6 位置调整",
    "text": "9.6 位置调整\n条形图可通过颜色美学（color）或填充美学（fill）着色。例如：\n# 上图\nggplot(mpg, aes(x = drv, color = drv)) + \n  geom_bar()\n\n# 下图\nggplot(mpg, aes(x = drv, fill = drv)) + \n  geom_bar()\n\n\n上图的条形仅显示彩色边框，下图的条形则填充了颜色。条形高度对应每种驱动类型（drv）的汽车数量。\n如果将填充美学映射到另一个变量（如 class），条形会自动堆叠：\nggplot(mpg, aes(x = drv, fill = class)) + \n  geom_bar()\n\n堆叠条形图显示汽车驱动类型，每个条形按汽车类别（class）填充颜色。条形总高度表示驱动类型的车辆总数，各色块高度表示该驱动类型下不同类别的车辆数量。\n堆叠效果由 position 参数自动控制。若需取消堆叠，有三种方式：\n\nposition = \"identity\"\n将每个对象精确绘制在其原始位置（条形会重叠，需配合透明度使用）：\n# 上图：半透明填充\nggplot(mpg, aes(x = drv, fill = class)) + \n  geom_bar(alpha = 1/5, position = \"identity\")\n\n# 下图：无填充仅边框\nggplot(mpg, aes(x = drv, color = class)) + \n  geom_bar(fill = NA, position = \"identity\")\n\n\nposition = \"fill\"\n堆叠并标准化高度为1，各色块高度表示类别在驱动类型中的占比：\nggplot(mpg, aes(x = drv, fill = class)) + \n  geom_bar(position = \"fill\")\n\nposition = \"dodge\"\n并列排列重叠对象，便于直接比较数值：\nggplot(mpg, aes(x = drv, fill = class)) + \n  geom_bar(position = \"dodge\")\n\n\n有时散点图存在过度绘制问题，如下图中数据取整导致点重叠。\n\n通过 position = \"jitter\" 添加轻微随机扰动可缓解：\nggplot(mpg, aes(x = displ, y = hwy)) + \n  geom_point(position = \"jitter\")\n\n抖动散点图显示发动机排量（displ）与高速油耗（hwy）的负相关。虽然小尺度精度下降，但大尺度分布更清晰。另有快捷函数 geom_jitter() 等效于 geom_point(position = \"jitter\")。",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>图层</span>"
    ]
  },
  {
    "objectID": "chapters/ch9_layers.html#坐标系系统",
    "href": "chapters/ch9_layers.html#坐标系系统",
    "title": "9  图层",
    "section": "9.7 坐标系系统",
    "text": "9.7 坐标系系统\nggplot2 默认使用笛卡尔坐标系（Cartesian），x 和 y 轴独立定位点位置。此外还有两种特殊坐标系：\n\n地理地图矫正：coord_quickmap()\n\n绘制地理空间数据时，可通过此函数校正长宽比例（保持地图不变形）。以下以新西兰地图为例：\n\n\nnz &lt;- map_data(\"nz\")\n\n# 未校正比例（上图）\nggplot(nz, aes(x = long, y = lat, group = group)) +\n  geom_polygon(fill = \"white\", color = \"black\")\n\n# 校正比例（下图）\nggplot(nz, aes(x = long, y = lat, group = group)) +\n  geom_polygon(fill = \"white\", color = \"black\") +\n  coord_quickmap()\n两图对比新西兰边界：左图比例失真，右图通过 coord_quickmap() 保持正确地理比例。\n\n极坐标系：coord_polar()\n\n将条形图转换为玫瑰图（Coxcomb chart），可揭示数据分布的周期性，每个类别对应一个扇形区域。\n# 基础条形图（长宽比设为1:1）\nbar &lt;- ggplot(diamonds) + \n  geom_bar(\n    aes(x = clarity, fill = clarity), \n    show.legend = FALSE,\n    width = 1\n  ) + \n  theme(aspect.ratio = 1)\n\n# 横向条形图（上图）\nbar + coord_flip()\n\n# 极坐标转换的玫瑰图（下图）\nbar + coord_polar()",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>图层</span>"
    ]
  },
  {
    "objectID": "chapters/ch10_exploratory_data_analysis.html",
    "href": "chapters/ch10_exploratory_data_analysis.html",
    "title": "10  探索性数据分析",
    "section": "",
    "text": "10.1 简介\n本章将介绍如何通过可视化和数据转换系统化地探索数据，这一过程在统计学中称为探索性数据分析（Exploratory Data Analysis, EDA）。EDA是一个迭代循环的过程，包含以下步骤：\nEDA是数据分析的核心环节，能帮助评估数据质量。例如，数据清洗本质上就是EDA的应用：通过质疑数据是否符合预期，利用可视化、转换和建模工具识别并解决问题。",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>探索性数据分析</span>"
    ]
  },
  {
    "objectID": "chapters/ch10_exploratory_data_analysis.html#简介",
    "href": "chapters/ch10_exploratory_data_analysis.html#简介",
    "title": "10  探索性数据分析",
    "section": "",
    "text": "提出问题：针对数据生成初步问题；\n探索答案：通过可视化、数据转换和建模寻找答案；\n迭代优化：根据发现的问题调整或生成新问题。",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>探索性数据分析</span>"
    ]
  },
  {
    "objectID": "chapters/ch10_exploratory_data_analysis.html#问题的艺术",
    "href": "chapters/ch10_exploratory_data_analysis.html#问题的艺术",
    "title": "10  探索性数据分析",
    "section": "10.2 问题的艺术",
    "text": "10.2 问题的艺术\n在EDA过程中，核心目标是理解数据，而提问是引导探索的最佳工具。每个问题都会聚焦到数据的特定方面，进而选择恰当的可视化、模型或数据转换方法。\nEDA本质上是创造性过程，提出高质量问题的关键在于追求问题数量。虽然由于尚未了解数据中隐藏信息，初期问题可能较肤浅，但每个新问题都会揭示新视角。通过连续追问可逐步深入数据。\n提问没有固定模板，但以下两类问题一般最有研究价值：\n\n变异（Variation）\n例如：某变量的分布形态如何？是否存在异常值？\n“顾客年龄范围是多少？80岁的记录是真实数据还是输入错误？”\n共变（Covariation）\n例如：两个变量是否存在关联？关联强度如何？\n“产品销量与广告支出是否同步变化？季节性影响是否显著？”",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>探索性数据分析</span>"
    ]
  },
  {
    "objectID": "chapters/ch10_exploratory_data_analysis.html#变异",
    "href": "chapters/ch10_exploratory_data_analysis.html#变异",
    "title": "10  探索性数据分析",
    "section": "10.3 变异",
    "text": "10.3 变异\n变异（Variation）指变量在不同测量中取值的波动现象。现实中所有连续变量都会存在变异，结果也会因微小误差而不同。理解变异的关键在于可视化的值分布。\n以钻石重量（carat）为例，通过直方图观察其分布：\n# 全数据集直方图（右偏分布）\nggplot(diamonds, aes(x = carat)) +\n  geom_histogram(binwidth = 0.5)\n\n# 聚焦小克拉钻石（窄binwidth揭示细节）\nsmaller &lt;- diamonds |&gt;\n  filter(carat &lt; 3)\n\nggplot(smaller, aes(x = carat)) +\n  geom_histogram(binwidth = 0.01)\n\n根据可视化图形，我们就可以进一步观察与追问。比如：\n\n峰值现象\n为什么克拉数为整数或常见分数（如0.5、1）的钻石更多？\n可能钻石切割标准或消费者偏好导致特定重量更常见。\n右偏特征\n每个峰值右侧的钻石为何比左侧多？\n可能切割时倾向于略微超重而非不足。\n诸如此类。\n\n图中若出现异常值，可能是错误数据或某些特殊现象。以钻石尺寸（y轴长度）为例：\n# 基础直方图（异常值被掩盖）\nggplot(diamonds, aes(x = y)) + \n  geom_histogram(binwidth = 0.5)\n\n# 聚焦y轴低频区域（暴露出异常）\nggplot(diamonds, aes(x = y)) + \n  geom_histogram(binwidth = 0.5) +\n  coord_cartesian(ylim = c(0, 50))\n\n# 根据图形提取异常记录\nunusual &lt;- diamonds |&gt; \n  filter(y &lt; 3 | y &gt; 20) |&gt; \n  select(price, x, y, z) |&gt;\n  arrange(y)\n提取完异常值，可按照以下思路针对性分析。\n\n零值\n尺寸为0mm的钻石（y=0）显然是数据错误，应转换为NA。\n极端值\n长达30mm+的钻石若价格不足万元，可能需核实：\n\n是否单位错误（如英寸误录为毫米）\n是否测量设备故障\n\n\n通过这种分析，我们不仅发现了数据质量问题（如零值），还可能识别出特殊钻石类别（如超大但低价的异常记录），为进一步处理提供方向。",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>探索性数据分析</span>"
    ]
  },
  {
    "objectID": "chapters/ch10_exploratory_data_analysis.html#异常值处理",
    "href": "chapters/ch10_exploratory_data_analysis.html#异常值处理",
    "title": "10  探索性数据分析",
    "section": "10.4 异常值处理",
    "text": "10.4 异常值处理\n数据中的异常值需要继续处理，有两种方式。\n\n直接删除整行\n\ndiamonds2 &lt;- diamonds |&gt; \n  filter(between(y, 3, 20))\n但是存在隐患，毕竟单个变量的异常不代表整行数据无效。\n\n替换为缺失值(NA)\n\ndiamonds2 &lt;- diamonds |&gt; \n  mutate(y = if_else(y &lt; 3 | y &gt; 20, NA, y))\n这一方法就更合理，能够保留其他变量的有效信息。\n排除缺失值后再次可视化，ggplot2默认移除缺失值并给出警告：\nggplot(diamonds2, aes(x = x, y = y)) + \n  geom_point()\n#&gt; Warning: Removed 9 rows containing missing values or values outside the scale range\n\n可通过na.rm = TRUE隐藏警告：\nggplot(diamonds2, aes(x = x, y = y)) + \n  geom_point(na.rm = TRUE)\n而有时缺失值本身也具有意义。例如航班数据中，dep_time为NA时，表示航班取消。",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>探索性数据分析</span>"
    ]
  },
  {
    "objectID": "chapters/ch10_exploratory_data_analysis.html#共变",
    "href": "chapters/ch10_exploratory_data_analysis.html#共变",
    "title": "10  探索性数据分析",
    "section": "10.5 共变",
    "text": "10.5 共变\n共变（Covariation）描述变量间的协同变化关系，是探索数据多维模式的核心工具。本节探索钻石价格与切工质量的关系，通过两种可视化方法揭示反常现象及其原因。\n\n频率多边形（Density标准化）\n\n我们首先进行初次尝试：\nggplot(diamonds, aes(x = price)) + \n  geom_freqpoly(aes(color = cut), binwidth = 500, linewidth = 0.75)\n\n这张图存在两点问题：\n\n不同切工等级的样本量差异大（如Ideal切工钻石最多），导致频数难以直接比较。\n图形重叠严重，无法清晰观察分布形态差异。\n\n如下改进：\nggplot(diamonds, aes(x = price, y = after_stat(density))) + \n  geom_freqpoly(aes(color = cut), binwidth = 500, linewidth = 0.75)\n\n将y轴从绝对计数转换为相对密度，使得每条曲线下的面积均为1。\n\n\n这样便可进行分析：\n\nFair切工（最低等级）的钻石价格密度分布右移，均值最高，较为反常。\n其他切工等级在1500美元附近出现高峰。\n\n\n箱线图\n\nggplot(diamonds, aes(x = cut, y = price)) +\n  geom_boxplot()\n\n分析可得：\n\n中位数价格：Fair &gt; Good &gt; Very Good &gt; Premium &gt; Ideal（随切工等级提升而下降）。\n分布形态：所有切工等级均右偏，但Fair切工的离群点更多。\n\n针对箱线图，还有一些扩展技巧如下。\n示例：车辆油耗（hwy）按车型（class）分类\n# 默认无序排列\nggplot(mpg, aes(x = class, y = hwy)) + geom_boxplot()\n\n# 按中位数排序\nggplot(mpg, aes(x = fct_reorder(class, hwy, median), y = hwy)) +\n  geom_boxplot()\n\n# 若名称过长，可翻转坐标轴\nggplot(mpg, aes(x = hwy, y = fct_reorder(class, hwy, median))) +\n  geom_boxplot()\n\n下面对变量关系进一步分析，但首先应确认变量类型。\n若要对两个分类变量的关系进行分析，有以下两种方法。\n\n气泡图（geom_count()）\nggplot(diamonds, aes(x = cut, y = color)) +\n  geom_count()\n\n每个气泡大小表示组合频数（如G色Ideal切工钻石最多）。虽然直观，但当类别过多时，气泡可能重叠。\n热图（geom_tile()）\ndiamonds |&gt; \n  count(color, cut) |&gt;  \n  ggplot(aes(x = color, y = cut, fill = n)) +\n  geom_tile() +\n  scale_fill_viridis_c()  # 优化颜色梯度\n\n颜色深浅直观反映频数差异，适合展示高维组合。\n例如根据上图可分析出：\n\nIdeal切工在D-G色中更常见，而J色几乎无Ideal切工。\nFair切工在低色级（I-J）占比更高。\n\n\n若要对两个数值变量的关系进行分析，有以下两种方法。\n\n过绘制（Overplotting）\n\nggplot(smaller, aes(x = carat, y = price)) + \n  geom_point(alpha = 0.01)  # 调整透明度，揭示数据密集区域\n\n\n二维分箱\n\n\n矩形分箱（geom_bin2d()）\nggplot(smaller, aes(x = carat, y = price)) +\n  geom_bin2d() +\n  scale_fill_gradient(low = \"lightblue\", high = \"darkred\")\n\n六边形分箱（geom_hex()）\nlibrary(hexbin)\nggplot(smaller, aes(x = carat, y = price)) +\n  geom_hex()  # 相邻单元过渡更自然\n\n\n\n离散化+箱线图\n\nggplot(smaller, aes(x = carat, y = price)) + \n  geom_boxplot(aes(group = cut_width(carat, 0.1)), varwidth = TRUE)\n\n\n关键参数\ncut_width(x, width)：按固定宽度分箱。\nvarwidth = TRUE：箱宽反映样本量。",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>探索性数据分析</span>"
    ]
  },
  {
    "objectID": "chapters/ch10_exploratory_data_analysis.html#模式与模型",
    "href": "chapters/ch10_exploratory_data_analysis.html#模式与模型",
    "title": "10  探索性数据分析",
    "section": "10.6 模式与模型",
    "text": "10.6 模式与模型\n当数据中出现系统性关系时，它会表现为某种模式(pattern)。发现模式后，需追问以下问题：\n\n该模式是否因巧合产生？\n如何描述该模式暗示的关系？\n这种关系的相关性强度如何？\n是否有其他变量影响该关系？\n在不同数据子组中，该关系是否不同？\n\n要解决以上问题，我们需创建模型(model)。\n比如现在对钻石进行分析，其价格（price）同时受克拉（carat）和切工（cut）影响，而克拉与切工又存在关联（高切工等级的钻石通常较小）。直接观察cut与price的关系会产生误导，因此我们建立预测模型，用克拉预测价格，提取残差并分析。残差会反映出反常的价格波动，此时再探索切工的影响。\nlibrary(tidymodels)\n\n# 对数变换后建模（更适合指数关系）\ndiamonds &lt;- diamonds |&gt;\n  mutate(\n    log_price = log(price),\n    log_carat = log(carat)\n  )\n\n# 拟合线性模型\ndiamonds_fit &lt;- linear_reg() |&gt;\n  fit(log_price ~ log_carat, data = diamonds)\n\n# 计算残差并逆变换\ndiamonds_aug &lt;- augment(diamonds_fit, new_data = diamonds) |&gt;\n  mutate(.resid = exp(.resid))  # 残差还原为原始价格尺度\n\n# 可视化残差与克拉的关系\nggplot(diamonds_aug, aes(x = carat, y = .resid)) + \n  geom_point(alpha = 0.1) +\n  labs(y = \"Price Residuals (adjusted for carat)\")\n\n根据可视化图形可发现，大克拉钻石的残差普遍更低。\n可见，创建模型后，更方便进一步确认变量间的模式。",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>探索性数据分析</span>"
    ]
  },
  {
    "objectID": "chapters/ch11_communication.html",
    "href": "chapters/ch11_communication.html",
    "title": "11  解释性图表",
    "section": "",
    "text": "11.1 引言\n通过前一章节我们知道如何分析数据，接下来就需要将自己的理解传达给他人。由于我们的受众可能不具备相关背景知识，所以要确保图表尽可能一目了然，从而帮助他们快速建立对数据的准确认知。\n简言之，目标是：将探索性图表转化为解释性图表。\n必要工具包：",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>解释性图表</span>"
    ]
  },
  {
    "objectID": "chapters/ch11_communication.html#引言",
    "href": "chapters/ch11_communication.html#引言",
    "title": "11  解释性图表",
    "section": "",
    "text": "library(tidyverse)    # 含ggplot2\nlibrary(scales)       # 调整坐标轴刻度/标签\nlibrary(ggrepel)      # 智能标签防重叠\nlibrary(patchwork)    # 多图排版",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>解释性图表</span>"
    ]
  },
  {
    "objectID": "chapters/ch11_communication.html#标签labels",
    "href": "chapters/ch11_communication.html#标签labels",
    "title": "11  解释性图表",
    "section": "11.2 标签（Labels）",
    "text": "11.2 标签（Labels）\n使用labs()为图表添加标签，增强图形可读性：\nggplot(mpg, aes(x = displ, y = hwy)) +\n  geom_point(aes(color = class)) +\n  geom_smooth(se = FALSE) +\n  labs(\n    x = \"Engine displacement (L)\",\n    y = \"Highway fuel economy (mpg)\",\n    color = \"Car type\",\n    title = \"Fuel efficiency generally decreases with engine size\",\n    subtitle = \"Two seaters (sports cars) are an exception because of their light weight\",\n    caption = \"Data from fueleconomy.gov\"\n  )\n\n图表标题的作用是概括核心内容。注意标题不能仅描述图表类型（如“发动机排量与燃油经济性的散点图”）。\n除了主标题，还有两种标签：\n\nsubtitle：在主标题下方以较小字体添加补充说明\ncaption：在图表右下角添加文字（通常用于注明数据来源）\n\n通过labs()函数也可以修改坐标轴和图例标题。建议将简短的变量名替换为更详细的描述，并包含单位信息。\n此外，还可以使用数学公式代替普通文本标签。只需将引号替换为quote()，具体语法可参考?plotmath。\ndf &lt;- tibble(\n  x = 1:10,\n  y = cumsum(x^2)\n)\n\nggplot(df, aes(x, y)) +\n  geom_point() +\n  labs(\n    x = quote(x[i]),\n    y = quote(sum(x[i]^2, i==1, n))\n  )",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>解释性图表</span>"
    ]
  },
  {
    "objectID": "chapters/ch11_communication.html#注释annotations",
    "href": "chapters/ch11_communication.html#注释annotations",
    "title": "11  解释性图表",
    "section": "11.3 注释（Annotations）",
    "text": "11.3 注释（Annotations）\n除了标签外，对个别观测值或观测值组进行注释也很有用。基础函数是geom_text()，它与geom_point()类似，但多了一个label美学属性，可以在图表中添加文字注释。\n注释有两种方法。\n第一种是使用专门准备的标注数据框。例如，我们提取每种驱动类型中发动机排量最大的车型信息：\nlabel_info &lt;- mpg |&gt;\n  group_by(drv) |&gt;\n  arrange(desc(displ)) |&gt;\n  slice_head(n = 1) |&gt;\n  mutate(\n    drive_type = case_when(\n      drv == \"f\" ~ \"front-wheel drive\",\n      drv == \"r\" ~ \"rear-wheel drive\",\n      drv == \"4\" ~ \"4-wheel drive\"\n    )\n  ) |&gt;\n  select(displ, hwy, drv, drive_type)\n\nlabel_info\n#&gt; # A tibble: 3 × 4\n#&gt; # Groups:   drv [3]\n#&gt;   displ   hwy drv   drive_type       \n#&gt;   &lt;dbl&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt;            \n#&gt; 1   6.5    17 4     4-wheel drive    \n#&gt; 2   5.3    25 f     front-wheel drive\n#&gt; 3   7      24 r     rear-wheel drive\n然后直接在图表上标注这三组数据，用注释代替图例。通过调整字体大小(size)和粗细(fontface)可以突出注释：\nggplot(mpg, aes(x = displ, y = hwy, color = drv)) +\n  geom_point(alpha = 0.3) +\n  geom_smooth(se = FALSE) +\n  geom_text(\n    data = label_info,\n    aes(label = drive_type),\n    fontface = \"bold\", size = 5, hjust = \"right\", vjust = \"bottom\" # 控制标注对齐\n  ) +\n  theme(legend.position = \"none\")  # 隐藏图例\n\n注意到注释与散点重叠，此时可以使用ggrepel包的geom_label_repel()自动调整位置：\nggplot(mpg, aes(x = displ, y = hwy, color = drv)) +\n  geom_point(alpha = 0.3) +\n  geom_smooth(se = FALSE) +\n  geom_label_repel(\n    data = label_info,\n    aes(label = drive_type),\n    fontface = \"bold\", size = 5,\n    nudge_y = 2  # 垂直偏移\n  ) +\n  theme(legend.position = \"none\")\n\n结合geom_text_repel()和特殊标记则可以突出异常点：\npotential_outliers &lt;- mpg |&gt; filter(hwy &gt; 40 | (hwy &gt; 20 & displ &gt; 5))\n\nggplot(mpg, aes(x = displ, y = hwy)) +\n  geom_point() +\n  geom_text_repel(data = potential_outliers, aes(label = model)) +\n  geom_point(\n    data = potential_outliers, \n    color = \"red\", size = 3, shape = \"circle open\"  # 空心红圈标记\n  )\n\n其他标注特殊点的方法：\n\n参考线：使用geom_hline()/geom_vline()\n矩形标记：使用geom_rect()或ggforce::geom_mark_hull()\n箭头指示：使用geom_segment(arrow = arrow())\n\n注释的第二种方法是使用annotate函数。\nannotate()适合添加少量独立标注元素。例如添加趋势说明：\ntrend_text &lt;- \"Larger engine sizes tend to have lower fuel economy.\" |&gt;\n  str_wrap(width = 30)\ntrend_text\n#&gt; [1] \"Larger engine sizes tend to\\nhave lower fuel economy.\"\nggplot(mpg, aes(x = displ, y = hwy)) +\n  geom_point() +\n  annotate(\n    geom = \"label\", x = 3.5, y = 38,\n    label = trend_text,\n    hjust = \"left\", color = \"red\"\n  ) +\n  annotate(\n    geom = \"segment\",\n    x = 3, y = 35, xend = 5, yend = 25, color = \"red\", # 给箭头定位\n    arrow = arrow(type = \"closed\")\n  )",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>解释性图表</span>"
    ]
  },
  {
    "objectID": "chapters/ch11_communication.html#比例尺scales",
    "href": "chapters/ch11_communication.html#比例尺scales",
    "title": "11  解释性图表",
    "section": "11.4 比例尺（Scales）",
    "text": "11.4 比例尺（Scales）\n比例尺也可调整美学映射的视觉表现形式。\n\n11.4.1 默认比例\nggplot2 默认添加的比例尺如下：\nggplot(mpg, aes(x = displ, y = hwy)) +\n  geom_point(aes(color = class)) +\n  scale_x_continuous() +\n  scale_y_continuous() +\n  scale_color_discrete()\n命名规则：scale_ + 美学名称（如 x、color） + _ + 比例尺类型（如 continuous、discrete）。\n\ncontinuous 表示将数值以连续刻度形式映射。\ndiscrete 表示基于每个离散变量类别进行分配。\n\n默认比例尺适用于大多数情况。\n\n\n11.4.2 轴刻度和图例键\n坐标轴和图例统称为引导元素（guides）。其中坐标轴用于呈现x和y美学映射，而图例则负责展示其他所有美学映射。\n影响坐标轴刻度线和图例显示的两个主要参数是： breaks 和 labels。breaks参数用于控制刻度线的位置或与图例相关联的数值；labels参数则控制每个刻度线或图例对应的文本标签。\n以下分别为例：\n# break修改y轴刻度间隔\nggplot(mpg, aes(x = displ, y = hwy)) +\n  geom_point() +\n  scale_y_continuous(breaks = seq(15, 40, by = 5))\n\nggplot(mpg, aes(x = displ, y = hwy, color = drv)) +\n  geom_point() +\n  scale_x_continuous(labels = NULL) +\n  scale_y_continuous(labels = NULL) +\n  scale_color_discrete(labels = c(\"4\" = \"4-wheel\", \"f\" = \"front\", \"r\" = \"rear\"))\n\nlabels参数与scales包中的标签格式化函数结合使用时，能有效实现数值的货币化（如添加美元符号）、百分比化等格式转换。比如label_dollar()函数效果如下，通过将美元数值除以1000并添加”K”，同时自定义刻度间隔点（breaks参数仍基于原始标度设置）。\nlibrary(scales)\nggplot(diamonds, aes(x = price, y = cut)) +\n  geom_boxplot() +\n  scale_x_continuous(labels = label_dollar(scale = 1/1000, suffix = \"K\"))\n\n另一个实用的函数是 label_percent()，将标签改为百分比形式。\nggplot(diamonds, aes(x = cut, fill = clarity)) +\n  geom_bar(position = \"fill\") +\n  scale_y_continuous(name = \"Percentage\", labels = label_percent())\n\n另外，breaks 参数还有另一个用途。当数据点较少时可精确标注观测值位置。以展示美国总统任期起止时间的图表为例：\npresidential |&gt;\n  mutate(id = 33 + row_number()) |&gt;\n  ggplot(aes(x = start, y = id)) +\n  geom_point() +\n  geom_segment(aes(xend = end, yend = id)) +\n  scale_x_date(name = NULL, breaks = presidential$start, date_labels = \"'%y\")\n\n\n\n11.4.3 图例布局\nbreaks和labels参数最常用于调整坐标轴，虽然它们也可用于图例，但图例调整通常需要其他方法。\n控制图例整体位置需使用theme()设置（在本章末尾详述，它主要用于控制图形的非数据元素）。通过theme()的legend.position参数可指定图例位置：\nbase &lt;- ggplot(mpg, aes(x = displ, y = hwy)) +\n  geom_point(aes(color = class))\n\n# 默认右侧显示\nbase + theme(legend.position = \"right\")  \n# 左侧显示\nbase + theme(legend.position = \"left\")\n# 顶部显示并控制图例分3行排列\nbase + theme(legend.position = \"top\") +\n  guides(color = guide_legend(nrow = 3))\n# 底部显示并控制图例分3行排列\nbase + theme(legend.position = \"bottom\") +\n  guides(color = guide_legend(nrow = 3))\n布局建议：\n\n宽幅图形建议图例置于顶部或底部\n窄幅图形建议图例置于左侧或右侧\n使用legend.position = \"none\"可完全隐藏图例\n\n通过guides()配合guide_legend()或guide_colorbar()可控制单个图例显示。以下示例展示两个关键设置：\n\n用nrow更改图例行数\n用override.aes更改美学设置（如增大图例点大小）\n\nggplot(mpg, aes(x = displ, y = hwy)) +\n  geom_point(aes(color = class), alpha = 0.5) +  # 半透明显示密集点\n  geom_smooth(se = FALSE) +\n  theme(legend.position = \"bottom\") +\n  guides(color = guide_legend(\n    nrow = 2, \n    override.aes = list(size = 4)  # 图例点尺寸设为4倍\n  ))\n\n\n特别注意：guides()中的参数名称必须与对应的美学映射名称完全匹配。\n\n\n\n11.4.4 替换比例尺\n除了微调参数外，还可以直接替换整个比例尺。最常需要替换的比例尺主要有两种：连续位置比例尺和颜色比例尺。\n1. 连续位置比例尺\n使用对数变换（保留原始刻度标签）：\nggplot(diamonds, aes(x = carat, y = price)) +\n  geom_point() +\n  scale_x_log10() + \n  scale_y_log10()\n\n\n\nPlot of price versus carat of diamonds. Data binned and the color of the rectangles representing each bin based on the number of points that fall into that bin. The axis labels are on the original data scale.\n\n\n2. 颜色比例尺\n\n离散型：使用 ColorBrewer 调色板（对色盲友好）：\nggplot(mpg, aes(x = displ, y = hwy)) +\n  geom_point(aes(color = drv)) +\n  scale_color_brewer(palette = \"Set1\") # 适配红绿色盲\n当需要自定义数值与颜色的映射关系时，应使用 scale_color_manual()。例如在总统政党数据可视化中，红色代表共和党，蓝色代表民主党，可以写成：\nscale_color_manual(values = c(Republican = \"#E81B23\", Democratic = \"#00AEF3\")\n连续型：使用内置的 scale_color_gradient() 或 scale_fill_gradient() 函数。如果需要发散的（diverging）颜色比例尺，则应当使用 scale_color_gradient2()，该函数允许为正负值分配不同颜色（例如区分高于或低于均值的数据点）。\n另一个推荐方案是采用 viridis 色标体系。设计者 Nathaniel Smith 和 Stéfan van der Walt 精心打造的这些连续色标具有以下特性：\n\n适配各类色盲患者的视觉需求\n在彩色和黑白模式下均保持感知均匀性\n在 ggplot2 中提供三种变体：\n\n连续型（后缀 _c）\n离散型（后缀 _d）\n分箱型（后缀 _b）\n\n\n应用示例如下：\ndf &lt;- tibble(\n  x = rnorm(10000),\n  y = rnorm(10000)\n)\n\nggplot(df, aes(x, y)) +\n  geom_hex() +\n  coord_fixed() +\n  labs(title = \"Default, continuous\", x = NULL, y = NULL)\n\nggplot(df, aes(x, y)) +\n  geom_hex() +\n  coord_fixed() +\n  scale_fill_viridis_b() +\n  labs(title = \"Viridis, binned\", x = NULL, y = NULL)\n\n\n\n\n\n11.4.5 缩放视图\n控制图形显示范围主要有两个方法：\n\n调整绘图数据范围\n设置比例尺限制\n\n比如当分别绘制SUV和小轿车的油耗数据时，两张图的坐标轴范围和图例显示不一致，SUV的x轴范围是4.0-6.5，轿车则是1.8-4.0；且图例也不同，SUV只有四驱和后驱，轿车只有前驱和四驱。两张图不能直接比较，需进行标度统一。\n# 创建共享比例尺\nx_scale &lt;- scale_x_continuous(limits = range(mpg$displ))\ny_scale &lt;- scale_y_continuous(limits = range(mpg$hwy))\ncol_scale &lt;- scale_color_discrete(limits = unique(mpg$drv))\n\n# 应用至分面图形\nggplot(suv, aes(displ, hwy, color = drv)) +\n  geom_point() +\n  x_scale + y_scale + col_scale\n\nggplot(compact, aes(displ, hwy, color = drv)) +\n  geom_point() +\n  x_scale + y_scale + col_scale",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>解释性图表</span>"
    ]
  },
  {
    "objectID": "chapters/ch11_communication.html#主题themes",
    "href": "chapters/ch11_communication.html#主题themes",
    "title": "11  解释性图表",
    "section": "11.5 主题（Themes）",
    "text": "11.5 主题（Themes）\n主题（theme）用于自定义图表的非数据元素（如背景、网格线、字体等）。\nggplot2 提供8种内置主题，默认是 theme_gray()。常用主题包括：\n\n\n\n主题函数\n效果描述\n\n\n\n\ntheme_gray()\n灰色背景（默认）\n\n\ntheme_bw()\n白色背景 + 灰色网格线\n\n\ntheme_classic()\n经典风格（无网格线，仅坐标轴）\n\n\ntheme_minimal()\n极简风格（无背景和边框）\n\n\ntheme_void()\n完全空白（仅显示几何对象）\n\n\n\n通过 theme() 函数可以精细控制图表外观，例如：\n\n调整图例\n\nggplot(mpg, aes(x = displ, y = hwy, color = drv)) +\n  geom_point() +\n  theme(\n    legend.position = c(0.6, 0.7),  # 图例位置（坐标范围0~1）\n    legend.direction = \"horizontal\", # 图例水平排列\n    legend.box.background = element_rect(color = \"black\")  # 图例边框\n  )\n\n坐标轴和网格线\n\ntheme(\n  axis.text.x = element_text(angle = 45, hjust = 1),  # X轴标签旋转45度\n  panel.grid.major = element_line(color = \"gray80\"),  # 主网格线颜色\n  panel.background = element_rect(fill = \"white\")     # 绘图区背景色\n要快速预览当前主题效果可用如下函数：\nggplot2::theme_get()",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>解释性图表</span>"
    ]
  },
  {
    "objectID": "chapters/ch11_communication.html#多图布局layout",
    "href": "chapters/ch11_communication.html#多图布局layout",
    "title": "11  解释性图表",
    "section": "11.6 多图布局（Layout）",
    "text": "11.6 多图布局（Layout）\n当需要将多个图表组合成一个图形时，可以使用 patchwork 包。\n\n让两个子图合并，并排显示\n\nlibrary(patchwork)\nlibrary(ggplot2)\n\n# 创建两个图表对象\np1 &lt;- ggplot(mpg, aes(x = displ, y = hwy)) + \n  geom_point() + \n  labs(title = \"散点图：发动机排量 vs. 油耗\")\n\np2 &lt;- ggplot(mpg, aes(x = drv, y = hwy)) + \n  geom_boxplot() + \n  labs(title = \"箱线图：驱动类型 vs. 油耗\")\n\n# 并排显示\np1 + p2\n\n复杂布局（| 和 /)\n\np3 &lt;- ggplot(mpg, aes(x = cty, y = hwy)) + \n  geom_point() + \n  labs(title = \"散点图：城市油耗 vs. 高速油耗\")\n\n(p1 | p3) / p2\n# 第一行：p1 | p3，第二行：p2\n\n\n| 横向排列，/ 纵向排列\n用括号 () 明确分组优先级\n\n\n\n统一图例、定义尺寸\n\n通过 plot_layout(guides = \"collect\") 合并多个子图的图例，并用 & theme() 统一调整位置：\n(p1 + p2 + p3) + \n  plot_layout(guides = \"collect\") &  # 合并所有图例\n  theme(legend.position = \"top\")    # 图例置顶\n\n运算符区别：\n\n+添加图层或组合子图\n&批量修改主题（适用于 patchwork 全局）\n\n\n拼图的图例区域称为（guide_area），是专门为图例预留的区域，通常与顶部布局结合：\n(guide_area() / (p1 + p2)) +  # 图例在上，p1和p2在下\n  plot_layout(guides = \"collect\", heights = c(1, 4))  # 图例区高度1，主图区高度4\n另外还可自定义子图尺寸，通过 heights 和 widths 按比例分配空间：\n(p1 | p2 | p3) + \n  plot_layout(\n    widths = c(2, 1, 1),  # 第一个图宽度占2份\n    heights = c(3, 2)      # 适用于纵向布局\n  )",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>解释性图表</span>"
    ]
  },
  {
    "objectID": "chapters/ch12_logical_vectors.html",
    "href": "chapters/ch12_logical_vectors.html",
    "title": "12  逻辑向量",
    "section": "",
    "text": "12.1 引言\n逻辑向量中的元素只有三种值：TRUE、FALSE、NA。\n本章用到下列R包：",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>逻辑向量</span>"
    ]
  },
  {
    "objectID": "chapters/ch12_logical_vectors.html#引言",
    "href": "chapters/ch12_logical_vectors.html#引言",
    "title": "12  逻辑向量",
    "section": "",
    "text": "library(tidyverse)\nlibrary(nycflights13) #航班数据",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>逻辑向量</span>"
    ]
  },
  {
    "objectID": "chapters/ch12_logical_vectors.html#比较运算",
    "href": "chapters/ch12_logical_vectors.html#比较运算",
    "title": "12  逻辑向量",
    "section": "12.2 比较运算",
    "text": "12.2 比较运算\n创建逻辑向量的最常用方法是使用比较运算符：&lt;、&lt;=、&gt;、&gt;=、!= 和 ==。\n比如在filter()函数中的比较运算符用于筛选数据：\nflights |&gt; \n  filter(dep_time &gt; 600 & dep_time &lt; 2000 & abs(arr_delay) &lt; 20)\n或者在mutate()函数中用于限定：\nflights |&gt; \n  mutate(\n    daytime = dep_time &gt; 600 & dep_time &lt; 2000,\n    approx_ontime = abs(arr_delay) &lt; 20,\n    .keep = \"used\"\n  )\n在进行比较运算时，注意与浮点数相关的运算不能用==，因为计算机表示小数时存在精度误差。错误示范：\nx &lt;- c(1 / 49 * 49, sqrt(2) ^ 2)\nx == c(1, 2)\n#&gt; [1] FALSE FALSE\n解决方法是使用 dplyr::near() 函数，可忽略极小的数值差异：\nnear(x, c(1, 2))\n#&gt; [1] TRUE TRUE\nNA表示”未知“，与其相关的比较运算结果都是NA：\nNA &gt; 5        #&gt; NA\n10 == NA      #&gt; NA\nNA == NA      #&gt; NA （不表示相等，而是“未知是否相等”）\n因此，不能用 == NA 检测缺失值。如下代码无效：\nflights |&gt; filter(dep_time == NA)\n#&gt; 返回0行，因为 dep_time == NA 得到 NA，filter 会忽略\n要检测缺失值要使用is.na()函数，比如：\nis.na(c(TRUE, NA, FALSE))   #&gt; FALSE TRUE FALSE\nis.na(c(1, NA, 3))          #&gt; FALSE TRUE FALSE\nis.na()函数可用于辅助排序：\n# 将 NA 排在前面\nflights |&gt; \n  filter(month == 1, day == 1) |&gt; \n  arrange(desc(is.na(dep_time)), dep_time)",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>逻辑向量</span>"
    ]
  },
  {
    "objectID": "chapters/ch12_logical_vectors.html#布尔代数",
    "href": "chapters/ch12_logical_vectors.html#布尔代数",
    "title": "12  逻辑向量",
    "section": "12.3 布尔代数",
    "text": "12.3 布尔代数\n使用布尔代数可将多个逻辑向量进行组合。\n\n&：与（and）\n|：或（or）\n!：非（not）\nxor()：异或（exclusive or）\n\n\n另外还有&&和||，但它们是短路逻辑操作符，只返回一个布尔值，故适用于编程控制流（如 if 语句），而非数据分析。\n在布尔运算中，与NA相关的运算颇为抽象，如下：\n\nNA | TRUE = TRUE：因为 NA 可能是 TRUE，总有一项为真；\nNA | FALSE = NA：因为结果取决于 NA 的真假，无法确定；\nNA & TRUE = NA：是否为真依赖 NA 的真假，无法确定；\nNA & FALSE = FALSE：一项为假，整体为假。\n\n书写布尔代数表达式时注意不要用日常说话的语序，比如若要筛选11月或12月的航班，错误示例：\nflights |&gt; filter(month == 11 | 12)\n正确写法：\nflights |&gt; filter(month == 11 | month == 12)\n或更推荐：\nflights |&gt; filter(month %in% c(11, 12))\nx %in% y 判断 x 中的每个元素是否在向量 y 中，返回逻辑向量。等价于多个 == 和 | 联合使用，但语法更简洁，逻辑更清晰。比如：\n1:12 %in% c(1, 5, 11)\n#&gt; TRUE FALSE ... TRUE ... TRUE\n同时注意与NA相关的运算，比如：\nc(1, 2, NA) %in% NA\n#&gt; FALSE FALSE TRUE",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>逻辑向量</span>"
    ]
  },
  {
    "objectID": "chapters/ch12_logical_vectors.html#逻辑汇总",
    "href": "chapters/ch12_logical_vectors.html#逻辑汇总",
    "title": "12  逻辑向量",
    "section": "12.4 逻辑汇总",
    "text": "12.4 逻辑汇总\n\n逻辑汇总函数\nany(x) 相当于逻辑“或”，只要 x 中存在任意一个 TRUE 就返回 TRUE。 all(x) 相当于逻辑“与”，只有当 x 中所有值都是 TRUE 时才返回 TRUE。\n数值汇总函数\n逻辑向量在数值情境下会自动转换：TRUE 变成 1，FALSE 变成 0。从而可用sum() 统计 TRUE 的个数，mean() 计算 TRUE 的比例\n逻辑子集筛选\n逻辑向量可以用来对单个变量进行子集筛选，主要利用中括号[]。形如：\narr_delay[arr_delay &lt; 0]",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>逻辑向量</span>"
    ]
  },
  {
    "objectID": "chapters/ch12_logical_vectors.html#条件转换",
    "href": "chapters/ch12_logical_vectors.html#条件转换",
    "title": "12  逻辑向量",
    "section": "12.5 条件转换",
    "text": "12.5 条件转换\n若想在某个条件为 TRUE 时使用一个值，为 FALSE 时使用另一个值时，可以使用 dplyr::if_else()函数。\n主要用 if_else() 前三个参数：\n\ncondition ：逻辑向量；\n&lt;true&gt; ：条件为 TRUE 时输出的值或向量；\n&lt;false&gt; ：条件为 FALSE 时输出的值或向量。\n\n例如：\n&gt; x &lt;- c(-2:2, NA)\n&gt; if_else(x &gt; 0, \"非负\", \"负\")\n[1] \"负\"   \"负\"   \"负\"   \"非负\" \"非负\" NA \n可选的第四个参数称为为 missing，可用自定义值替换NA 值：\n&gt; if_else(x &gt; 0, \"非负\", \"负\", \"secret\")\n[1] \"负\"    \"负\"    \"负\"    \"非负\"  \"非负\"  \"secret\"\n还有一种条理更清晰的函数case_when()，使用方式为：条件 ~ 输出，类似分段函数。\n&gt; case_when(\n+     x == 0   ~ \"0\",\n+     x &lt; 0    ~ \"-\", \n+     x &gt; 0    ~ \"+\",\n+     is.na(x) ~ \"secret\"\n+ )\n[1] \"-\"      \"-\"      \"0\"      \"+\"      \"+\"     \"secret\"\n若想提供默认值，可使用 .default = \"&lt;默认值&gt;\"\n如果有多个条件同时为 TRUE，只会对应第一个匹配的。\n需要注意，TRUE和FALSE对应输出的值必须兼容，比如字符串和数值不兼容。以下为常见的兼容类型：\n\n数值与逻辑向量兼容\n字符串与因子类型兼容\nNA 与所有类型兼容",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>逻辑向量</span>"
    ]
  },
  {
    "objectID": "chapters/ch13_numbers.html",
    "href": "chapters/ch13_numbers.html",
    "title": "13  数值处理",
    "section": "",
    "text": "13.1 引言\n数值向量是数据科学的核心，本章系统学习它们在 R 中的用法。\n本章需要用到以下R包：",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>数值处理</span>"
    ]
  },
  {
    "objectID": "chapters/ch13_numbers.html#引言",
    "href": "chapters/ch13_numbers.html#引言",
    "title": "13  数值处理",
    "section": "",
    "text": "library(tidyverse)\nlibrary(nycflights13) #航班数据",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>数值处理</span>"
    ]
  },
  {
    "objectID": "chapters/ch13_numbers.html#创建数值",
    "href": "chapters/ch13_numbers.html#创建数值",
    "title": "13  数值处理",
    "section": "13.2 创建数值",
    "text": "13.2 创建数值\n大多数情况下，数值会以 R 的标准数值类型（如 integer 或 double）形式存在。但有时会遇到字符串形式的数字，可能是从列名透视过来的数据，或者数据导入过程中出现了错误。\nreadr 包提供了两个函数可将字符串转换为数值：parse_double() 和 parse_number()。\n\n如果字符串是纯数字（可含有小数点或科学计数法），使用 parse_double()：\n\nx &lt;- c(\"1.2\", \"5.6\", \"1e3\")\nparse_double(x)\n#&gt; [1]    1.2    5.6 1000.0\n\n如果字符串中包含需忽略的非数字字符（如货币符号或百分号），使用 parse_number()：\n\nx &lt;- c(\"$1,234\", \"USD 3,513\", \"59%\")\nparse_number(x)\n#&gt; [1] 1234 3513   59",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>数值处理</span>"
    ]
  },
  {
    "objectID": "chapters/ch13_numbers.html#计数",
    "href": "chapters/ch13_numbers.html#计数",
    "title": "13  数值处理",
    "section": "13.3 计数",
    "text": "13.3 计数\n数据分析仅靠简单计数和基础运算就能完成很多工作。因此 dplyr 提供了极为便捷的 count() 函数，能快速在数据分析中统计频次，结果将显示每个目的地（dest）对应的航班数量（n）：\nflights |&gt; count(dest)\n#&gt; # A tibble: 105 × 2\n#&gt;   dest      n\n#&gt;   &lt;chr&gt; &lt;int&gt;\n#&gt; 1 ABQ     254\n#&gt; 2 ACK     265\n#&gt; ...\n\n尽管第 4 章建议分行书写长命令，但 count() 一般用于交互式快速查看，因此常将其写在一行中。\n\n想查看出现次数最多的前几项，可以加上 sort = TRUE：\nflights |&gt; count(dest, sort = TRUE)\n#&gt;   dest      n\n#&gt; 1 ORD   17283\n#&gt; 2 ATL   17215\n#&gt; 3 LAX   16174\n#&gt; ...\n如果想一次性查看全部值，可以使用 flights |&gt; View() 打开交互窗口，或 flights |&gt; print(n = Inf) 输出全部结果。\n除了 count()，也可以手动组合 group_by()、summarize() 和 n() 来完成相同操作。这种方式更灵活，可以同时进行其他统计：\nflights |&gt; \n  group_by(dest) |&gt; \n  summarize(\n    n = n(),\n    delay = mean(arr_delay, na.rm = TRUE)\n  )\n这里 n() 是一个特殊的汇总函数，不需要任何参数，它会统计当前分组的行数。它只能在 dplyr 的函数（如 mutate()、filter()、summarize()）中使用，否则会报错：\nn()\n#&gt; Error: Must only be used inside data-masking verbs like `mutate()`, `filter()`, and `group_by()`.\n另外还有n_distinct(x)函数统计某变量中特定值的数量。例如，想知道哪些目的地有最多航空公司服务，如下可列出各个目的地以及服务它的不同航空公司数量。：\nflights |&gt; \n  group_by(dest) |&gt; \n  summarize(carriers = n_distinct(carrier)) |&gt; \n  arrange(desc(carriers))\n有时还需要对某个变量进行“加权计数”，本质上就是求和。例如，可以统计每架飞机飞行的总里程：\nflights |&gt; \n  group_by(tailnum) |&gt; \n  summarize(miles = sum(distance))\ncount() 函数也支持这种加权方式，通过 wt 参数实现：\nflights |&gt; count(tailnum, wt = distance)\n若要统计缺失值的数量，可以结合 sum() 和 is.na()。比如通过判断出发时间是否缺失，统计每个目的地取消的航班数量：\nflights |&gt; \n  group_by(dest) |&gt; \n  summarize(n_cancelled = sum(is.na(dep_time)))",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>数值处理</span>"
    ]
  },
  {
    "objectID": "chapters/ch13_numbers.html#数值变换",
    "href": "chapters/ch13_numbers.html#数值变换",
    "title": "13  数值处理",
    "section": "13.4 数值变换",
    "text": "13.4 数值变换\n对于基本运算，R中存在“扩展规则”，当两个向量进行基本运算时，若向量所含元素数目不相同， R 会将少元素向量自动扩展（recycle）与另一向量一样长，从而逐个元素进行计算。举例如下：\nx &lt;- c(1, 2, 10, 20)\nx / 5\n# 等价于\nx / c(5, 5, 5, 5)\n#&gt; [1] 0.2 0.4 2.0 4.0\n只有当较长向量的长度是较短向量的整数倍时才不会报错或发出警告：\nx * c(1, 2)\n#&gt; [1]  1  4 10 40\n\nx * c(1, 2, 3)\n#&gt; Warning: longer object length is not a multiple of shorter\n#&gt; [1]  1  4 30 20\n此规则同样适用于逻辑比较（==、&lt;、!= 等）。如果不小心用 == 代替 %in%，并且数据框的行数刚好是“错误的倍数”，就可能出现悄无声息的逻辑错误：\nflights |&gt; filter(month == c(1, 2))  # 本想选出1月和2月的航班\n这段代码实际上会选出奇数行中 month == 1 的航班、偶数行中 month == 2 的航班，但不会报错！因为 flights 的行数正好是 2 的倍数，自发执行扩展规则。这种“沉默的失败”是数据分析中最难察觉的陷阱之一。\n\n区分==和%in%：\n\n== 是逐个元素一一比较，用于判断两个向量的对应位置元素是否相等：\n\nc(1, 2, 3) == c(2, 3, 4)\n#&gt; [1] FALSE FALSE FALSE\n\n%in% 是用来判断是否属于的：\n\nc(1, 2, 3) %in% c(2, 3, 4)\n#&gt; [1] FALSE  TRUE  TRUE\n\n除了基本运算，还可以用 pmin() 和 pmax() 来逐行求最小值或最大值：\ndf &lt;- tribble(\n  ~x, ~y,\n  1,  3,\n  5,  2,\n  7, NA\n)\n\ndf |&gt; mutate(\n  min = pmin(x, y, na.rm = TRUE),\n  max = pmax(x, y, na.rm = TRUE)\n)\n区别在于：\n\npmin()/pmax()：按行比较返回每行的最小/最大值\nmin()/max()：整体取最小/最大，会返回一个标量\n\n另外，模运算（modular arithmetic）是处理“整除和余数”的工具。在 R 中：\n\n%/% 表示整除，取商\n%% 表示取余\n\n1:10 %/% 3\n#&gt; [1] 0 0 1 1 1 2 2 2 3 3\n\n1:10 %% 3\n#&gt; [1] 1 2 0 1 2 0 1 2 0 1\n以及对数变换，广泛用于：缩放数量级差异较大的数据，或将指数增长转化为线性增长。\nR 提供了三种对数函数：\n\nlog()：自然对数（以 e 为底）\nlog2()：以 2 为底\nlog10()：以 10 为底\n\n对应的反函数：\n\nexp()：log() 的反函数\n2^x、10^x：分别为 log2() 和 log10() 的反函数\n\n要对运算结果进行四舍五入，可使用 round() 函数，默认取整：\nround(123.456)  # [1] 123\n可以用第二个参数 digits 控制小数位数：\nround(123.456, 2)  # 保留两位小数 -&gt; 123.46\nround(123.456, -2) # 取整到百位 -&gt; 100\n注意，R 默认采用“四舍六入，五取偶”的修约策略，如下为例：\n&gt; round(1.35,1)\n[1] 1.4\n&gt; round(1.45,1)\n[1] 1.4\n此外还有：\n\nfloor(x)：向下取整\nceiling(x)：向上取整\n\n这些函数没有 digits 参数，因此要通过缩放再还原的方式控制小数精度：\n# 向下保留两位小数\nfloor(x / 0.01) * 0.01\n# 向上保留两位小数\nceiling(x / 0.01) * 0.01\n可使用 cut() 可以将连续变量划分为多个区间（分箱）：\nx &lt;- c(1, 2, 5, 10, 15, 20)\ncut(x, breaks = c(0, 5, 10, 15, 20))\n#&gt; [1] (0,5]   (0,5]   (0,5]   (5,10]  (10,15] (15,20]\n也可以给每一段设置分段标签：\ncut(x, breaks = c(0, 5, 10, 15, 20), \n    labels = c(\"sm\", \"md\", \"lg\", \"xl\"))\n超出分段范围的值会返回 NA：\nx &lt;- c(1, 2, 5, 10, 15, 30)\ncut(x, breaks = c(0, 5, 10, 15, 20))\n#&gt; [1] (0,5]   (0,5]   (0,5]   (5,10]  (10,15] &lt;NA&gt;   \n还可以通过参数控制区间是否包含端点，如：\n\nright = FALSE 表示区间是 [a, b)\ninclude.lowest = TRUE 表示包括最小值\n\n此外，base R 提供了常见的累积函数：\n\ncumsum()：累加\ncumprod()：累乘\ncummin()：累积最小\ncummax()：累积最大\n\ndplyr 还提供了 cummean() 用于计算累积平均值。\nx &lt;- 1:10\ncumsum(x)\n#&gt; [1] 1 3 6 10 15 21 28 36 45 55\ncummean(x)\n#&gt; [1] 1.0 1.5 2.0 2.5 3.0 3.5 4.0 4.5 5.0 5.5",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>数值处理</span>"
    ]
  },
  {
    "objectID": "chapters/ch13_numbers.html#通用变换",
    "href": "chapters/ch13_numbers.html#通用变换",
    "title": "13  数值处理",
    "section": "13.5 通用变换",
    "text": "13.5 通用变换\ndplyr 提供了一系列参考 SQL 的排名函数，比如 min_rank()从小到大排名，且处理并列值的方法符合常理。\nx &lt;- c(1, 2, 2, 3, 4, NA)\nmin_rank(x)\n#&gt; [1]  1  2  2  4  5 NA\n若想从大到小，可追加使用 desc(x)：\nmin_rank(desc(x))\n#&gt; [1]  5  3  3  2  1 NA\n还有以下变体函数：\n\nrow_number()：不保留并列，按顺序排名相同值\ndense_rank()：将并列的若干值视为一体，下一个名次不跳号\npercent_rank()：按百分比标准化排名\ncume_dist()：累计分布，表示当前值小于等于多少比例\n\n这些函数的行为类似于 base R 的 rank()，可通过设置 ties.method 和 na.last = \"keep\" 来实现同样的功能。\n此外，在 dplyr 管道中使用 row_number() 不带参数时，表示“当前行号”。结合 %/% 与 %% 可以实现按行号分组，例如：\ndf &lt;- tibble(id = 1:10)\ndf |&gt; mutate(\n  row0 = row_number() - 1,\n  three_groups = row0 %% 3,         # 三组标记（循环编号）\n  three_in_each_group = row0 %/% 3  # 每组3个（等分分组）\n)\nlead()函数可以将当前向量向前移动一定单位，默认1位，加上参数 n 可实现多位偏移； lag()则向后移动。返回向量长度与输入一致，并在开头或结尾填充 NA：\nx &lt;- c(2, 5, 11, 11, 19, 35)\nlag(x)\n#&gt; [1] NA  2  5 11 11 19\nlead(x)\n#&gt; [1]  5 11 11 19 35 NA\n有时需要在满足某个条件时开始新的分组。例如，分析网站访问行为时，若两次访问间隔超过某一阈值（如5分钟），就认为是新的访问会话：\nevents &lt;- tibble(time = c(0, 1, 2, 3, 5, 10, 12, 15, 17, 19, 20, 27, 28, 30))\n\nevents &lt;- events |&gt; mutate(\n  diff = time - lag(time, default = first(time)),\n  has_gap = diff &gt;= 5\n)\n生成的 has_gap 是逻辑值，表示是否存在5分钟间隔。接下来使用 cumsum() 为每段会话生成连续编号：\nevents |&gt; mutate(group = cumsum(has_gap))\n另一个办法是使用 consecutive_id()，此函数给连续的相同元素编相同的号：\ndf &lt;- tibble(\n  x = c(\"a\", \"a\", \"a\", \"b\", \"c\", \"c\", \"d\", \"e\", \"a\", \"a\", \"b\", \"b\"),\n  y = c(1, 2, 3, 2, 4, 1, 3, 9, 4, 8, 10, 199)\n)\n\ndf |&gt; \n  group_by(id = consecutive_id(x)) |&gt; \n  slice_head(n = 1)  # 保留每一组重复元素的第一个\n\n13.5.0.1 13.6 数值函数\n下面总结不同数值函数的用途与适用场景。\n\nmean(): 平均数，对极端值敏感，适合对称分布。\nmedian(): 中位数，不受极端值影响，适合偏态分布。\nmin() / max(): 最小/最大值；\nquantile(x, p): 分位数，常用于排除极端值影响。p取值为[0,1]。\nsd(x): 标准差，衡量总体波动。\nIQR(x): 四分位距 = Q3 - Q1，衡量中间 50% 数据的跨度。\nfirst(x) / last(x) / nth(x, n): 提取每组数据中的第一个、最后一个、第 n 个元素。支持以下参数：\n\nna_rm = TRUE：跳过缺失值；\ndefault = ...：位置不存在时提供默认值；\norder_by = ...：更改排序方式；\n\n\n以上函数不仅用于 summarize()，也常用于 mutate() 实现标准化变换：\n\n\n\n变换形式\n效果\n\n\n\n\nx / sum(x)\n转换为比例\n\n\n(x - mean(x)) / sd(x)\n转换为标准分数（Z-score）\n\n\n(x - min(x)) / (max(x) - min(x))\n归一化到 [0, 1]\n\n\nx / first(x)\n转换为指数增长（以首值为基准）",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>数值处理</span>"
    ]
  },
  {
    "objectID": "chapters/ch14_strings.html",
    "href": "chapters/ch14_strings.html",
    "title": "14  字符串处理",
    "section": "",
    "text": "14.1 引言\n本章深入介绍如何创建、处理和提取字符串，重点使用 stringr 包（属于tidyverse）提供的一系列以 str_ 开头的函数。\n本章需要用到以下R包：",
    "crumbs": [
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>字符串处理</span>"
    ]
  },
  {
    "objectID": "chapters/ch14_strings.html#引言",
    "href": "chapters/ch14_strings.html#引言",
    "title": "14  字符串处理",
    "section": "",
    "text": "ibrary(tidyverse)\nlibrary(babynames)  # 婴儿名字数据",
    "crumbs": [
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>字符串处理</span>"
    ]
  },
  {
    "objectID": "chapters/ch14_strings.html#创建字符串",
    "href": "chapters/ch14_strings.html#创建字符串",
    "title": "14  字符串处理",
    "section": "14.2 创建字符串",
    "text": "14.2 创建字符串\n字符串可使用单引号或双引号创建，一般情况建议统一使用双引号：\nstring1 &lt;- \"This is a string\"\nstring2 &lt;- 'Use single quotes if the string contains \"quotes\"'\n若未闭合引号，控制台将显示 + 作为继续提示，按 Esc 可退出。\n若字符串中包含引号或反斜杠 \\，需使用转义字符：\ndouble_quote &lt;- \"\\\"\"  # 双引号\nsingle_quote &lt;- '\\''  # 单引号\nbackslash &lt;- \"\\\\\"     # 反斜杠\n注意：R 打印时会自动显示转义字符，但真实内容并不包含它们。可使用 str_view() 查看，显示的是实际字符，而不是转义形式：\nx &lt;- c(single_quote, double_quote, backslash)\nstr_view(x)\n[1] │ '\n[2] │ \"\n[3] │ \\\n另有其他转义符如下：\n\n\n\n转义序列\n含义\n\n\n\n\n\\n\n换行符\n\n\n\\t\n制表符\n\n\n\\uXXXX\nUnicode 字符\n\n\n\nx &lt;- c(\"one\\ntwo\", \"one\\ttwo\", \"\\u00b5\", \"\\U0001f604\")\nstr_view(x)\n[1] │ one\n    │ two\n[2] │ one{\\t}two\n[3] │ µ\n[4] │ 😄\n\n其中 {} 是 str_view() 用来清晰显示不可见字符（如 tab）的可视化处理方式。\n\n字符串中若包含大量引号或反斜杠（如嵌入代码片段），会出现所谓“倾斜牙签综合征”（leaning toothpick syndrome），即转义符过多导致难以阅读。可用原始字符串语法解决。\n原始字符串以 r\"()\" 包裹，括号内部的转义符失效。如 \\n 不会被解释为换行，而是字面意义上的两个字符。但是若内容中包含 )\"，仍需规避，可使用 r\"[]\"、r\"{}\" 或r\"---()---\"，提高灵活性。",
    "crumbs": [
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>字符串处理</span>"
    ]
  },
  {
    "objectID": "chapters/ch14_strings.html#构造字符串",
    "href": "chapters/ch14_strings.html#构造字符串",
    "title": "14  字符串处理",
    "section": "14.3 构造字符串",
    "text": "14.3 构造字符串\nstr_c()函数用于拼接字符串。它可接收若干向量作为参数，返回一个字符向量。例如：\nstr_c(\"x\", \"y\", \"z\")           # \"xyz\"\nstr_c(\"Hello \", c(\"John\", \"Susan\"))\n#&gt; \"Hello John\" \"Hello Susan\"\nstr_c(c(\"Hello \",\"Hi \"), c(\"John\", \"Susan\"))\n#&gt; \"Hello John\" \"Hi Susan\"  \n适用于mutate()，且合理处理缺失值 NA：\ndf &lt;- tibble(name = c(\"Flora\", \"David\", \"Terra\", NA))\ndf |&gt; mutate(greeting = str_c(\"Hi \", name, \"!\"))\n#&gt; name    greeting\n#&gt; Flora   Hi Flora!\n#&gt; David   Hi David!\n#&gt; Terra   Hi Terra!\n#&gt; NA      NA\ncoalesce() 函数可以用自定义值替换缺失值：\ndf |&gt; \n  mutate(\n    greeting1 = str_c(\"Hi \", coalesce(name, \"you\"), \"!\"),\n    greeting2 = coalesce(str_c(\"Hi \", name, \"!\"), \"Hi!\")\n  )\n\ngreeting1：缺失值用 \"you\" 代替，结果是 \"Hi you!\"\ngreeting2：拼接结果为 NA 时整体替换为 \"Hi!\"\n\n使用 str_c() 拼接多个变量和文字，会写很多 \" 和 ,，可读性差。这时可以使用 glue 包提供的 str_glue() 函数：\ndf |&gt; mutate(greeting = str_glue(\"Hi {name}!\"))\n#&gt; Flora   Hi Flora!\n#&gt; David   Hi David!\n#&gt; NA      Hi NA!\n\n{} 中嵌入变量名\n缺失值会被转为字符串 \"NA\"（注意与 str_c() 会生成 NA不同）\n\n如果要在字符串中保留大括号 {} 本身，需要使用双大括号转义：\nstr_glue(\"{{Hi {name}!}}\")\n#&gt; \"{Hi Flora!}\" ...\n在 summarize() 中将多个字符串合并，使用 str_flatten()。\nstr_flatten(c(\"x\", \"y\", \"z\"))                      # \"xyz\"\nstr_flatten(c(\"x\", \"y\", \"z\"), \", \")                # \"x, y, z\"\nstr_flatten(c(\"x\", \"y\", \"z\"), \", \", last = \", and \")\n#&gt; \"x, y, and z\"",
    "crumbs": [
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>字符串处理</span>"
    ]
  },
  {
    "objectID": "chapters/ch14_strings.html#从字符串中提取数据",
    "href": "chapters/ch14_strings.html#从字符串中提取数据",
    "title": "14  字符串处理",
    "section": "14.4 从字符串中提取数据",
    "text": "14.4 从字符串中提取数据\n工作中经常会遇到多个变量挤在一个字符串中的情况。tidyr 提供了四个主力函数来提取这些变量：\nseparate_longer_delim()      # 按分隔符拆分为多行\nseparate_longer_position()   # 按固定宽度拆分为多行\nseparate_wider_delim()       # 按分隔符拆分为多列\nseparate_wider_position()    # 按固定宽度拆分为多列\n\nlonger → 把一列拆成多行\nwider → 把一列拆成多列\ndelim → 用分隔符\nposition → 用固定宽度\n\n拆成多行适用于每行元素个数不固定的情况。\ndf1 &lt;- tibble(x = c(\"a,b,c\", \"d,e\", \"f\"))\ndf1 |&gt; \n  separate_longer_delim(x, delim = \",\")\n#&gt; # A tibble: 6 × 1\n#&gt;   x    \n#&gt;   &lt;chr&gt;\n#&gt; 1 a    \n#&gt; 2 b    \n#&gt; 3 c    \n#&gt; 4 d    \n#&gt; 5 e    \n#&gt; 6 f\n拆成多列适用于每个字符串的成分数固定，且需要展开为多个列的情况。\ndf3 &lt;- tibble(x = c(\"a10.1.2022\", \"b10.2.2011\", \"e15.1.2015\"))\ndf3 |&gt; \n  separate_wider_delim(\n    x,\n    delim = \".\",\n    names = c(\"code\", \"edition\", \"year\")\n  )\n#&gt; # A tibble: 3 × 3\n#&gt;   code  edition year \n#&gt;   &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;\n#&gt; 1 a10   1       2022 \n#&gt; 2 b10   2       2011 \n#&gt; 3 e15   1       2015\n如果某一部分不需要保留，用 NA 占位即可：\ndf3 |&gt; \n  separate_wider_delim(\n    x,\n    delim = \".\",\n    names = c(\"code\", NA, \"year\")\n  )\n#&gt; # A tibble: 3 × 2\n#&gt;   code  year \n#&gt;   &lt;chr&gt; &lt;chr&gt;\n#&gt; 1 a10   2022 \n#&gt; 2 b10   2011 \n#&gt; 3 e15   2015\n有时警告拆分失败，需要进行排查。\n\n组件数量不足（too few）\n\ndf &lt;- tibble(x = c(\"1-1-1\", \"1-1-2\", \"1-3\", \"1-3-2\", \"1\"))\n\ndf |&gt; separate_wider_delim(\n  x,\n  delim = \"-\",\n  names = c(\"x\", \"y\", \"z\")\n)\n出现报错：某些行只有1或2个字段，不足3个。\n使用 too_few = \"debug\" 进入调试模式：\ndebug &lt;- df |&gt; \n  separate_wider_delim(\n    x,\n    delim = \"-\",\n    names = c(\"x\", \"y\", \"z\"),\n    too_few = \"debug\"\n  )\n#&gt; Warning: Debug mode activated: adding variables `x_ok`, `x_pieces`, and\n#&gt; `x_remainder`.\ndebug\n# A tibble: 5 × 6\n  x     y     z     x_ok  x_pieces x_remainder\n  &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;lgl&gt;    &lt;int&gt; &lt;chr&gt;      \n1 1-1-1 1     1     TRUE         3 \"\"         \n2 1-1-2 1     2     TRUE         3 \"\"         \n3 1-3   3     NA    FALSE        2 \"\"         \n4 1-3-2 3     2     TRUE         3 \"\"         \n5 1     NA    NA    FALSE        1 \"\"         \n新增列说明：\n\nx_ok：是否符合预期\nx_pieces：实际字段数量\nx_remainder：剩余没分配的部分（对 too_many 更有用）\n\n可以用 filter(!x_ok) 快速筛出异常行。\n若只是想补齐 NA 继续处理，可使用：\ntoo_few = \"align_start\" # 从左对齐，补 NA 到右边\ntoo_few = \"align_end\"   # 从右对齐，补 NA 到左边\n\n组件过多（too many）\n\ndf &lt;- tibble(x = c(\"1-1-1\", \"1-1-2\", \"1-3-5-6\", \"1-3-2\", \"1-3-5-7-9\"))\n\ndf |&gt; separate_wider_delim(\n  x,\n  delim = \"-\",\n  names = c(\"x\", \"y\", \"z\")\n)\n同样报错：有行多于3个字段。\n使用 too_many = \"debug\"开启调试：\ndebug &lt;- df |&gt; separate_wider_delim(\n  x,\n  delim = \"-\",\n  names = c(\"x\", \"y\", \"z\"),\n  too_many = \"debug\"\n)\ndebug\n# A tibble: 5 × 6\n  x         y     z     x_ok  x_pieces x_remainder\n  &lt;chr&gt;     &lt;chr&gt; &lt;chr&gt; &lt;lgl&gt;    &lt;int&gt; &lt;chr&gt;      \n1 1-1-1     1     1     TRUE         3 \"\"         \n2 1-1-2     1     2     TRUE         3 \"\"         \n3 1-3-5-6   3     5     FALSE        4 \"-6\"       \n4 1-3-2     3     2     TRUE         3 \"\"         \n5 1-3-5-7-9 3     5     FALSE        5 \"-7-9\"   \n可观察 x_remainder 中存放了多余部分。\n处理方法：\n\ntoo_many = \"drop\"：多余字段丢弃\ntoo_many = \"merge\"：合并多余字段到最后一列",
    "crumbs": [
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>字符串处理</span>"
    ]
  },
  {
    "objectID": "chapters/ch14_strings.html#字母与子串处理",
    "href": "chapters/ch14_strings.html#字母与子串处理",
    "title": "14  字符串处理",
    "section": "14.5 字母与子串处理",
    "text": "14.5 字母与子串处理\n本节介绍处理字符串中字母的基本函数。\n\nstr_length()函数用于返回字符串的字符个数（包括空格和标点）：\n\nstr_length(c(\"a\", \"R for data science\", NA))\n#&gt; [1]  1 18 NA\n例如要统计小孩名字长度，并查看最长的名字：\nbabynames |&gt;\n  count(length = str_length(name), wt = n)\nbabynames |&gt; \n  filter(str_length(name) == 15) |&gt; \n  count(name, wt = n, sort = TRUE)\n\nstr_sub()函数用于提取子串，基本参数如下：\n\nstr_sub(string, start, end)\n\n起始位置 start 和结束位置 end 为闭区间\n支持负数索引：-1 表示最后一个字符，-2 为倒数第二个，以此类推\n\n示例：\nx &lt;- c(\"Apple\", \"Banana\", \"Pear\")\nstr_sub(x, 1, 3)\n#&gt; [1] \"App\" \"Ban\" \"Pea\"\nstr_sub(x, -3, -1)\n#&gt; [1] \"ple\" \"ana\" \"ear\"\n如果长度不足，函数会尽量返回可取部分，而不会报错：\nstr_sub(\"a\", 1, 5)\n#&gt; [1] \"a\"\n例如要提取名字首字母与尾字母\nbabynames |&gt; \n  mutate(\n    first = str_sub(name, 1, 1),\n    last = str_sub(name, -1, -1)\n  )",
    "crumbs": [
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>字符串处理</span>"
    ]
  },
  {
    "objectID": "chapters/ch14_strings.html#非英文文本处理",
    "href": "chapters/ch14_strings.html#非英文文本处理",
    "title": "14  字符串处理",
    "section": "14.6 非英文文本处理",
    "text": "14.6 非英文文本处理\n之前的内容主要处理英文文本。因为英文相对简单，原因有二：\n\n英文只有26个基础字母；\n计算机编码标准（如 ASCII）是由英语国家设计的，更偏向英文语境。\n\n处理非英语文本难免遇到意料之外的难题，包括字符编码问题、带变音符的字母、地区敏感的字符串排序与大小写转换。\n\n字符编码\n\n字符编码决定了字符如何在底层以数字（字节）表示。\ncharToRaw(\"Hadley\")\n#&gt; [1] 48 61 64 6c 65 79\n这是 ASCII 编码，每个字符一个字节（如 48 对应 H）。\n如今通用编码是 UTF-8，可表达几乎所有语言的字符与表情符号（emoji）\n读取非UTF-8编码数据：\nread_csv(x1, locale = locale(encoding = \"Latin1\"))\nread_csv(x2, locale = locale(encoding = \"Shift-JIS\"))\n如何判断编码？\n使用 guess_encoding() 可自动推测，建议在字符量较大的文本上使用。\n\n若文本打印乱码（比如所谓“锟斤拷”），通常就是编码不匹配。\n\n\n字母变体\n\n带变音符的字母（如 ü）可能存在两种编码方式：\n\n单字符（预组合）：\\u00fc\n双字符（分解组合）：\"u\" + \"\\u0308\"\n\nu &lt;- c(\"\\u00fc\", \"u\\u0308\")\nstr_length(u)\n#&gt; [1] 1 2\nstr_sub(u, 1, 1)\n#&gt; [1] \"ü\" \"u\"\n可见虽然视觉上一样，但实际上字符长度、内容不同。\n\n函数的地区敏感性\n\nlocale（语言-地区标识）会影响大小写转换与排序函数。此处不作赘述。",
    "crumbs": [
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>字符串处理</span>"
    ]
  },
  {
    "objectID": "chapters/ch15_regular_expressions.html",
    "href": "chapters/ch15_regular_expressions.html",
    "title": "15  正则表达式",
    "section": "",
    "text": "15.1 引言\n正则表达式是一种描述字符串模式的简洁且常用的语言。简称为 regex 或 regexp。\n本章要用到的包如下：\n要用到以下三个 R 自带的字符串：",
    "crumbs": [
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>正则表达式</span>"
    ]
  },
  {
    "objectID": "chapters/ch15_regular_expressions.html#引言",
    "href": "chapters/ch15_regular_expressions.html#引言",
    "title": "15  正则表达式",
    "section": "",
    "text": "library(tidyverse)\nlibrary(babynames) #包含婴儿名字数据\n\n\nfruit：80 种水果；\nwords：980 个英文常见词；\nsentences：720 个简短英文句子。",
    "crumbs": [
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>正则表达式</span>"
    ]
  },
  {
    "objectID": "chapters/ch15_regular_expressions.html#基础模式",
    "href": "chapters/ch15_regular_expressions.html#基础模式",
    "title": "15  正则表达式",
    "section": "15.2 基础模式",
    "text": "15.2 基础模式\nstr_view() 是学习 regex 的利器。它可以可视化匹配内容，将匹配的部分用 &lt; &gt; 包裹并高亮。以下对常见字符进行逐个说明。\n\n最简单的正则表达式是字母或数字，直接匹配对应字符，称为字面匹配（Literal Match）：\n\nstr_view(fruit, \"berry\")\n某些符号（如 .、+、*、[ ]、? 等）具有特殊含义，称为元字符（metacharacters）。\n\n. 匹配任意单字符：\n\nstr_view(fruit, \"a...e\")  # 匹配“a开头，后跟任意三个字符，e结尾”的词\n\n下面三个符号称为量词（Quantifiers），匹配指定字符若干次：\n\n\n\n\n符号\n含义\n\n\n\n\n?\n匹配 0 或 1 次（可选）\n\n\n+\n匹配 ≥1 次（至少一次）\n\n\n*\n匹配 ≥0 次（可选+可重复）\n\n\n\n# ab? 表示匹配一个a，后可加可不加一个b\nstr_view(c(\"a\", \"ab\", \"abb\"), \"ab?\")\n#&gt; [1] │ &lt;a&gt;\n#&gt; [2] │ &lt;ab&gt;\n#&gt; [3] │ &lt;ab&gt;b\n\n# ab+ 表示匹配一个a，后加至少一个b\nstr_view(c(\"a\", \"ab\", \"abb\"), \"ab+\")\n#&gt; [2] │ &lt;ab&gt;\n#&gt; [3] │ &lt;abb&gt;\n\n# ab* 表示匹配一个a，后加任意数目的b（可无b）\nstr_view(c(\"a\", \"ab\", \"abb\"), \"ab*\")\n#&gt; [1] │ &lt;a&gt;\n#&gt; [2] │ &lt;ab&gt;\n#&gt; [3] │ &lt;abb&gt;\n\n[] 称为字符类（Character Classes），指定匹配多个字符之一：\n\n[abcd]   # 匹配 a 或 b 或 c 或 d\n[^abcd]  # 匹配不含 a/b/c/d 字符\n示例：寻找中间是 x 且两边为元音的词：\nstr_view(words, \"[aeiou]x[aeiou]\")\n\n| 称为操作符（Alternation），表示多个可选模式：\n\nstr_view(fruit, \"apple|melon|nut\")\n示例：匹配含有指定关键词的水果：\npine&lt;apple&gt;, rock &lt;melon&gt;, coco&lt;nut&gt;",
    "crumbs": [
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>正则表达式</span>"
    ]
  },
  {
    "objectID": "chapters/ch15_regular_expressions.html#关键函数",
    "href": "chapters/ch15_regular_expressions.html#关键函数",
    "title": "15  正则表达式",
    "section": "15.3 关键函数",
    "text": "15.3 关键函数\n在掌握正则基础之后，可结合函数进行实用数据处理。\n\n检测匹配\n\nstr_detect() 函数返回逻辑向量，判断字符串中是否匹配某个正则模式。\nstr_detect(c(\"a\", \"b\", \"c\"), \"[aeiou]\")\n#&gt; [1] TRUE FALSE FALSE\n常与 filter() 结合使用，示例：查找包含小写 “x” 的人名并按使用次数降序排列：\nbabynames |&gt; \n  filter(str_detect(name, \"x\")) |&gt; \n  count(name, wt = n, sort = TRUE)\n#&gt; # A tibble: 974 × 2\n#&gt;   name           n\n#&gt;   &lt;chr&gt;      &lt;int&gt;\n#&gt; 1 Alexander 665492\n#&gt; 2 Alexis    399551\n#&gt; 3 Alex      278705\n#&gt; 4 Alexandra 232223\n#&gt; 5 Max       148787\n#&gt; 6 Alexa     123032\n#&gt; # ℹ 968 more rows\n可以将 str_detect() 与 summarize() 结合使用，通过 sum() 或 mean() 来统计匹配情况：\n\nsum(str_detect(x, pattern))：返回匹配该正则表达式的观测值总数（即有多少个元素匹配）；\nmean(str_detect(x, pattern))：返回匹配比例，即匹配元素占所有元素的百分比。\n\n例如，以下代码统计并可视化了每年中包含字母 “x” 的婴儿名字所占的比例：\nbabynames |&gt; \n  group_by(year) |&gt; \n  summarize(prop_x = mean(str_detect(name, \"x\"))) |&gt; \n  ggplot(aes(year, prop_x)) + \n  geom_line()\n\n\n计数匹配\n\nstr_count() 返回每个字符串中匹配模式出现的次数：\nx &lt;- c(\"apple\", \"banana\", \"pear\")\nstr_count(x, \"p\")\n#&gt; [1] 2 0 1\n需要注意，匹配的字段之间是不重叠计算的：\nstr_count(\"abababa\", \"aba\")\n#&gt; [1] 2\n示例：统计人名中的元音和辅音数量\nbabynames |&gt; \n  count(name) |&gt; \n  mutate(\n    vowels = str_count(name, \"[aeiou]\"),\n    consonants = str_count(name, \"[^aeiou]\")\n  )\n上例结果偏小，因为正则默认区分大小写，可通过以下方式修正：\n\n同时匹配大写字符：\"[aeiouAEIOU]\"\n忽略大小写：regex(\"[aeiou]\", ignore_case = TRUE)\n预处理为小写：str_to_lower(name)\n\n\n替换值\n\n使用 str_replace() 和 str_replace_all() 替换匹配的文本：\nx &lt;- c(\"apple\", \"pear\", \"banana\")\nstr_replace_all(x, \"[aeiou]\", \"-\")\n#&gt; [1] \"-ppl-\"  \"p--r\"   \"b-n-n-\"\n删除匹配的内容可用 str_remove() / str_remove_all()：\ntr_remove_all(x, \"[aeiou]\")\n#&gt; [1] \"ppl\" \"pr\"  \"bnn\"\n这些函数常用于 mutate() 中进行数据清洗，通常需要多次重复处理以处理格式不一致的情况。\n\n提取变量\n\n使用 separate_wider_regex() 可将结构化的字符串拆成多列。\n示例数据：\ndf &lt;- tribble(\n  ~str,\n  \"&lt;Sheryl&gt;-F_34\",\n  \"&lt;Kisha&gt;-F_45\", \n  \"&lt;Brandon&gt;-N_33\",\n  \"&lt;Sharon&gt;-F_38\", \n  \"&lt;Penny&gt;-F_58\",\n  \"&lt;Justin&gt;-M_41\", \n  \"&lt;Patricia&gt;-F_84\"\n)\n提取其中的人名、性别和年龄：\ndf |&gt; \n  separate_wider_regex(\n    str,\n    patterns = c(\n      \"&lt;\", \n      name = \"[A-Za-z]+\", \n      \"&gt;-\", \n      gender = \".\", \n      \"_\", \n      age = \"[0-9]+\"\n    )\n  )\n结果：\n# A tibble: 7 × 3\n  name      gender age  \n  &lt;chr&gt;     &lt;chr&gt;  &lt;chr&gt;\n1 Sheryl    F      34   \n2 Kisha     F      45   \n3 Brandon   N      33   \n4 Sharon    F      38   \n5 Penny     F      58   \n6 Justin    M      41   \n7 Patricia  F      84\n\n使用 too_few = \"debug\" 可以定位匹配失败的原因。",
    "crumbs": [
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>正则表达式</span>"
    ]
  },
  {
    "objectID": "chapters/ch15_regular_expressions.html#模式细节",
    "href": "chapters/ch15_regular_expressions.html#模式细节",
    "title": "15  正则表达式",
    "section": "15.4 模式细节",
    "text": "15.4 模式细节\n\n转义（Escaping）\n\n像字符串一样，正则表达式使用反斜杠 \\ 进行转义。所以，为了匹配字面上的 .，需要使用正则表达式 \\.。问题在于，我们是用字符串来表示正则表达式的，而字符串中 \\ 同样是转义符。因此，要表示正则表达式 \\.，需要写成字符串 \"\\\\.\"。我将此总结为“嵌套式双重转义”。如下为例：\ndot &lt;- \"\\\\.\"\nstr_view(dot) \n#&gt; [1] │ \\.\n\nstr_view(c(\"abc\", \"a.c\", \"bef\"), \"a\\\\.c\")  # 匹配字面值 a.c\n#&gt; [2] │ &lt;a.c&gt;\n若要匹配字面上的 \\ 本身，同样需要进行转义，即正则表达式为 \\\\。由于字符串中也需转义 \\，所以最终写法是 \"\\\\\\\\\"，即 4 个反斜杠代表一个字面上的 \\：\nx &lt;- \"a\\\\b\"\nstr_view(x)\n#&gt; [1] │ a\\b\n\nstr_view(x, \"\\\\\\\\\")\n#&gt; [1] │ a&lt;\\&gt;b\n为避免多重嵌套转义的混乱，也可以使用原始字符串语法：\nstr_view(x, r\"{\\\\}\")\n#&gt; [1] │ a&lt;\\&gt;b\n此外，对于诸如 .、$、|、*、+、 ?、 {、}、(、 ) 等特殊字符，也可使用字符类 [.]、[$] 等方式表示其字面值：\nstr_view(c(\"abc\", \"a.c\", \"a*c\", \"a c\"), \"a[.]c\")\n#&gt; [2] │ &lt;a.c&gt;\n\nstr_view(c(\"abc\", \"a.c\", \"a*c\", \"a c\"), \".[*]c\")\n#&gt; [3] │ &lt;a*c&gt;\n\n锚点（Anchors）\n\n默认情况下，正则表达式会匹配字符串中的任意部分。若希望仅匹配字符串开头或结尾，可使用锚点 ^（匹配开头）和 $（匹配结尾）：\nstr_view(fruit, \"^a\")   # 以a开头的字符串\n#&gt; [1] │ &lt;a&gt;pple\n#&gt; [2] │ &lt;a&gt;pricot\n#&gt; [3] │ &lt;a&gt;vocado\n\nstr_view(fruit, \"a$\")   # 以a结尾的字符串\n#&gt; [4] │ banan&lt;a&gt;\n#&gt; [15] │ cherimoy&lt;a&gt;\n#&gt; ...\n\n虽然 $ 常被用在金额表示中放在前面，但在正则中，它表示结尾。\n\n若希望整个字符串完全匹配某模式，同时使用 ^ 与 $即可：\nstr_view(fruit, \"apple\")\n#&gt; [1] │ &lt;apple&gt;\n#&gt; [62] │ pine&lt;apple&gt;\nstr_view(fruit, \"^apple$\")\n#&gt; [1] │ &lt;apple&gt;\n\\b 可用于匹配单词边界（即单词的开头或结尾），常用于避免误匹配。例如搜索 sum() 时避免匹配 summary、rowsum 等：\nx &lt;- c(\"summary(x)\", \"summarize(df)\", \"rowsum(x)\", \"sum(x)\")\nstr_view(x, \"\\\\bsum\\\\b\") # 注意转义\n#&gt; [4] │ &lt;sum&gt;(x)\n锚点本身是零宽度匹配：\nstr_view(\"abc\", c(\"$\", \"^\", \"\\\\b\"))\n#&gt; [1] │ abc&lt;&gt;\n#&gt; [2] │ &lt;&gt;abc\n#&gt; [3] │ &lt;&gt;abc&lt;&gt;\n\n字符类（Character Classes）\n\n字符类用于匹配集合中的任一字符。可用 [] 来构造，例如 [abc] 匹配 a、b 或 c，[^abc] 匹配除这三者外的任意字符。在 [] 内部，除 ^ 外，还有两个具有特殊含义的字符：\n\n- 表示范围，如 [a-z] 表示小写字母，[0-9] 表示数字；\n\\ 用于转义特殊字符，如 [\\^\\-\\]] 匹配 ^、-、]。\n\n常见的字符类还有简写形式：\n\n\\d：数字，\\D：非数字；\n\\s：空白字符，\\S：非空白；\n\\w：字母或数字，\\W：非字母或数字。\n\n\n量词（Quantifiers）\n\n量词控制某模式匹配的次数。 ?（0 或 1 次）、+（1 次或多次）、*（0 次或多次）。此外，{} 可指定更精确的匹配次数：\n\n{n}：恰好匹配 n 次；\n{n,}：至少 n 次；\n{n,m}：匹配 n 到 m 次之间。\n\n\n运算符优先级与括号\n\n表达式 ab+ 是匹配 “a” 后接多个 “b”，还是多次匹配 “ab”？表达式 ^a|b$ 是匹配 “完整的 a 或 b”，还是 “以 a 开头或以 b 结尾”？\n这取决于运算符优先级，就像算术中乘除优先加减一样。正则表达式中，量词优先级高，| 优先级低。因此：\n\nab+ 等价于 a(b+)；\n^a|b$ 等价于 (^a)|(b$)。\n\n为了避免歧义，建议使用括号明确结构。\n\n分组与捕获（Grouping and Capturing）\n\n括号不仅可以控制优先级，还能创建“捕获组”（capturing group），形如(...)，以便在后续使用匹配子模式的结果。\n\\1 表示与第一个括号的内容相同，\\2 表示第二个，以此类推：\nstr_view(fruit, \"(..)\\\\1\") # 找出两个连续字符重复的单词\n#&gt; banana, coconut, cucumber, etc.\n\nstr_view(words, \"^(..).*\\\\1$\") # 找出首尾两个字符一样的单词\n#&gt; church, decide, photograph, etc.\n可以在 str_replace() 中使用捕获组交换位置。例如将一句话第二个词和第三个词调个顺序：\nsentences |&gt;\n  str_replace(\"(\\\\w+) (\\\\w+) (\\\\w+)\", \"\\\\1 \\\\3 \\\\2\") |&gt;\n  str_view()\n\nw+表示字母或数字类\n\n若要提取每个组的匹配结果，使用 str_match()：\nstr_match(\"the (\\\\w+) (\\\\w+)\") \n除了捕获组，还可使用非捕获组，形如 (?:...)，只用于匹配，不保存匹配内容，不会出现在 \\\\1 里。\nstr_match(x, \"gr(?:e|a)y\")\n#&gt; \"gray\", \"grey\"",
    "crumbs": [
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>正则表达式</span>"
    ]
  },
  {
    "objectID": "chapters/ch15_regular_expressions.html#模式控制",
    "href": "chapters/ch15_regular_expressions.html#模式控制",
    "title": "15  正则表达式",
    "section": "15.5 模式控制",
    "text": "15.5 模式控制\n有一些设置可以用来调整正则表达式的细节，这在其他语言中通常被称为 flags（标志）。可以通过 regex() 函数将字符串包裹起来来使用这些设置。\n最常用的标志有：\n\nignore_case = TRUE：忽略大小写\n\nbananas &lt;- c(\"banana\", \"Banana\", \"BANANA\")\nstr_view(bananas, \"banana\")\n#&gt; 只匹配 \"banana\"\nstr_view(bananas, regex(\"banana\", ignore_case = TRUE))\n#&gt; 同时匹配 banana、Banana 和 BANANA\n\ndotall = TRUE：让 . 匹配换行符（\\n）\n\nx &lt;- \"Line 1\\nLine 2\\nLine 3\"\nstr_view(x, \".Line\") \nstr_view(x, regex(\".Line\", dotall = TRUE))\n\n下面一行的代码将正则表达式 .Line 改写为允许点号 . 匹配换行符，即让点号真正变成“匹配任意字符（包括换行）”。这样就能跨越行与行之间的 \\n，成功匹配 \\nL 这种中间有换行的情况。\n\n\nmultiline = TRUE：让 ^ 和 $ 匹配每一行的开头和结尾。\n\nx &lt;- \"Line 1\\nLine 2\\nLine 3\"\nstr_view(x, \"^Line\")  # 默认只匹配第一行\nstr_view(x, regex(\"^Line\", multiline = TRUE))\n#&gt; 匹配每一行的 Line\n\ncomments = TRUE：允许使用空格和注释来增强可读性\n\n可以在正则表达式中添加空格和 # 注释来解释每一部分。这些空格默认会被忽略，如要匹配空格或 #，则需使用反斜杠转义。\nphone &lt;- regex(\n  r\"(\n    \\(?     # 可选的左括号\n    (\\d{3}) # 三位区号\n    [)\\-]?  # 可选的右括号或短横线\n    \\ ?     # 可选空格\n    (\\d{3}) # 三位号码\n    [\\ -]?  # 可选空格或短横线\n    (\\d{4}) # 四位号码\n  )\",\n  comments = TRUE\n)\n\nstr_extract(c(\"514-791-8141\", \"(123) 456 7890\", \"123456\"), phone)\n#&gt; 提取出电话号码\n除了 regex() 函数包裹的标志设置，还可以通过 fixed() 函数来关闭正则表达式的规则，直接按字面意义匹配：\nstr_view(c(\"\", \"a\", \".\"), fixed(\".\"))\n#&gt; 只匹配真正的 “.” 字符\n也可以配合 ignore_case = TRUE 忽略大小写：\nstr_view(\"x X\", fixed(\"X\", ignore_case = TRUE))\n#&gt; 匹配 x 和 X\nstr_view(\"i İ ı I\", fixed(\"İ\", ignore_case = TRUE))\n#&gt; 在默认",
    "crumbs": [
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>正则表达式</span>"
    ]
  }
]